<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process Control Block | Nagih | Blog</title>
<meta name=keywords content="pcb"><meta name=description content="Khối Quản lý Tiến trình (PCB) - &ldquo;CMND&rdquo; của Mọi Chương trình trong Máy tính"><meta name=author content="Nagih"><link rel=canonical href=https://blog.nagih.io.vn/posts/process-control-block/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://blog.nagih.io.vn/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.nagih.io.vn/posts/process-control-block/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.nagih.io.vn/posts/process-control-block/"><meta property="og:site_name" content="Nagih | Blog"><meta property="og:title" content="Process Control Block"><meta property="og:description" content="Khối Quản lý Tiến trình (PCB) - “CMND” của Mọi Chương trình trong Máy tính"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-05T00:00:00+00:00"><meta property="article:tag" content="Pcb"><meta property="og:image" content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Process Control Block"><meta name=twitter:description content="Khối Quản lý Tiến trình (PCB) - &ldquo;CMND&rdquo; của Mọi Chương trình trong Máy tính"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nagih.io.vn/posts/"},{"@type":"ListItem","position":2,"name":"Process Control Block","item":"https://blog.nagih.io.vn/posts/process-control-block/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Process Control Block","name":"Process Control Block","description":"Khối Quản lý Tiến trình (PCB) - \u0026ldquo;CMND\u0026rdquo; của Mọi Chương trình trong Máy tính\n","keywords":["pcb"],"articleBody":"Khối Quản lý Tiến trình (PCB) - “CMND” của Mọi Chương trình trong Máy tính\nGiới thiệu Hệ điều hành (Operating System - OS). Để quản lý từng mỗi chương trình đang chạy, hay còn gọi là process, process cần một bản thông tin chi tiết về từng thành viên. Bản thông tin này chính là Khối Quản lý Tiến trình (Process Control Block - PCB).\nĐể dễ hình dung nhất, hãy coi PCB chính là “Chứng minh nhân dân” (CMND) hay “Căn cước công dân” (CCCD) của một tiến trình. Đó là một tấm thẻ định danh chứa đựng mọi thông tin sống còn mà hệ điều hành cần để quản lý, giám sát và điều khiển tiến trình đó. Nếu không có “tấm thẻ” này, một tiến trình sẽ trở nên vô danh và không thể quản lý được đối với hệ điều hành.\n1. Khối Quản lý Tiến trình (PCB) chính xác là gì? Dấu vân tay Kỹ thuật số Về mặt hình thức, PCB là một cấu trúc dữ liệu cơ bản nằm trong nhân (kernel) của hệ điều hành. Nó còn được biết đến với các tên gọi khác như “Bộ mô tả Tiến trình” (Process Descriptor) hay “Khối điều khiển Tác vụ” (Task Control Block).5 Điều quan trọng cần nhấn mạnh là PCB không phải là một phần của chương trình người dùng viết ra; nó là một công cụ nội bộ, được tạo ra và sử dụng độc quyền bởi hệ điều hành để quản lý các tiến trình.\nVòng đời của một PCB Vòng đời của một PCB gắn liền với vòng đời của tiến trình mà nó đại diện:\nKhởi tạo: Ngay khi người dùng khởi chạy một ứng dụng (ví dụ, nhấp đúp vào biểu tượng Google Chrome), hệ điều hành sẽ tạo ra một tiến trình mới. Song song với đó, nó cấp phát bộ nhớ và khởi tạo một PCB tương ứng cho tiến trình này. Quản lý: Trong suốt thời gian tồn tại của tiến trình, hệ điều hành liên tục đọc và cập nhật thông tin trong PCB của nó khi trạng thái và việc sử dụng tài nguyên thay đổi. Kết thúc: Khi tiến trình hoàn thành nhiệm vụ hoặc bị chấm dứt, hệ điều hành sẽ thu hồi tất cả tài nguyên của nó và phá hủy PCB, giải phóng bộ nhớ đã cấp phát. Lưu trữ An toàn PCB chứa những thông tin cực kỳ quan trọng đối với sự ổn định của hệ thống. Do đó, nó được lưu trữ trong một vùng bộ nhớ được bảo vệ đặc biệt gọi là “không gian nhân” (kernel space). Cơ chế bảo vệ này ngăn chặn các chương trình người dùng truy cập và sửa đổi (dù vô tình hay cố ý) dữ liệu điều khiển của chính chúng hoặc của các tiến trình khác, một hành động có thể gây sập toàn bộ hệ thống.\nBảng Tiến trình (Process Table) Để theo dõi tất cả các tiến trình đang hoạt động, hệ điều hành duy trì một danh sách tổng thể, thường được gọi là Bảng Tiến trình (Process Table). Về cơ bản, đây là một mảng hoặc danh sách liên kết chứa các con trỏ trỏ đến từng PCB của mọi tiến trình đang hoạt động trong hệ thống. Bảng này giống như một cuốn danh bạ mà hệ điều hành dùng để tra cứu mọi tiến trình mà nó đang quản lý.\nTừ góc độ của nhân hệ điều hành, PCB không chỉ đơn thuần là một bản ghi thông tin; nó chính là hiện thân của tiến trình. Một chương trình trên đĩa cứng (ví dụ: chrome.exe) chỉ là một tập hợp các chỉ thị thụ động. Một tiến trình là sự thực thi\nchủ động của những chỉ thị đó. Và PCB chính là cấu trúc dữ liệu cụ thể hóa “sự chủ động” này. Nó là thực thể hữu hình, có thể quản lý được mà hệ điều hành tương tác. Tất cả các hành động quản lý của OS—lập lịch, cấp phát tài nguyên, chấm dứt—đều là các hoạt động được thực hiện trên hoặc dựa vào dữ liệu chứa trong PCB. Do đó, có thể nói rằng PCB là linh hồn kỹ thuật số, là bản chất của một tiến trình trong mắt hệ điều hành.\n2. Giải phẫu PCB - Nhìn vào bên trong “Tấm thẻ Căn cước” Mặc dù cấu trúc chính xác có thể khác nhau giữa các hệ điều hành (ví dụ, Linux và Windows), các loại thông tin cốt lõi về cơ bản là giống nhau. Chúng ta sẽ tiếp tục sử dụng phép ẩn dụ “Tấm thẻ Căn cước” để làm rõ mục đích của từng thành phần.\nPhân tích chi tiết các thành phần Thông tin Nhận dạng (Process Identification Data): Mã định danh Tiến trình (Process ID - PID): Một số nguyên duy nhất do hệ điều hành cấp để xác định tiến trình. Đây là trường thông tin quan trọng nhất, được sử dụng làm khóa trong hầu hết các bảng hệ thống khác. Ví von: Số CMND/CCCD duy nhất trên thẻ căn cước. Mã định danh Tiến trình Cha (Parent Process ID - PPID): PID của tiến trình đã tạo ra tiến trình này. Điều này thiết lập một cấu trúc phân cấp dạng cây cho các tiến trình. Mã định danh Người dùng (User ID - UID) \u0026 Nhóm (Group ID - GID): Xác định người dùng và nhóm sở hữu tiến trình, được sử dụng cho mục đích bảo mật và phân quyền. Trạng thái Tiến trình (Process State): Một trường ghi lại trạng thái hiện tại của tiến trình. Thông tin này rất quan trọng để bộ lập lịch biết được tiến trình nào đủ điều kiện để chạy. Mới (New): Tiến trình đang được tạo. Sẵn sàng (Ready): Tiến trình đã được nạp vào bộ nhớ và đang chờ đến lượt được cấp CPU. Đang chạy (Running): Các chỉ thị của tiến trình đang được thực thi bởi một lõi CPU. Đang chờ/Bị chặn (Waiting/Blocked): Tiến trình không thể tiếp tục cho đến khi một sự kiện nào đó xảy ra (ví dụ: chờ người dùng nhập liệu hoặc chờ đọc dữ liệu từ đĩa). Kết thúc (Terminated): Tiến trình đã hoàn thành và đang trong quá trình dọn dẹp. Ngữ cảnh Thực thi (Execution Context): Bộ đếm Chương trình (Program Counter - PC): Lưu địa chỉ bộ nhớ của chỉ thị tiếp theo sẽ được thực thi. Đây là yếu tố sống còn để có thể tiếp tục một tiến trình sau khi nó bị gián đoạn. Ví von: Một chiếc kẹp đánh dấu trang sách. Nó cho bạn biết chính xác cần bắt đầu đọc lại từ đâu. Các thanh ghi CPU (CPU Registers): Một bản sao lưu (snapshot) nội dung của các thanh ghi đa dụng, con trỏ ngăn xếp (stack pointer), v.v., của CPU tại thời điểm tiến trình bị ngắt. Các thanh ghi này chứa dữ liệu trung gian của các phép tính hiện tại. Ví von: Những dòng ghi chú trên giấy nháp khi đang giải một bài toán phức tạp. Bạn cần lưu chúng lại để có thể tiếp tục bài toán sau đó. Thông tin Quản lý Tài nguyên (Resource Management Information): Thông tin Lập lịch CPU (CPU Scheduling Information): Dữ liệu được bộ lập lịch của hệ điều hành sử dụng để quyết định tiến trình nào sẽ chạy tiếp theo. Bao gồm độ ưu tiên của tiến trình, con trỏ đến các hàng đợi lập lịch mà nó đang tham gia, và các tham số khác. Ví von: Nhóm lên máy bay hoặc hạng vé của hành khách (ví dụ: VIP, Thương gia, Phổ thông) quyết định thứ tự lên máy bay. Thông tin Quản lý Bộ nhớ (Memory Management Information): Thông tin về bộ nhớ được cấp phát cho tiến trình này, chẳng hạn như con trỏ đến bảng trang (page tables) hoặc bảng phân đoạn (segment tables) của nó. Điều này xác định không gian địa chỉ của tiến trình và ngăn nó truy cập vào bộ nhớ của các tiến trình khác. Ví von: Sổ đỏ hoặc giấy tờ nhà đất, xác định ranh giới của một mảnh đất. Thông tin Trạng thái I/O (I/O Status Information): Danh sách các thiết bị I/O được cấp phát cho tiến trình (ví dụ: một máy in cụ thể) và danh sách các tệp tin mà nó đang mở. Ví von: Một thẻ thư viện ghi lại những cuốn sách đang được mượn, hoặc danh sách các công cụ đã mượn từ một xưởng làm việc. Thông tin Kế toán (Accounting Information): Theo dõi việc sử dụng tài nguyên, chẳng hạn như lượng thời gian CPU mà tiến trình đã tiêu thụ, giới hạn thời gian, v.v. Thông tin này có thể được sử dụng để giám sát hệ thống hoặc tính phí trong môi trường doanh nghiệp. Ví von: Chi tiết sử dụng trên hóa đơn tiện ích (ví dụ: số kilowatt-giờ điện đã dùng). Bảng: Giải phẫu “Tấm thẻ Căn cước” của một Tiến trình Bảng dưới đây tóm tắt các thành phần chính của PCB và phép ví von tương ứng, giúp củng cố khái niệm một cách trực quan.\nComponent (Thành phần) Purpose (Mục đích) Analogy (Phép ví von) Process ID (PID) Một số duy nhất để nhận dạng tiến trình. Số CMND/CCCD Process State Hoạt động hiện tại của tiến trình (Đang chạy, Đang chờ, v.v.). Tình trạng hôn nhân (Độc thân, Đã kết hôn,…) Program Counter (PC) Địa chỉ của lệnh tiếp theo sẽ thực thi. Dấu trang sách (Bookmark) CPU Registers Lưu trữ dữ liệu tạm thời cho phép tính hiện tại. Giấy nháp (Scratchpad) Memory Info Chi tiết về việc cấp phát bộ nhớ của tiến trình. Sổ đỏ / Giấy tờ nhà đất I/O Status Info Danh sách các tệp tin và thiết bị đang sử dụng. Thẻ thư viện và các vật dụng đã mượn Scheduling Info Độ ưu tiên để truy cập CPU. Mức độ ưu tiên / Vé VIP Accounting Info Ghi lại tài nguyên đã tiêu thụ (ví dụ: thời gian CPU). Hóa đơn tiền điện/nước 3. PCB trong Thực tiễn - Phép màu của Đa nhiệm (Chuyển đổi Ngữ cảnh) Vai trò quan trọng nhất của PCB là cho phép đa nhiệm (multitasking) thông qua một cơ chế gọi là “chuyển đổi ngữ cảnh” (context switch).1 Chuyển đổi ngữ cảnh là quá trình hệ điều hành dừng một tiến trình và bắt đầu một tiến trình khác.2 Điều này xảy ra hàng trăm, thậm chí hàng nghìn lần mỗi giây, tạo ra ảo giác về sự thực thi song song.\nTác nhân Kích hoạt Một cuộc chuyển đổi ngữ cảnh không xảy ra ngẫu nhiên. Nó được kích hoạt bởi các sự kiện cụ thể 20:\nĐa nhiệm: “Lát cắt thời gian” (time slice hoặc quantum) của một tiến trình đã hết, và bộ lập lịch quyết định đã đến lượt một tiến trình khác (đa nhiệm phủ đầu - preemptive multitasking). Chờ I/O: Tiến trình đang chạy yêu cầu một tác vụ tốn thời gian (như đọc một tệp từ đĩa) và chuyển sang trạng thái “Chờ”, giải phóng CPU cho một tiến trình khác. Ngắt (Interrupts): Một ngắt phần cứng xảy ra (ví dụ: người dùng nhấp chuột), yêu cầu hệ điều hành phải xử lý, và việc này có thể liên quan đến việc chuyển sang một tiến trình khác. Quy trình từng bước của một cuộc Chuyển đổi Ngữ cảnh Hãy tưởng tượng CPU đang chạy Tiến trình A (ví dụ: Microsoft Word) và cần chuyển sang Tiến trình B (ví dụ: Google Chrome).\nNgắt Xảy ra: Một sự kiện (như ngắt từ bộ đếm thời gian) báo hiệu cần phải chuyển đổi. Phần cứng CPU tự động chuyển quyền điều khiển cho nhân hệ điều hành. Lưu Ngữ cảnh của Tiến trình A: Hệ điều hành ngay lập tức tạm dừng Tiến trình A. Sau đó, nó sao chép một cách tỉ mỉ toàn bộ ngữ cảnh thực thi hiện tại từ phần cứng của CPU vào PCB của Tiến trình A. Ngữ cảnh này bao gồm Bộ đếm Chương trình, tất cả các thanh ghi CPU, và các thông tin trạng thái khác. Quá trình này giống như việc bạn cẩn thận lưu lại trò chơi trước khi thoát. Cập nhật Trạng thái: Hệ điều hành cập nhật trường “Trạng thái Tiến trình” trong PCB của Tiến trình A từ “Đang chạy” thành “Sẵn sàng” hoặc “Đang chờ”. Nó di chuyển PCB này vào hàng đợi thích hợp (ví dụ: hàng đợi sẵn sàng). Chọn Tiến trình Tiếp theo: Bộ lập lịch của hệ điều hành chạy thuật toán của mình, tham khảo các PCB trong hàng đợi sẵn sàng để chọn tiến trình tiếp theo sẽ chạy. Giả sử nó chọn Tiến trình B. Nạp Ngữ cảnh của Tiến trình B: Hệ điều hành lấy ngữ cảnh đã được lưu từ PCB của Tiến trình B và nạp nó vào phần cứng của CPU. Bộ đếm Chương trình được khôi phục, các thanh ghi được điền đầy bằng các giá trị đã lưu của Tiến trình B, và các con trỏ bộ nhớ được cập nhật. Tiếp tục Thực thi: Hệ điều hành chuyển quyền điều khiển từ nhân trở lại chương trình người dùng. Tiến trình B bắt đầu thực thi chỉ thị tiếp theo của nó, hoàn toàn không biết rằng nó đã từng bị tạm dừng. Nó tiếp tục chính xác từ nơi nó đã dừng lại. Phép ví von: Hai đầu bếp chia sẻ một khu vực làm việc Hãy tưởng tượng hai đầu bếp (Tiến trình A và B) phải chia sẻ chung một chiếc thớt và một con dao (CPU).\nĐầu bếp A đang thái rau. Người quản lý (Hệ điều hành) nói rằng thời gian của anh ta đã hết. Đầu bếp A ghi vào sổ tay của mình (PCB A): “Tôi đang thái cà rốt, con dao ở đây, còn lại 3 củ” (lưu PC, các thanh ghi, trạng thái). Sau đó, anh ta dọn dẹp khu vực làm việc và rời đi. Người quản lý gọi đầu bếp B. Đầu bếp B nhìn vào sổ tay của mình (PCB B), trong đó ghi: “Tôi đang thái hành tây, cần con dao nhỏ, đã thái được nửa củ thứ hai.” Đầu bếp B sắp xếp khu vực làm việc chính xác như trong ghi chú của mình (nạp ngữ cảnh) và ngay lập tức tiếp tục thái củ hành tây thứ hai. Quá trình chuyển đổi diễn ra liền mạch. Mặc dù quá trình chuyển đổi ngữ cảnh có vẻ kỳ diệu, nó không hề miễn phí. Nó là một chi phí hoạt động thuần túy (overhead); trong khoảng thời gian hệ điều hành đang lưu và nạp các PCB, không có công việc hữu ích nào của người dùng được thực hiện. Điều này tạo ra một sự đánh đổi cơ bản trong thiết kế hệ điều hành. Kích thước và độ phức tạp của PCB đóng góp trực tiếp vào chi phí này. Các nhà thiết kế hệ điều hành luôn phải đối mặt với một xung đột cốt lõi:\nChuyển đổi thường xuyên và nhanh chóng (lát cắt thời gian ngắn) làm cho hệ thống có cảm giác rất nhạy và tương tác tốt, nhưng một tỷ lệ lớn thời gian CPU bị lãng phí cho chi phí chuyển đổi. Chuyển đổi không thường xuyên và chậm hơn (lát cắt thời gian dài) hiệu quả hơn (ít thời gian lãng phí cho chi phí), nhưng hệ thống có thể cảm thấy ì ạch, vì một tiến trình duy nhất có thể độc chiếm CPU trong thời gian dài hơn. Do đó, thiết kế của PCB và thuật toán lập lịch có mối liên hệ mật thiết trong một bài toán cân bằng giữa việc cung cấp các tính năng nâng cao, đảm bảo khả năng phản hồi của hệ thống và tối đa hóa hiệu quả sử dụng CPU.\n4. Tại sao PCB là người hùng thầm lặng của Hệ điều hành Cấu trúc dữ liệu có vẻ đơn giản này lại là nền tảng cho máy tính hiện đại vì nhiều lý do.\nYếu tố cho phép Đa nhiệm: Như đã trình bày, nếu không có khả năng lưu và khôi phục trạng thái của PCB, việc chuyển đổi ngữ cảnh sẽ là không thể. Chúng ta sẽ bị mắc kẹt trong một thế giới đơn nhiệm. Nền tảng cho Lập lịch: Bộ lập lịch là “bộ não” quyết định tiến trình nào sẽ được sử dụng CPU, nhưng PCB là “hệ thần kinh” cung cấp tất cả các thông tin đầu vào (độ ưu tiên, trạng thái, việc sử dụng tài nguyên) để bộ não đó đưa ra quyết định thông minh. Người bảo vệ sự Ổn định của Hệ thống: Bằng cách lưu trữ ranh giới bộ nhớ và quyền sở hữu tài nguyên, PCB giúp hệ điều hành thực thi sự cô lập giữa các tiến trình, ngăn chặn một chương trình hoạt động sai cách làm hỏng các chương trình khác hoặc chính nhân hệ điều hành. Công cụ Quản lý Tài nguyên: Hệ điều hành sử dụng thông tin I/O và bộ nhớ trong các PCB để quản lý việc cấp phát tài nguyên, ngăn ngừa xung đột (ví dụ: hai tiến trình cố gắng ghi vào cùng một tệp tin đồng thời), và thậm chí giúp phát hiện tình trạng bế tắc (deadlock). Vượt ra ngoài Tiến trình đơn: Các khái niệm Nâng cao Một tiến trình có thể có nhiều luồng (thread), giống như các “tiến trình mini”. Trong trường hợp này, PCB chứa thông tin được chia sẻ chung (như không gian bộ nhớ), trong khi mỗi luồng sẽ có một Khối điều khiển Luồng (Thread Control Block - TCB) nhẹ hơn để lưu trữ ngữ cảnh thực thi riêng của nó (các thanh ghi, con trỏ ngăn xếp). Điều này cho phép đa nhiệm ở mức độ chi tiết hơn nữa ngay trong một ứng dụng duy nhất.\nCác trường thông tin và độ phức tạp cụ thể của cấu trúc PCB trong một hệ điều hành nhất định là sự phản ánh trực tiếp các mục tiêu và triết lý thiết kế của hệ điều hành đó. Một hệ điều hành thời gian thực (RTOS) cho hệ thống phanh của ô tô ưu tiên sự đoán trước và các thời hạn nghiêm ngặt. Do đó, PCB của nó có thể sẽ có các trường rất chi tiết và chặt chẽ liên quan đến các ràng buộc thời gian. Ngược lại, PCB của một máy chủ Linux (task_struct) nổi tiếng là phức tạp, chứa thông tin sâu rộng về quyền của người dùng/nhóm, giới hạn tài nguyên, và các tín hiệu giao tiếp liên tiến trình, phản ánh di sản đa người dùng và chú trọng bảo mật của nó. Điều này có nghĩa là PCB không chỉ là một triển khai kỹ thuật chung chung; nó là một tạo tác thể hiện triết lý kiến trúc và mục đích dự định của toàn bộ hệ điều hành.\nNếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!\n","wordCount":"3264","inLanguage":"en","image":"https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-09-05T00:00:00Z","dateModified":"2025-09-05T00:00:00Z","author":{"@type":"Person","name":"Nagih"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nagih.io.vn/posts/process-control-block/"},"publisher":{"@type":"Organization","name":"Nagih | Blog","logo":{"@type":"ImageObject","url":"https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nagih.io.vn/ accesskey=h title="Home (Alt + H)"><img src=https://blog.nagih.io.vn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.nagih.io.vn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nagih.io.vn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nagih.io.vn/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.nagih.io.vn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://nagih.io.vn title=Home><span>Home</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nagih.io.vn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.nagih.io.vn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Process Control Block</h1><div class=post-meta><span title='2025-09-05 00:00:00 +0000 UTC'>September 5, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;3264 words&nbsp;·&nbsp;Nagih&nbsp;|&nbsp;<a href=https://github.com/vuongmanhnghia/posts/content/posts/system/Process%20Control%20Block.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#giới-thiệu>Giới thiệu</a></li><li><a href=#1-khối-quản-lý-tiến-trình-pcb-chính-xác-là-gì-dấu-vân-tay-kỹ-thuật-số>1. Khối Quản lý Tiến trình (PCB) chính xác là gì? Dấu vân tay Kỹ thuật số</a><ul><li><a href=#vòng-đời-của-một-pcb>Vòng đời của một PCB</a></li><li><a href=#lưu-trữ-an-toàn>Lưu trữ An toàn</a></li><li><a href=#bảng-tiến-trình-process-table>Bảng Tiến trình (Process Table)</a></li></ul></li><li><a href=#2-giải-phẫu-pcb---nhìn-vào-bên-trong-tấm-thẻ-căn-cước>2. Giải phẫu PCB - Nhìn vào bên trong &ldquo;Tấm thẻ Căn cước&rdquo;</a><ul><li><a href=#phân-tích-chi-tiết-các-thành-phần>Phân tích chi tiết các thành phần</a></li><li><a href=#bảng-giải-phẫu-tấm-thẻ-căn-cước-của-một-tiến-trình>Bảng: Giải phẫu &ldquo;Tấm thẻ Căn cước&rdquo; của một Tiến trình</a></li></ul></li><li><a href=#3-pcb-trong-thực-tiễn---phép-màu-của-đa-nhiệm-chuyển-đổi-ngữ-cảnh>3. PCB trong Thực tiễn - Phép màu của Đa nhiệm (Chuyển đổi Ngữ cảnh)</a><ul><li><a href=#tác-nhân-kích-hoạt>Tác nhân Kích hoạt</a></li><li><a href=#quy-trình-từng-bước-của-một-cuộc-chuyển-đổi-ngữ-cảnh>Quy trình từng bước của một cuộc Chuyển đổi Ngữ cảnh</a></li><li><a href=#phép-ví-von-hai-đầu-bếp-chia-sẻ-một-khu-vực-làm-việc>Phép ví von: Hai đầu bếp chia sẻ một khu vực làm việc</a></li></ul></li><li><a href=#4-tại-sao-pcb-là-người-hùng-thầm-lặng-của-hệ-điều-hành>4. Tại sao PCB là người hùng thầm lặng của Hệ điều hành</a><ul><li><a href=#vượt-ra-ngoài-tiến-trình-đơn-các-khái-niệm-nâng-cao>Vượt ra ngoài Tiến trình đơn: Các khái niệm Nâng cao</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Khối Quản lý Tiến trình (PCB) - &ldquo;CMND&rdquo; của Mọi Chương trình trong Máy tính</p><h2 id=giới-thiệu>Giới thiệu<a hidden class=anchor aria-hidden=true href=#giới-thiệu>#</a></h2><p>Hệ điều hành (Operating System - OS). Để quản lý từng mỗi chương trình đang chạy, hay còn gọi là <strong>process</strong>, <strong>process</strong> cần một bản thông tin chi tiết về từng thành viên. Bản thông tin này chính là Khối Quản lý Tiến trình (Process Control Block - PCB).</p><p>Để dễ hình dung nhất, hãy coi PCB chính là &ldquo;Chứng minh nhân dân&rdquo; (CMND) hay &ldquo;Căn cước công dân&rdquo; (CCCD) của một tiến trình. Đó là một tấm thẻ định danh chứa đựng mọi thông tin sống còn mà hệ điều hành cần để quản lý, giám sát và điều khiển tiến trình đó. Nếu không có &ldquo;tấm thẻ&rdquo; này, một tiến trình sẽ trở nên vô danh và không thể quản lý được đối với hệ điều hành.</p><h2 id=1-khối-quản-lý-tiến-trình-pcb-chính-xác-là-gì-dấu-vân-tay-kỹ-thuật-số>1. Khối Quản lý Tiến trình (PCB) chính xác là gì? Dấu vân tay Kỹ thuật số<a hidden class=anchor aria-hidden=true href=#1-khối-quản-lý-tiến-trình-pcb-chính-xác-là-gì-dấu-vân-tay-kỹ-thuật-số>#</a></h2><p>Về mặt hình thức, PCB là một cấu trúc dữ liệu cơ bản nằm trong nhân (kernel) của hệ điều hành. Nó còn được biết đến với các tên gọi khác như &ldquo;Bộ mô tả Tiến trình&rdquo; (Process Descriptor) hay &ldquo;Khối điều khiển Tác vụ&rdquo; (Task Control Block).5 Điều quan trọng cần nhấn mạnh là PCB không phải là một phần của chương trình người dùng viết ra; nó là một công cụ nội bộ, được tạo ra và sử dụng độc quyền bởi hệ điều hành để quản lý các tiến trình.</p><h3 id=vòng-đời-của-một-pcb>Vòng đời của một PCB<a hidden class=anchor aria-hidden=true href=#vòng-đời-của-một-pcb>#</a></h3><p>Vòng đời của một PCB gắn liền với vòng đời của tiến trình mà nó đại diện:</p><ul><li><strong>Khởi tạo:</strong> Ngay khi người dùng khởi chạy một ứng dụng (ví dụ, nhấp đúp vào biểu tượng Google Chrome), hệ điều hành sẽ tạo ra một tiến trình mới. Song song với đó, nó cấp phát bộ nhớ và khởi tạo một PCB tương ứng cho tiến trình này.</li><li><strong>Quản lý:</strong> Trong suốt thời gian tồn tại của tiến trình, hệ điều hành liên tục đọc và cập nhật thông tin trong PCB của nó khi trạng thái và việc sử dụng tài nguyên thay đổi.</li><li><strong>Kết thúc:</strong> Khi tiến trình hoàn thành nhiệm vụ hoặc bị chấm dứt, hệ điều hành sẽ thu hồi tất cả tài nguyên của nó và phá hủy PCB, giải phóng bộ nhớ đã cấp phát.</li></ul><h3 id=lưu-trữ-an-toàn>Lưu trữ An toàn<a hidden class=anchor aria-hidden=true href=#lưu-trữ-an-toàn>#</a></h3><p>PCB chứa những thông tin cực kỳ quan trọng đối với sự ổn định của hệ thống. Do đó, nó được lưu trữ trong một vùng bộ nhớ được bảo vệ đặc biệt gọi là &ldquo;không gian nhân&rdquo; (kernel space). Cơ chế bảo vệ này ngăn chặn các chương trình người dùng truy cập và sửa đổi (dù vô tình hay cố ý) dữ liệu điều khiển của chính chúng hoặc của các tiến trình khác, một hành động có thể gây sập toàn bộ hệ thống.</p><h3 id=bảng-tiến-trình-process-table>Bảng Tiến trình (Process Table)<a hidden class=anchor aria-hidden=true href=#bảng-tiến-trình-process-table>#</a></h3><p>Để theo dõi tất cả các tiến trình đang hoạt động, hệ điều hành duy trì một danh sách tổng thể, thường được gọi là Bảng Tiến trình (Process Table). Về cơ bản, đây là một mảng hoặc danh sách liên kết chứa các con trỏ trỏ đến từng PCB của mọi tiến trình đang hoạt động trong hệ thống. Bảng này giống như một cuốn danh bạ mà hệ điều hành dùng để tra cứu mọi tiến trình mà nó đang quản lý.</p><p>Từ góc độ của nhân hệ điều hành, PCB không chỉ đơn thuần là một bản ghi thông tin; nó chính <em>là</em> hiện thân của tiến trình. Một chương trình trên đĩa cứng (ví dụ: <code>chrome.exe</code>) chỉ là một tập hợp các chỉ thị thụ động. Một tiến trình là sự thực thi</p><p><em>chủ động</em> của những chỉ thị đó. Và PCB chính là cấu trúc dữ liệu cụ thể hóa &ldquo;sự chủ động&rdquo; này. Nó là thực thể hữu hình, có thể quản lý được mà hệ điều hành tương tác. Tất cả các hành động quản lý của OS—lập lịch, cấp phát tài nguyên, chấm dứt—đều là các hoạt động được thực hiện trên hoặc dựa vào dữ liệu chứa trong PCB. Do đó, có thể nói rằng PCB là linh hồn kỹ thuật số, là bản chất của một tiến trình trong mắt hệ điều hành.</p><h2 id=2-giải-phẫu-pcb---nhìn-vào-bên-trong-tấm-thẻ-căn-cước>2. Giải phẫu PCB - Nhìn vào bên trong &ldquo;Tấm thẻ Căn cước&rdquo;<a hidden class=anchor aria-hidden=true href=#2-giải-phẫu-pcb---nhìn-vào-bên-trong-tấm-thẻ-căn-cước>#</a></h2><p>Mặc dù cấu trúc chính xác có thể khác nhau giữa các hệ điều hành (ví dụ, Linux và Windows), các loại thông tin cốt lõi về cơ bản là giống nhau. Chúng ta sẽ tiếp tục sử dụng phép ẩn dụ &ldquo;Tấm thẻ Căn cước&rdquo; để làm rõ mục đích của từng thành phần.</p><h3 id=phân-tích-chi-tiết-các-thành-phần>Phân tích chi tiết các thành phần<a hidden class=anchor aria-hidden=true href=#phân-tích-chi-tiết-các-thành-phần>#</a></h3><ul><li><strong>Thông tin Nhận dạng (Process Identification Data):</strong><ul><li><strong>Mã định danh Tiến trình (Process ID - PID):</strong> Một số nguyên duy nhất do hệ điều hành cấp để xác định tiến trình. Đây là trường thông tin quan trọng nhất, được sử dụng làm khóa trong hầu hết các bảng hệ thống khác.<ul><li><em>Ví von:</em> Số CMND/CCCD duy nhất trên thẻ căn cước.</li></ul></li><li><strong>Mã định danh Tiến trình Cha (Parent Process ID - PPID):</strong> PID của tiến trình đã tạo ra tiến trình này. Điều này thiết lập một cấu trúc phân cấp dạng cây cho các tiến trình.</li><li><strong>Mã định danh Người dùng (User ID - UID) & Nhóm (Group ID - GID):</strong> Xác định người dùng và nhóm sở hữu tiến trình, được sử dụng cho mục đích bảo mật và phân quyền.</li></ul></li><li><strong>Trạng thái Tiến trình (Process State):</strong><ul><li>Một trường ghi lại trạng thái hiện tại của tiến trình. Thông tin này rất quan trọng để bộ lập lịch biết được tiến trình nào đủ điều kiện để chạy.<ul><li><em>Mới (New):</em> Tiến trình đang được tạo.</li><li><em>Sẵn sàng (Ready):</em> Tiến trình đã được nạp vào bộ nhớ và đang chờ đến lượt được cấp CPU.</li><li><em>Đang chạy (Running):</em> Các chỉ thị của tiến trình đang được thực thi bởi một lõi CPU.</li><li><em>Đang chờ/Bị chặn (Waiting/Blocked):</em> Tiến trình không thể tiếp tục cho đến khi một sự kiện nào đó xảy ra (ví dụ: chờ người dùng nhập liệu hoặc chờ đọc dữ liệu từ đĩa).</li><li><em>Kết thúc (Terminated):</em> Tiến trình đã hoàn thành và đang trong quá trình dọn dẹp.</li></ul></li></ul></li><li><strong>Ngữ cảnh Thực thi (Execution Context):</strong><ul><li><strong>Bộ đếm Chương trình (Program Counter - PC):</strong> Lưu địa chỉ bộ nhớ của chỉ thị <em>tiếp theo</em> sẽ được thực thi. Đây là yếu tố sống còn để có thể tiếp tục một tiến trình sau khi nó bị gián đoạn.<ul><li><em>Ví von:</em> Một chiếc kẹp đánh dấu trang sách. Nó cho bạn biết chính xác cần bắt đầu đọc lại từ đâu.</li></ul></li><li><strong>Các thanh ghi CPU (CPU Registers):</strong> Một bản sao lưu (snapshot) nội dung của các thanh ghi đa dụng, con trỏ ngăn xếp (stack pointer), v.v., của CPU tại thời điểm tiến trình bị ngắt. Các thanh ghi này chứa dữ liệu trung gian của các phép tính hiện tại.<ul><li><em>Ví von:</em> Những dòng ghi chú trên giấy nháp khi đang giải một bài toán phức tạp. Bạn cần lưu chúng lại để có thể tiếp tục bài toán sau đó.</li></ul></li></ul></li><li><strong>Thông tin Quản lý Tài nguyên (Resource Management Information):</strong><ul><li><strong>Thông tin Lập lịch CPU (CPU Scheduling Information):</strong> Dữ liệu được bộ lập lịch của hệ điều hành sử dụng để quyết định tiến trình nào sẽ chạy tiếp theo. Bao gồm độ ưu tiên của tiến trình, con trỏ đến các hàng đợi lập lịch mà nó đang tham gia, và các tham số khác.<ul><li><em>Ví von:</em> Nhóm lên máy bay hoặc hạng vé của hành khách (ví dụ: VIP, Thương gia, Phổ thông) quyết định thứ tự lên máy bay.</li></ul></li><li><strong>Thông tin Quản lý Bộ nhớ (Memory Management Information):</strong> Thông tin về bộ nhớ được cấp phát cho tiến trình này, chẳng hạn như con trỏ đến bảng trang (page tables) hoặc bảng phân đoạn (segment tables) của nó. Điều này xác định không gian địa chỉ của tiến trình và ngăn nó truy cập vào bộ nhớ của các tiến trình khác.<ul><li><em>Ví von:</em> Sổ đỏ hoặc giấy tờ nhà đất, xác định ranh giới của một mảnh đất.</li></ul></li><li><strong>Thông tin Trạng thái I/O (I/O Status Information):</strong> Danh sách các thiết bị I/O được cấp phát cho tiến trình (ví dụ: một máy in cụ thể) và danh sách các tệp tin mà nó đang mở.<ul><li><em>Ví von:</em> Một thẻ thư viện ghi lại những cuốn sách đang được mượn, hoặc danh sách các công cụ đã mượn từ một xưởng làm việc.</li></ul></li><li><strong>Thông tin Kế toán (Accounting Information):</strong> Theo dõi việc sử dụng tài nguyên, chẳng hạn như lượng thời gian CPU mà tiến trình đã tiêu thụ, giới hạn thời gian, v.v. Thông tin này có thể được sử dụng để giám sát hệ thống hoặc tính phí trong môi trường doanh nghiệp.<ul><li><em>Ví von:</em> Chi tiết sử dụng trên hóa đơn tiện ích (ví dụ: số kilowatt-giờ điện đã dùng).</li></ul></li></ul></li></ul><h3 id=bảng-giải-phẫu-tấm-thẻ-căn-cước-của-một-tiến-trình>Bảng: Giải phẫu &ldquo;Tấm thẻ Căn cước&rdquo; của một Tiến trình<a hidden class=anchor aria-hidden=true href=#bảng-giải-phẫu-tấm-thẻ-căn-cước-của-một-tiến-trình>#</a></h3><p>Bảng dưới đây tóm tắt các thành phần chính của PCB và phép ví von tương ứng, giúp củng cố khái niệm một cách trực quan.</p><table><thead><tr><th>Component (Thành phần)</th><th>Purpose (Mục đích)</th><th>Analogy (Phép ví von)</th></tr></thead><tbody><tr><td>Process ID (PID)</td><td>Một số duy nhất để nhận dạng tiến trình.</td><td>Số CMND/CCCD</td></tr><tr><td>Process State</td><td>Hoạt động hiện tại của tiến trình (Đang chạy, Đang chờ, v.v.).</td><td>Tình trạng hôn nhân (Độc thân, Đã kết hôn,&mldr;)</td></tr><tr><td>Program Counter (PC)</td><td>Địa chỉ của lệnh tiếp theo sẽ thực thi.</td><td>Dấu trang sách (Bookmark)</td></tr><tr><td>CPU Registers</td><td>Lưu trữ dữ liệu tạm thời cho phép tính hiện tại.</td><td>Giấy nháp (Scratchpad)</td></tr><tr><td>Memory Info</td><td>Chi tiết về việc cấp phát bộ nhớ của tiến trình.</td><td>Sổ đỏ / Giấy tờ nhà đất</td></tr><tr><td>I/O Status Info</td><td>Danh sách các tệp tin và thiết bị đang sử dụng.</td><td>Thẻ thư viện và các vật dụng đã mượn</td></tr><tr><td>Scheduling Info</td><td>Độ ưu tiên để truy cập CPU.</td><td>Mức độ ưu tiên / Vé VIP</td></tr><tr><td>Accounting Info</td><td>Ghi lại tài nguyên đã tiêu thụ (ví dụ: thời gian CPU).</td><td>Hóa đơn tiền điện/nước</td></tr></tbody></table><h2 id=3-pcb-trong-thực-tiễn---phép-màu-của-đa-nhiệm-chuyển-đổi-ngữ-cảnh>3. PCB trong Thực tiễn - Phép màu của Đa nhiệm (Chuyển đổi Ngữ cảnh)<a hidden class=anchor aria-hidden=true href=#3-pcb-trong-thực-tiễn---phép-màu-của-đa-nhiệm-chuyển-đổi-ngữ-cảnh>#</a></h2><p>Vai trò quan trọng nhất của PCB là cho phép đa nhiệm (multitasking) thông qua một cơ chế gọi là &ldquo;chuyển đổi ngữ cảnh&rdquo; (context switch).1 Chuyển đổi ngữ cảnh là quá trình hệ điều hành dừng một tiến trình và bắt đầu một tiến trình khác.2 Điều này xảy ra hàng trăm, thậm chí hàng nghìn lần mỗi giây, tạo ra ảo giác về sự thực thi song song.</p><h3 id=tác-nhân-kích-hoạt>Tác nhân Kích hoạt<a hidden class=anchor aria-hidden=true href=#tác-nhân-kích-hoạt>#</a></h3><p>Một cuộc chuyển đổi ngữ cảnh không xảy ra ngẫu nhiên. Nó được kích hoạt bởi các sự kiện cụ thể 20:</p><ul><li><strong>Đa nhiệm:</strong> &ldquo;Lát cắt thời gian&rdquo; (time slice hoặc quantum) của một tiến trình đã hết, và bộ lập lịch quyết định đã đến lượt một tiến trình khác (đa nhiệm phủ đầu - preemptive multitasking).</li><li><strong>Chờ I/O:</strong> Tiến trình đang chạy yêu cầu một tác vụ tốn thời gian (như đọc một tệp từ đĩa) và chuyển sang trạng thái &ldquo;Chờ&rdquo;, giải phóng CPU cho một tiến trình khác.</li><li><strong>Ngắt (Interrupts):</strong> Một ngắt phần cứng xảy ra (ví dụ: người dùng nhấp chuột), yêu cầu hệ điều hành phải xử lý, và việc này có thể liên quan đến việc chuyển sang một tiến trình khác.</li></ul><h3 id=quy-trình-từng-bước-của-một-cuộc-chuyển-đổi-ngữ-cảnh>Quy trình từng bước của một cuộc Chuyển đổi Ngữ cảnh<a hidden class=anchor aria-hidden=true href=#quy-trình-từng-bước-của-một-cuộc-chuyển-đổi-ngữ-cảnh>#</a></h3><p>Hãy tưởng tượng CPU đang chạy Tiến trình A (ví dụ: Microsoft Word) và cần chuyển sang Tiến trình B (ví dụ: Google Chrome).</p><ul><li><strong>Ngắt Xảy ra:</strong> Một sự kiện (như ngắt từ bộ đếm thời gian) báo hiệu cần phải chuyển đổi. Phần cứng CPU tự động chuyển quyền điều khiển cho nhân hệ điều hành.</li><li><strong>Lưu Ngữ cảnh của Tiến trình A:</strong> Hệ điều hành ngay lập tức tạm dừng Tiến trình A. Sau đó, nó sao chép một cách tỉ mỉ <em>toàn bộ</em> ngữ cảnh thực thi hiện tại từ phần cứng của CPU vào PCB của Tiến trình A. Ngữ cảnh này bao gồm Bộ đếm Chương trình, tất cả các thanh ghi CPU, và các thông tin trạng thái khác. Quá trình này giống như việc bạn cẩn thận lưu lại trò chơi trước khi thoát.</li><li><strong>Cập nhật Trạng thái:</strong> Hệ điều hành cập nhật trường &ldquo;Trạng thái Tiến trình&rdquo; trong PCB của Tiến trình A từ &ldquo;Đang chạy&rdquo; thành &ldquo;Sẵn sàng&rdquo; hoặc &ldquo;Đang chờ&rdquo;. Nó di chuyển PCB này vào hàng đợi thích hợp (ví dụ: hàng đợi sẵn sàng).</li><li><strong>Chọn Tiến trình Tiếp theo:</strong> Bộ lập lịch của hệ điều hành chạy thuật toán của mình, tham khảo các PCB trong hàng đợi sẵn sàng để chọn tiến trình tiếp theo sẽ chạy. Giả sử nó chọn Tiến trình B.</li><li><strong>Nạp Ngữ cảnh của Tiến trình B:</strong> Hệ điều hành lấy ngữ cảnh đã được lưu từ PCB của Tiến trình B và nạp nó <em>vào</em> phần cứng của CPU. Bộ đếm Chương trình được khôi phục, các thanh ghi được điền đầy bằng các giá trị đã lưu của Tiến trình B, và các con trỏ bộ nhớ được cập nhật.</li><li><strong>Tiếp tục Thực thi:</strong> Hệ điều hành chuyển quyền điều khiển từ nhân trở lại chương trình người dùng. Tiến trình B bắt đầu thực thi chỉ thị tiếp theo của nó, hoàn toàn không biết rằng nó đã từng bị tạm dừng. Nó tiếp tục chính xác từ nơi nó đã dừng lại.</li></ul><h3 id=phép-ví-von-hai-đầu-bếp-chia-sẻ-một-khu-vực-làm-việc>Phép ví von: Hai đầu bếp chia sẻ một khu vực làm việc<a hidden class=anchor aria-hidden=true href=#phép-ví-von-hai-đầu-bếp-chia-sẻ-một-khu-vực-làm-việc>#</a></h3><p>Hãy tưởng tượng hai đầu bếp (Tiến trình A và B) phải chia sẻ chung một chiếc thớt và một con dao (CPU).</p><ul><li>Đầu bếp A đang thái rau. Người quản lý (Hệ điều hành) nói rằng thời gian của anh ta đã hết.</li><li>Đầu bếp A ghi vào sổ tay của mình (PCB A): &ldquo;Tôi đang thái cà rốt, con dao ở đây, còn lại 3 củ&rdquo; (lưu PC, các thanh ghi, trạng thái). Sau đó, anh ta dọn dẹp khu vực làm việc và rời đi.</li><li>Người quản lý gọi đầu bếp B. Đầu bếp B nhìn vào sổ tay của mình (PCB B), trong đó ghi: &ldquo;Tôi đang thái hành tây, cần con dao nhỏ, đã thái được nửa củ thứ hai.&rdquo;</li><li>Đầu bếp B sắp xếp khu vực làm việc chính xác như trong ghi chú của mình (nạp ngữ cảnh) và ngay lập tức tiếp tục thái củ hành tây thứ hai. Quá trình chuyển đổi diễn ra liền mạch.</li></ul><p>Mặc dù quá trình chuyển đổi ngữ cảnh có vẻ kỳ diệu, nó không hề miễn phí. Nó là một chi phí hoạt động thuần túy (overhead); trong khoảng thời gian hệ điều hành đang lưu và nạp các PCB, không có công việc hữu ích nào của người dùng được thực hiện. Điều này tạo ra một sự đánh đổi cơ bản trong thiết kế hệ điều hành. Kích thước và độ phức tạp của PCB đóng góp trực tiếp vào chi phí này. Các nhà thiết kế hệ điều hành luôn phải đối mặt với một xung đột cốt lõi:</p><ul><li><strong>Chuyển đổi thường xuyên và nhanh chóng</strong> (lát cắt thời gian ngắn) làm cho hệ thống có cảm giác rất nhạy và tương tác tốt, nhưng một tỷ lệ lớn thời gian CPU bị lãng phí cho chi phí chuyển đổi.</li><li><strong>Chuyển đổi không thường xuyên và chậm hơn</strong> (lát cắt thời gian dài) hiệu quả hơn (ít thời gian lãng phí cho chi phí), nhưng hệ thống có thể cảm thấy ì ạch, vì một tiến trình duy nhất có thể độc chiếm CPU trong thời gian dài hơn.</li></ul><p>Do đó, thiết kế của PCB và thuật toán lập lịch có mối liên hệ mật thiết trong một bài toán cân bằng giữa việc cung cấp các tính năng nâng cao, đảm bảo khả năng phản hồi của hệ thống và tối đa hóa hiệu quả sử dụng CPU.</p><h2 id=4-tại-sao-pcb-là-người-hùng-thầm-lặng-của-hệ-điều-hành>4. Tại sao PCB là người hùng thầm lặng của Hệ điều hành<a hidden class=anchor aria-hidden=true href=#4-tại-sao-pcb-là-người-hùng-thầm-lặng-của-hệ-điều-hành>#</a></h2><p>Cấu trúc dữ liệu có vẻ đơn giản này lại là nền tảng cho máy tính hiện đại vì nhiều lý do.</p><ul><li><strong>Yếu tố cho phép Đa nhiệm:</strong> Như đã trình bày, nếu không có khả năng lưu và khôi phục trạng thái của PCB, việc chuyển đổi ngữ cảnh sẽ là không thể. Chúng ta sẽ bị mắc kẹt trong một thế giới đơn nhiệm.</li><li><strong>Nền tảng cho Lập lịch:</strong> Bộ lập lịch là &ldquo;bộ não&rdquo; quyết định tiến trình nào sẽ được sử dụng CPU, nhưng PCB là &ldquo;hệ thần kinh&rdquo; cung cấp tất cả các thông tin đầu vào (độ ưu tiên, trạng thái, việc sử dụng tài nguyên) để bộ não đó đưa ra quyết định thông minh.</li><li><strong>Người bảo vệ sự Ổn định của Hệ thống:</strong> Bằng cách lưu trữ ranh giới bộ nhớ và quyền sở hữu tài nguyên, PCB giúp hệ điều hành thực thi sự cô lập giữa các tiến trình, ngăn chặn một chương trình hoạt động sai cách làm hỏng các chương trình khác hoặc chính nhân hệ điều hành.</li><li><strong>Công cụ Quản lý Tài nguyên:</strong> Hệ điều hành sử dụng thông tin I/O và bộ nhớ trong các PCB để quản lý việc cấp phát tài nguyên, ngăn ngừa xung đột (ví dụ: hai tiến trình cố gắng ghi vào cùng một tệp tin đồng thời), và thậm chí giúp phát hiện tình trạng bế tắc (deadlock).</li></ul><h3 id=vượt-ra-ngoài-tiến-trình-đơn-các-khái-niệm-nâng-cao>Vượt ra ngoài Tiến trình đơn: Các khái niệm Nâng cao<a hidden class=anchor aria-hidden=true href=#vượt-ra-ngoài-tiến-trình-đơn-các-khái-niệm-nâng-cao>#</a></h3><p>Một tiến trình có thể có nhiều luồng (thread), giống như các &ldquo;tiến trình mini&rdquo;. Trong trường hợp này, PCB chứa thông tin được chia sẻ chung (như không gian bộ nhớ), trong khi mỗi luồng sẽ có một Khối điều khiển Luồng (Thread Control Block - TCB) nhẹ hơn để lưu trữ ngữ cảnh thực thi riêng của nó (các thanh ghi, con trỏ ngăn xếp). Điều này cho phép đa nhiệm ở mức độ chi tiết hơn nữa ngay trong một ứng dụng duy nhất.</p><p>Các trường thông tin và độ phức tạp cụ thể của cấu trúc PCB trong một hệ điều hành nhất định là sự phản ánh trực tiếp các mục tiêu và triết lý thiết kế của hệ điều hành đó. Một hệ điều hành thời gian thực (RTOS) cho hệ thống phanh của ô tô ưu tiên sự đoán trước và các thời hạn nghiêm ngặt. Do đó, PCB của nó có thể sẽ có các trường rất chi tiết và chặt chẽ liên quan đến các ràng buộc thời gian. Ngược lại, PCB của một máy chủ Linux (<code>task_struct</code>) nổi tiếng là phức tạp, chứa thông tin sâu rộng về quyền của người dùng/nhóm, giới hạn tài nguyên, và các tín hiệu giao tiếp liên tiến trình, phản ánh di sản đa người dùng và chú trọng bảo mật của nó. Điều này có nghĩa là PCB không chỉ là một triển khai kỹ thuật chung chung; nó là một tạo tác thể hiện triết lý kiến trúc và mục đích dự định của toàn bộ hệ điều hành.</p><hr><p><em>Nếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nagih.io.vn/tags/pcb/>Pcb</a></li></ul><nav class=paginav><a class=prev href=https://blog.nagih.io.vn/posts/h%C6%B0%E1%BB%9Bng-d%E1%BA%ABn-t%C3%B9y-bi%E1%BA%BFn-ph%C3%A2n-v%C3%B9ng-efi-khi-c%C3%A0i-windows/><span class=title>« Prev</span><br><span>Hướng dẫn tùy biến phân vùng EFI khi cài windows</span>
</a><a class=next href=https://blog.nagih.io.vn/posts/internal-separation/><span class=title>Next »</span><br><span>Internal Separation</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on x" href="https://x.com/intent/tweet/?text=Process%20Control%20Block&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f&amp;hashtags=pcb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f&amp;title=Process%20Control%20Block&amp;summary=Process%20Control%20Block&amp;source=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f&title=Process%20Control%20Block"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on whatsapp" href="https://api.whatsapp.com/send?text=Process%20Control%20Block%20-%20https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on telegram" href="https://telegram.me/share/url?text=Process%20Control%20Block&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Process Control Block on ycombinator" href="https://news.ycombinator.com/submitlink?t=Process%20Control%20Block&u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fprocess-control-block%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nagih.io.vn/>Nagih | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>