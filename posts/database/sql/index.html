<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SQL Overview | Nagih | Blog</title>
<meta name=keywords content="sql"><meta name=description content="Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng"><meta name=author content="Nagih"><link rel=canonical href=https://blog.nagih.io.vn/posts/database/sql/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.nagih.io.vn/posts/database/sql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.nagih.io.vn/posts/database/sql/"><meta property="og:site_name" content="Nagih | Blog"><meta property="og:title" content="SQL Overview"><meta property="og:description" content="Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-12T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-12T00:00:00+00:00"><meta property="article:tag" content="Sql"><meta property="og:image" content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SQL Overview"><meta name=twitter:description content="Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nagih.io.vn/posts/"},{"@type":"ListItem","position":2,"name":"SQL Overview","item":"https://blog.nagih.io.vn/posts/database/sql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQL Overview","name":"SQL Overview","description":"Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng\n","keywords":["sql"],"articleBody":"Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng\nPhần 1: Giới Thiệu - SQL Là Gì và Tại Sao Bạn Cần Phải Học Nó? SQL là gì? SQL, viết tắt của Structured Query Language (Ngôn ngữ Truy vấn có Cấu trúc), là ngôn ngữ tiêu chuẩn được sử dụng để giao tiếp, quản lý và thao tác với các cơ sở dữ liệu quan hệ. Cần phải nhấn mạnh rằng SQL không phải là một ngôn ngữ lập trình đa năng như Python hay Java, mà là một ngôn ngữ chuyên dụng, được thiết kế riêng cho mục đích làm việc với dữ liệu. Một trong những ưu điểm lớn nhất của SQL là nó không đòi hỏi kỹ năng mã hóa phức tạp, thay vào đó, nó sử dụng các từ khóa tiếng Anh gần gũi và dễ hiểu như\nSELECT, INSERT, UPDATE, giúp người dùng dễ dàng tiếp cận và sử dụng.\nLịch sử hình thành SQL ra đời vào những năm 1970, được phát triển bởi hai kỹ sư của IBM là Donald D. Chamberlin và Raymond F. Boyce. Ngôn ngữ này được xây dựng dựa trên nền tảng lý thuyết của mô hình cơ sở dữ liệu quan hệ do Tiến sĩ Edgar F. Codd, cũng là một nhà khoa học của IBM, đề xuất vào năm 1970. Ban đầu, nó có tên là SEQUEL (Structured English Query Language), nhưng sau đó được rút gọn thành SQL do một tranh chấp về thương hiệu. Kể từ đó, SQL đã trở thành một tiêu chuẩn công nghiệp được công nhận toàn cầu.\nVai trò và ứng dụng thực tế Ngày nay, SQL là một kỹ năng không thể thiếu đối với nhiều vị trí trong ngành công nghệ, từ nhà phân tích dữ liệu, nhà khoa học dữ liệu, lập trình viên backend cho đến quản trị viên cơ sở dữ liệu. Sự phổ biến của nó đến từ khả năng ứng dụng trong vô số lĩnh vực:\nPhân tích kinh doanh (Business Intelligence): Các chuyên gia sử dụng SQL để trích xuất, tổng hợp và phân tích dữ liệu từ các hệ thống lớn, nhằm tìm ra các xu hướng (insights) kinh doanh, tạo báo cáo và hỗ trợ việc ra quyết định. Phát triển ứng dụng: Hầu hết các ứng dụng web và di động đều cần một nơi để lưu trữ dữ liệu người dùng, thông tin sản phẩm, đơn hàng, v.v. SQL đóng vai trò là cầu nối ở tầng backend, giúp ứng dụng quản lý và thao tác với các dữ liệu này. Ngành Game: Các trò chơi điện tử sử dụng cơ sở dữ liệu để lưu trữ và quản lý một lượng lớn thông tin như hồ sơ người chơi, điểm số, vật phẩm và thành tích. Hệ thống giáo dục: Các trường học và tổ chức giáo dục dùng SQL để quản lý hồ sơ sinh viên, thông tin khóa học, điểm số và các hoạt động hành chính khác. Các Hệ Quản trị Cơ sở dữ liệu Quan hệ (RDBMS) phổ biến Một điểm quan trọng cần làm rõ là sự khác biệt giữa SQL và các Hệ Quản trị Cơ sở dữ liệu Quan hệ (Relational Database Management System - RDBMS). SQL là ngôn ngữ, trong khi RDBMS là phần mềm, là hệ thống thực thi các câu lệnh SQL đó. Có thể hình dung SQL như “tiếng Anh”, còn RDBMS như một “nhà xuất bản” sử dụng tiếng Anh để tạo ra sách. Việc nhầm lẫn giữa SQL và MySQL là rất phổ biến; MySQL chỉ là một trong nhiều RDBMS sử dụng ngôn ngữ SQL.\nMột số RDBMS phổ biến hiện nay bao gồm:\nMySQL: Một hệ quản trị CSDL quan hệ mã nguồn mở rất phổ biến, đặc biệt trong các ứng dụng web. PostgreSQL: Một hệ quản trị CSDL quan hệ mã nguồn mở mạnh mẽ, nổi tiếng với sự tuân thủ chuẩn SQL và các tính năng nâng cao. Microsoft SQL Server: Một sản phẩm thương mại của Microsoft, được sử dụng rộng rãi trong các môi trường doanh nghiệp, đặc biệt là các tổ chức sử dụng hệ sinh thái Windows. Oracle Database: Một hệ quản trị CSDL thương mại hàng đầu, thường được các tập đoàn lớn sử dụng cho các ứng dụng quan trọng và yêu cầu hiệu suất cao. Phần 2: Nền Tảng Của SQL - Hiểu Về Cơ Sở Dữ Liệu Quan Hệ Trước khi viết những câu lệnh SQL đầu tiên, việc nắm vững các khái niệm nền tảng của cơ sở dữ liệu quan hệ là điều kiện tiên quyết. Đây chính là cấu trúc mà SQL được thiết kế để tương tác.\nCác khái niệm cốt lõi Cơ sở dữ liệu (Database): Là một tập hợp các thông tin có liên quan đến nhau, được tổ chức và lưu trữ một cách có hệ thống trên máy tính để có thể dễ dàng truy cập và quản lý. Cơ sở dữ liệu quan hệ (Relational Database): Là một loại cơ sở dữ liệu mà trong đó dữ liệu được tổ chức thành các bảng (tables) có cấu trúc chặt chẽ. Mô hình này được E.F. Codd đề xuất vào năm 1970 và đã trở thành mô hình thống trị trong quản lý dữ liệu suốt nhiều thập kỷ. Bảng (Table): Là thành phần cấu trúc cơ bản nhất trong CSDL quan hệ, bao gồm các hàng và cột. Mỗi bảng đại diện cho một loại thực thể, ví dụ như bảng SinhVien, bảng SanPham. Hàng (Row) và Cột (Column): Cột (Column/Field/Attribute): Đại diện cho một thuộc tính hoặc một mẩu thông tin mô tả thực thể. Ví dụ, trong bảng SinhVien, các cột có thể là MaSinhVien, HoTen, NgaySinh. Hàng (Row/Record/Tuple): Đại diện cho một bản ghi dữ liệu cụ thể, một thực thể đơn lẻ trong bảng. Ví dụ, một hàng trong bảng SinhVien chứa thông tin đầy đủ của một sinh viên cụ thể. Chìa khóa của sự toàn vẹn Để đảm bảo dữ liệu luôn chính xác và nhất quán, CSDL quan hệ sử dụng các loại “khóa”.\nKhóa chính (Primary Key): Là một hoặc nhiều cột được sử dụng để xác định duy nhất mỗi hàng trong một bảng. Giá trị trong cột khóa chính không được phép trống (NULL) và phải là duy nhất trong toàn bộ bảng. Đây là “chứng minh nhân dân” của mỗi hàng. Khóa ngoại (Foreign Key): Là một cột (hoặc một nhóm cột) trong một bảng dùng để thiết lập một liên kết đến khóa chính của một bảng khác. Khóa ngoại là cơ chế để thực thi toàn vẹn tham chiếu (referential integrity), đảm bảo rằng mối quan hệ giữa các bảng luôn hợp lệ. Ví dụ, trong bảng DonHang, cột MaKhachHang sẽ là khóa ngoại tham chiếu đến cột MaKhachHang (khóa chính) trong bảng KhachHang. Các kiểu dữ liệu (Data Types) Mỗi cột trong một bảng phải được gán một kiểu dữ liệu cụ thể. Kiểu dữ liệu định nghĩa loại giá trị mà cột đó có thể chứa, ví dụ như số nguyên, văn bản, ngày tháng, v.v.. Việc chọn đúng kiểu dữ liệu không chỉ đảm bảo tính toàn vẹn mà còn giúp tối ưu hóa không gian lưu trữ và hiệu suất truy vấn.\nMặc dù SQL có một bộ chuẩn, các RDBMS khác nhau có thể có những tên gọi và đặc điểm riêng cho các kiểu dữ liệu. Việc hiểu rõ sự khác biệt này là rất quan trọng khi làm việc trên nhiều hệ thống.\nBảng so sánh các kiểu dữ liệu phổ biến\nLoại Dữ Liệu SQL Server MySQL Oracle Mô tả chung Chuỗi Ký Tự VARCHAR(n), NVARCHAR(n), VARCHAR(MAX) VARCHAR(n), TEXT VARCHAR2(n), CLOB Lưu trữ văn bản. Kiểu có tiền tố N (ví dụ: NVARCHAR) dùng để lưu trữ ký tự Unicode (đa ngôn ngữ) Số Nguyên TINYINT, SMALLINT, INT, BIGINT TINYINT, SMALLINT, INT, BIGINT NUMBER(p) Lưu trữ các số không có phần thập phân, với các phạm vi khác nhau Số Thực FLOAT, REAL, DECIMAL(p,s) FLOAT, DOUBLE, DECIMAL(p,s) NUMBER(p,s), FLOAT Lưu trữ các số có phần thập phân. DECIMAL dùng cho các giá trị cần độ chính xác cao như tiền tệ Ngày \u0026 Giờ DATE, TIME, DATETIME2, SMALLDATETIME DATE, TIME, DATETIME, TIMESTAMP DATE, TIMESTAMP Lưu trữ thông tin về ngày, giờ hoặc cả hai Logic/Bit BIT BOOLEAN (thực chất là TINYINT(1)) (Không có kiểu riêng, thường dùng NUMBER(1)) Lưu trữ giá trị logic True/False (thường là 1/0) Các ràng buộc (Constraints) Ràng buộc là các quy tắc được áp dụng trên các cột của bảng để đảm bảo tính chính xác và toàn vẹn của dữ liệu. Ngoài khóa chính và khóa ngoại, các ràng buộc phổ biến khác bao gồm:\nNOT NULL: Đảm bảo một cột không thể có giá trị NULL (trống). UNIQUE: Đảm bảo tất cả các giá trị trong một cột phải là duy nhất. CHECK: Đảm bảo rằng tất cả các giá trị trong một cột thỏa mãn một điều kiện cụ thể (ví dụ: Tuoi \u003e 18). DEFAULT: Cung cấp một giá trị mặc định cho một cột khi không có giá trị nào được chỉ định lúc chèn dữ liệu. Phần 3: Phân Loại Lệnh SQL - Sơ Đồ Tư Duy Để Làm Chủ SQL Để hệ thống hóa kiến thức và hiểu rõ mục đích của từng câu lệnh, SQL được chia thành các nhóm lệnh con. Cách phân loại phổ biến và hiện đại nhất chia SQL thành 5 họ lệnh chính. Việc hiểu rõ sự phân chia này giống như có một bản đồ tư duy, giúp người học biết chính xác nên dùng công cụ nào cho công việc nào.\nDDL (Data Definition Language - Ngôn ngữ Định nghĩa Dữ liệu): Các lệnh này được sử dụng để định nghĩa, tạo, thay đổi và xóa cấu trúc của các đối tượng trong cơ sở dữ liệu như bảng, chỉ mục, hay view. DML (Data Manipulation Language - Ngôn ngữ Thao tác Dữ liệu): Các lệnh này dùng để quản lý dữ liệu bên trong các bảng, bao gồm việc thêm, cập nhật và xóa dữ liệu. DQL (Data Query Language - Ngôn ngữ Truy vấn Dữ liệu): Họ lệnh này chỉ có một thành viên duy nhất và quan trọng nhất là SELECT. Nó được dùng để truy xuất và đọc dữ liệu từ cơ sở dữ liệu. DCL (Data Control Language - Ngôn ngữ Điều khiển Dữ liệu): Các lệnh này liên quan đến việc quản lý quyền truy cập và bảo mật, cho phép hoặc thu hồi quyền của người dùng trên các đối tượng cơ sở dữ liệu. TCL (Transaction Control Language - Ngôn ngữ Điều khiển Giao dịch): Các lệnh này quản lý các giao dịch (transactions) để đảm bảo tính toàn vẹn và nhất quán của dữ liệu khi thực hiện một chuỗi các thao tác. Một số tài liệu cũ hoặc một số hệ thống có thể gộp lệnh SELECT vào nhóm DML, vì nó cũng là một dạng “thao tác” với dữ liệu (thao tác đọc). Tuy nhiên, cách phân loại hiện đại tách\nSELECT thành một họ riêng là DQL mang lại sự rõ ràng và logic hơn. Việc tách biệt này nhấn mạnh sự khác biệt cơ bản giữa các hành động thay đổi trạng thái của dữ liệu (ghi - write) của DML và hành động chỉ đọc trạng thái (đọc - read) của DQL. Đối với người học, việc phân biệt rạch ròi giữa “đọc” và “ghi” là cực kỳ quan trọng để hiểu sâu hơn về các vấn đề như hiệu suất, khóa (locking) và bảo mật trong cơ sở dữ liệu.\nBảng tổng quan các lệnh SQL\nBảng dưới đây cung cấp một cái nhìn tổng thể về các họ lệnh và các lệnh chính thuộc mỗi họ, đóng vai trò như một bản đồ để định hướng trong suốt quá trình học.\nHọ Lệnh Tên Đầy Đủ Mục Đích Các Lệnh Chính DDL Data Definition Language Định nghĩa, thay đổi cấu trúc CSDL CREATE, ALTER, DROP, TRUNCATE DML Data Manipulation Language Thêm, sửa, xóa dữ liệu INSERT, UPDATE, DELETE DQL Data Query Language Truy vấn, đọc dữ liệu SELECT DCL Data Control Language Quản lý quyền truy cập GRANT, REVOKE TCL Transaction Control Language Quản lý các giao dịch COMMIT, ROLLBACK, SAVEPOINT Phần 4: DDL - Xây Dựng và Quản Lý “Ngôi Nhà” Dữ Liệu Các lệnh DDL là những công cụ đầu tiên bạn cần đến khi bắt đầu một dự án, dùng để xây dựng nên “khung xương” cho cơ sở dữ liệu của mình.\nCREATE DATABASE, CREATE TABLE: Được dùng để tạo mới một cơ sở dữ liệu hoặc một bảng. Khi tạo bảng, chúng ta cần định nghĩa các cột, kiểu dữ liệu cho từng cột và các ràng buộc cần thiết như khóa chính (PRIMARY KEY) hay NOT NULL. Ví dụ tạo bảng: SQL CREATE TABLE SinhVien ( MaSV INT PRIMARY KEY, HoTen NVARCHAR(100) NOT NULL, NgaySinh DATE ); ALTER TABLE: Lệnh này cho phép sửa đổi cấu trúc của một bảng đã tồn tại. Các thao tác phổ biến bao gồm thêm cột (ADD COLUMN), xóa cột (DROP COLUMN), hoặc thay đổi kiểu dữ liệu của một cột (MODIFY COLUMN hoặc ALTER COLUMN). Ví dụ thêm cột: ALTER TABLE SinhVien ADD Email VARCHAR(255); DROP DATABASE, DROP TABLE: Xóa vĩnh viễn một cơ sở dữ liệu hoặc một bảng, bao gồm cả cấu trúc, dữ liệu, chỉ mục và các ràng buộc liên quan. Đây là một hành động cực kỳ nguy hiểm và không thể hoàn tác nếu không có bản sao lưu (backup). TRUNCATE TABLE: Xóa toàn bộ dữ liệu bên trong một bảng một cách nhanh chóng nhưng vẫn giữ lại cấu trúc của bảng (tên cột, kiểu dữ liệu, chỉ mục, v.v.). Lệnh này hữu ích khi cần dọn sạch dữ liệu trong một bảng tạm để nạp dữ liệu mới. So sánh chuyên sâu: DELETE, TRUNCATE, và DROP Người mới bắt đầu thường nhầm lẫn giữa ba lệnh này vì chúng đều liên quan đến việc “xóa”. Tuy nhiên, chúng hoạt động theo những cách rất khác nhau và có những hệ quả riêng biệt.\nPhân loại lệnh: DELETE là một lệnh DML (Thao tác dữ liệu), trong khi TRUNCATE và DROP là các lệnh DDL (Định nghĩa dữ liệu). Sự khác biệt này không chỉ mang tính học thuật mà còn dẫn đến những khác biệt về cơ chế hoạt động.\nCơ chế hoạt động và Hiệu suất:\nDELETE: Xóa các hàng một cách có chọn lọc (nếu có mệnh đề WHERE) hoặc toàn bộ. Nó xóa từng hàng một và ghi lại mỗi hành động xóa vào nhật ký giao dịch (transaction log). Điều này làm cho DELETE chậm hơn nhưng cho phép hoàn tác (ROLLBACK) và có thể kích hoạt các TRIGGER (hành động tự động) trên bảng. TRUNCATE: Xóa tất cả các hàng trong bảng bằng cách giải phóng các trang dữ liệu (data pages) chứa dữ liệu của bảng. Nó không ghi log cho từng hàng nên thực thi nhanh hơn rất nhiều so với DELETE trên các bảng lớn. TRUNCATE không kích hoạt TRIGGER và thường không thể ROLLBACK một cách dễ dàng. DROP: Xóa toàn bộ đối tượng bảng, bao gồm cả cấu trúc và dữ liệu. Bảng đó sẽ không còn tồn tại trong cơ sở dữ liệu. Trường hợp sử dụng:\nDùng DELETE khi cần xóa dữ liệu có điều kiện (WHERE), muốn kích hoạt TRIGGER, hoặc cần khả năng hoàn tác. Ví dụ: Xóa một khách hàng cụ thể đã không hoạt động trong 2 năm. Dùng TRUNCATE khi cần xóa sạch dữ liệu của một bảng lớn một cách nhanh chóng và reset lại các giá trị tự tăng (identity), không quan tâm đến TRIGGER. Ví dụ: Dọn dẹp một bảng tạm (staging table) trước mỗi lần nhập dữ liệu hàng loạt. Dùng DROP khi muốn loại bỏ hoàn toàn một bảng không còn được sử dụng khỏi cơ sở dữ liệu. Việc lựa chọn đúng lệnh phụ thuộc vào mục đích cụ thể, yêu cầu về hiệu suất và khả năng phục hồi dữ liệu.\nPhần 5: DML - “Thêm, Sửa, Xóa” Dữ Liệu Sau khi đã có “ngôi nhà” (cấu trúc bảng), các lệnh DML giúp chúng ta đưa “đồ đạc” (dữ liệu) vào, sắp xếp lại hoặc loại bỏ chúng.\nINSERT INTO: Dùng để chèn một hoặc nhiều hàng dữ liệu mới vào một bảng. Cú pháp cơ bản: SQL INSERT INTO SinhVien (MaSV, HoTen, NgaySinh) VALUES (1, 'Nguyễn Văn A', '2002-01-15'); Chèn dữ liệu từ bảng khác: Một kỹ thuật nâng cao và rất hữu ích là sử dụng INSERT INTO... SELECT... để sao chép và chèn dữ liệu từ một bảng khác vào bảng hiện tại. SQL INSERT INTO SinhVienLuuTru (MaSV, HoTen) SELECT MaSV, HoTen FROM SinhVien WHERE NgaySinh \u003c '2000-01-01'; UPDATE: Dùng để cập nhật, sửa đổi các bản ghi hiện có trong bảng. SQL UPDATE SinhVien SET Email = 'a.nguyen@example.com' WHERE MaSV = 1; DELETE: Dùng để xóa một hoặc nhiều bản ghi khỏi bảng. SQL DELETE FROM SinhVien WHERE MaSV = 1; Tầm quan trọng sống còn của mệnh đề WHERE Một trong những sai lầm nguy hiểm và dễ mắc phải nhất đối với người mới làm việc với SQL là thực thi lệnh UPDATE hoặc DELETE mà quên mất mệnh đề WHERE. Nếu không có\nWHERE để chỉ định điều kiện, lệnh sẽ được áp dụng cho toàn bộ các hàng trong bảng, dẫn đến việc cập nhật hoặc xóa sạch dữ liệu một cách không mong muốn. Trong môi trường sản xuất, đây là một thảm họa có thể gây mất mát dữ liệu nghiêm trọng.\nVì vậy, một quy tắc vàng cần phải tuân thủ nghiêm ngặt là: Luôn luôn viết và kiểm tra câu lệnh SELECT với cùng mệnh đề WHERE trước khi thực thi UPDATE hoặc DELETE.\nViết câu lệnh SELECT * FROM ten_bang WHERE dieu_kien;. Chạy câu lệnh SELECT và kiểm tra kết quả để đảm bảo rằng nó chỉ trả về đúng những hàng mà bạn muốn thay đổi. Sau khi đã chắc chắn, thay thế SELECT * bằng UPDATE ten_bang SET... hoặc DELETE. Thực hành thói quen này sẽ giúp tránh được những sai lầm tốn kém và đảm bảo an toàn cho dữ liệu.\nPhần 6: DQL - Trái Tim Của SQL, Nghệ Thuật Truy Vấn Dữ Liệu Nếu DDL xây dựng cấu trúc và DML quản lý dữ liệu, thì DQL (với lệnh SELECT) chính là công cụ để khai thác giá trị từ dữ liệu đó. Đây là phần được sử dụng thường xuyên nhất trong công việc hàng ngày của một nhà phân tích.\nTruy vấn cơ bản SELECT: Chọn các cột mà bạn muốn hiển thị trong kết quả. Có thể sử dụng * để chọn tất cả các cột. FROM: Chỉ định bảng nguồn mà bạn muốn lấy dữ liệu từ đó. DISTINCT: Loại bỏ các hàng có giá trị trùng lặp hoàn toàn trong kết quả trả về. SQL\nSELECT DISTINCT ThanhPho FROM KhachHang; -- Lấy danh sách các thành phố duy nhất của khách hàng Lọc dữ liệu với WHERE Mệnh đề WHERE được dùng để lọc các hàng, chỉ giữ lại những hàng thỏa mãn một điều kiện nhất định.\nToán tử so sánh: =, != (hoặc \u003c\u003e), \u003e, \u003c, \u003e=, \u003c= Toán tử logic: AND, OR, NOT để kết hợp nhiều điều kiện. Toán tử nâng cao: IN: Kiểm tra xem giá trị của một cột có nằm trong một danh sách các giá trị cho trước hay không. BETWEEN: Lọc các giá trị nằm trong một khoảng (bao gồm cả hai đầu mút). LIKE: Tìm kiếm dữ liệu văn bản theo một mẫu. Nó thường được kết hợp với các ký tự đại diện: % (đại diện cho không, một hoặc nhiều ký tự) và _ (đại diện cho chính xác một ký tự). SQL\nSELECT * FROM SanPham WHERE Gia BETWEEN 100000 AND 500000 AND TenSanPham LIKE 'Áo sơ mi%'; Sắp xếp và Giới hạn ORDER BY: Sắp xếp tập kết quả theo một hoặc nhiều cột. ASC (Ascending) là sắp xếp tăng dần (mặc định), và DESC (Descending) là giảm dần. LIMIT / TOP: Giới hạn số lượng hàng được trả về. Cú pháp có sự khác biệt giữa các RDBMS: MySQL và PostgreSQL sử dụng LIMIT, trong khi SQL Server sử dụng TOP. SQL\n-- Lấy 5 sản phẩm đắt nhất (MySQL/PostgreSQL) SELECT TenSanPham, Gia FROM SanPham ORDER BY Gia DESC LIMIT 5; -- Lấy 5 sản phẩm đắt nhất (SQL Server) SELECT TOP 5 TenSanPham, Gia FROM SanPham ORDER BY Gia DESC; Các hàm tổng hợp (Aggregate Functions) Các hàm này thực hiện một phép tính trên một tập hợp các hàng và trả về một giá trị duy nhất, tóm tắt cho tập hợp đó.\nCOUNT(): Đếm số lượng hàng. SUM(): Tính tổng các giá trị (chỉ áp dụng cho cột số). AVG(): Tính giá trị trung bình (chỉ áp dụng cho cột số). MAX(): Tìm giá trị lớn nhất. MIN(): Tìm giá trị nhỏ nhất. Gom nhóm dữ liệu GROUP BY: Nhóm các hàng có cùng giá trị trong một hoặc nhiều cột lại với nhau thành các hàng tóm tắt. Lệnh này gần như luôn đi kèm với các hàm tổng hợp để thực hiện tính toán trên mỗi nhóm. HAVING: Được sử dụng sau GROUP BY để lọc các nhóm dựa trên một điều kiện. Điều kiện này thường áp dụng cho kết quả của một hàm tổng hợp. SQL\nSELECT ChuyenMuc, COUNT(*) AS SoLuongSanPham FROM SanPham GROUP BY ChuyenMuc HAVING COUNT(*) \u003e 10; -- Chỉ hiển thị các chuyên mục có nhiều hơn 10 sản phẩm Thứ tự thực thi logic và sự khác biệt giữa WHERE và HAVING Một trong những điểm gây nhầm lẫn nhất cho người mới học SQL là sự khác biệt giữa WHERE và HAVING. Cả hai đều dùng để lọc, nhưng chúng hoạt động ở các giai đoạn khác nhau trong quá trình xử lý truy vấn của cơ sở dữ liệu. Mặc dù chúng ta viết câu lệnh theo thứ tự\nSELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, hệ quản trị CSDL không thực thi theo thứ tự đó. Thứ tự xử lý logic thực tế là:\nFROM và JOIN: Xác định và kết hợp các bảng nguồn. WHERE: Lọc các hàng riêng lẻ dựa trên các điều kiện. GROUP BY: Gom các hàng đã được lọc thành các nhóm. HAVING: Lọc các nhóm đã được tạo. SELECT: Chọn các cột cuối cùng và tính toán các biểu thức. DISTINCT: Loại bỏ các hàng trùng lặp. ORDER BY: Sắp xếp tập kết quả cuối cùng. LIMIT / TOP: Lấy ra một phần của kết quả đã sắp xếp. Từ thứ tự này, có thể rút ra kết luận:\nWHERE được thực thi ở bước 2, trước khi dữ liệu được gom nhóm (bước 3). Do đó, WHERE chỉ có thể lọc dựa trên dữ liệu của từng hàng riêng lẻ và không thể sử dụng các hàm tổng hợp (như SUM(), COUNT()) vì chúng chưa được tính toán. HAVING được thực thi ở bước 4, sau khi dữ liệu đã được gom nhóm và các hàm tổng hợp đã được tính toán cho mỗi nhóm. Do đó, HAVING được thiết kế đặc biệt để lọc dựa trên kết quả của các hàm tổng hợp. Một cách dễ hình dung: WHERE là bộ lọc “đầu vào” cho các hàng, còn HAVING là bộ lọc “đầu ra” cho các nhóm.\nPhần 7: Sức Mạnh Kết Nối - Làm Chủ Các Loại JOIN Trong một cơ sở dữ liệu quan hệ được thiết kế tốt, dữ liệu thường được chia nhỏ ra nhiều bảng để tránh lặp lại và đảm bảo tính nhất quán. Lệnh JOIN chính là công cụ mạnh mẽ cho phép chúng ta kết hợp dữ liệu từ hai hoặc nhiều bảng này lại với nhau dựa trên các cột có liên quan (thường là cặp khóa chính - khóa ngoại).\nPhân tích chi tiết từng loại JOIN INNER JOIN (hoặc JOIN): Đây là loại JOIN phổ biến nhất. Nó trả về các bản ghi chỉ khi có giá trị khớp ở cả hai bảng tham gia. Về mặt lý thuyết tập hợp, đây chính là phép giao (intersection). LEFT JOIN (hoặc LEFT OUTER JOIN): Trả về tất cả các bản ghi từ bảng bên trái và các bản ghi khớp từ bảng bên phải. Nếu không có sự khớp nối, các cột tương ứng của bảng bên phải sẽ có giá trị NULL. RIGHT JOIN (hoặc RIGHT OUTER JOIN): Hoạt động ngược lại với LEFT JOIN. Nó trả về tất cả các bản ghi từ bảng bên phải và các bản ghi khớp từ bảng bên trái. Nếu không có sự khớp nối, các cột của bảng bên trái sẽ có giá trị NULL. FULL OUTER JOIN: Kết hợp kết quả của cả LEFT JOIN và RIGHT JOIN. Nó trả về tất cả các bản ghi khi có sự khớp ở một trong hai bảng. Nếu một hàng ở bảng này không có hàng khớp ở bảng kia, các cột của bảng kia sẽ là NULL. Đây là phép hợp (union) của hai tập hợp. CROSS JOIN: Trả về tích Descartes của hai bảng. Nó kết hợp mỗi hàng của bảng thứ nhất với tất cả các hàng của bảng thứ hai. Loại JOIN này có thể tạo ra một tập kết quả rất lớn và cần được sử dụng một cách cẩn trọng. SELF JOIN: Đây không phải là một loại JOIN riêng biệt mà là một kỹ thuật, trong đó một bảng được kết nối với chính nó. Kỹ thuật này rất hữu ích để truy vấn các dữ liệu có cấu trúc phân cấp, ví dụ như trong một bảng NhanVien, có cột MaNguoiQuanLy tham chiếu trở lại cột MaNhanVien trong cùng bảng đó. Bảng so sánh các loại JOIN\nLoại JOIN Kết Quả Trả Về Kịch Bản Sử Dụng Điển Hình INNER JOIN Chỉ các hàng có khóa khớp ở cả hai bảng. Lấy danh sách khách hàng đã từng đặt hàng. LEFT JOIN Tất cả hàng từ bảng trái, và hàng khớp từ bảng phải. Lấy danh sách tất cả khách hàng và đơn hàng của họ (kể cả những khách hàng chưa từng đặt hàng). RIGHT JOIN Tất cả hàng từ bảng phải, và hàng khớp từ bảng trái. Lấy danh sách tất cả sản phẩm và thông tin người đã mua chúng (kể cả những sản phẩm chưa từng được bán). FULL OUTER JOIN Tất cả hàng từ cả hai bảng. Lấy danh sách tất cả nhân viên và tất cả phòng ban, ghép nối thông tin nếu nhân viên thuộc phòng ban đó. CROSS JOIN Mọi tổ hợp hàng có thể có giữa hai bảng. Tạo dữ liệu thử nghiệm, ví dụ: ghép mọi size áo với mọi màu sắc để tạo danh sách sản phẩm. SELF JOIN Bảng tự kết nối với chính nó. Tìm tên của mỗi nhân viên và tên của người quản lý trực tiếp của họ trong cùng một bảng nhân sự. Phần 8: Giao Dịch và Bảo Mật - Đảm Bảo An Toàn Dữ Liệu Việc thao tác với dữ liệu không chỉ dừng lại ở truy vấn mà còn phải đảm bảo tính toàn vẹn và bảo mật. Đây là lúc các lệnh TCL và DCL phát huy vai trò.\nTCL - Transaction Control Language Một giao dịch (transaction) là một chuỗi các thao tác SQL được thực hiện như một đơn vị công việc logic duy nhất. Nguyên tắc của giao dịch là “hoặc tất cả thành công, hoặc tất cả thất bại”. Ví dụ kinh điển là giao dịch chuyển tiền: việc trừ tiền từ tài khoản A và cộng tiền vào tài khoản B phải cùng xảy ra, nếu một trong hai bước thất bại, toàn bộ giao dịch phải được hủy bỏ.\nĐộ tin cậy của giao dịch được đảm bảo bởi bốn thuộc tính, gọi là ACID:\nAtomicity (Tính nguyên tử): Giao dịch là không thể chia nhỏ. Consistency (Tính nhất quán): Giao dịch đưa cơ sở dữ liệu từ một trạng thái hợp lệ này sang một trạng thái hợp lệ khác. Isolation (Tính cô lập): Các giao dịch đồng thời không ảnh hưởng lẫn nhau. Durability (Tính bền vững): Một khi giao dịch đã được xác nhận thành công, các thay đổi của nó sẽ tồn tại vĩnh viễn, ngay cả khi hệ thống gặp sự cố. 20 Các lệnh TCL chính bao gồm:\nCOMMIT: Lưu vĩnh viễn các thay đổi của giao dịch hiện tại vào cơ sở dữ liệu. ROLLBACK: Hủy bỏ tất cả các thay đổi đã được thực hiện trong giao dịch hiện tại, đưa cơ sở dữ liệu trở về trạng thái trước khi giao dịch bắt đầu. SAVEPOINT: Đặt một điểm lưu tạm thời bên trong một giao dịch. Điều này cho phép ROLLBACK về một điểm cụ thể mà không cần phải hủy bỏ toàn bộ giao dịch. DCL - Data Control Language DCL là nhóm lệnh dùng để quản lý quyền truy cập của người dùng đối với các đối tượng trong cơ sở dữ liệu, đảm bảo rằng chỉ những người được ủy quyền mới có thể thực hiện các hành động nhất định.\nGRANT: Cấp quyền cho một người dùng hoặc một nhóm người dùng. Ví dụ: cấp quyền SELECT, INSERT trên một bảng cụ thể. REVOKE: Thu hồi lại các quyền đã được cấp trước đó. SQL\n-- Cấp quyền SELECT trên bảng SanPham cho người dùng 'analyst' GRANT SELECT ON SanPham TO analyst; -- Thu hồi quyền INSERT trên bảng SanPham từ người dùng 'analyst' REVOKE INSERT ON SanPham FROM analyst; Việc cấp quyền trực tiếp trên các bảng dữ liệu gốc đôi khi có thể làm lộ thông tin nhạy cảm (ví dụ: cột Luong trong bảng NhanVien). Để giải quyết vấn đề này, DCL thường được sử dụng kết hợp với các đối tượng cơ sở dữ liệu khác như View và Stored Procedure để tạo ra một cơ chế bảo mật đa lớp và linh hoạt hơn. Thay vì cấp quyền SELECT trực tiếp trên bảng NhanVien, quản trị viên có thể tạo một View không chứa cột Luong và chỉ cấp quyền SELECT trên View đó cho người dùng. Tương tự, thay vì cấp quyền\nUPDATE trên bảng, quản trị viên có thể tạo một Stored Procedure để thực hiện một hành động cụ thể (như tăng lương) và chỉ cấp quyền thực thi (EXECUTE) thủ tục đó. Cách tiếp cận này che giấu cấu trúc dữ liệu phức tạp và giới hạn các hành động mà người dùng có thể thực hiện, tăng cường đáng kể tính bảo mật.\nPhần 9: Tối Ưu Hóa và Các Đối Tượng Nâng Cao Để làm việc hiệu quả với các hệ thống cơ sở dữ liệu lớn, việc hiểu và sử dụng các đối tượng nâng cao để tối ưu hóa hiệu suất là vô cùng cần thiết.\nIndex (Chỉ mục) Khái niệm: Một chỉ mục (Index) là một cấu trúc dữ liệu đặc biệt được sử dụng để tăng tốc độ truy xuất dữ liệu từ một bảng. Nó hoạt động tương tự như mục lục ở cuối một cuốn sách. Thay vì phải lật từng trang (quét toàn bộ bảng - table scan) để tìm thông tin, cơ sở dữ liệu có thể sử dụng chỉ mục để đi thẳng đến vị trí của dữ liệu cần tìm. Lợi ích và Đánh đổi: Lợi ích chính của chỉ mục là tăng tốc đáng kể các truy vấn SELECT có mệnh đề WHERE hoặc các phép JOIN. Tuy nhiên, nó cũng có một cái giá phải trả: các thao tác ghi dữ liệu (INSERT, UPDATE, DELETE) sẽ trở nên chậm hơn, vì ngoài việc thay đổi dữ liệu trong bảng, cơ sở dữ liệu còn phải cập nhật cả cấu trúc của chỉ mục. Do đó, cần cân nhắc kỹ lưỡng việc tạo chỉ mục trên các bảng có tần suất ghi dữ liệu cao. Cú pháp: SQL CREATE INDEX idx_TenSanPham ON SanPham (TenSanPham); View (Khung nhìn) Khái niệm: Một View là một “bảng ảo” (virtual table), được định nghĩa bởi một câu lệnh SELECT. View không lưu trữ dữ liệu của riêng nó mà chỉ đơn giản là một “cửa sổ” để nhìn vào dữ liệu từ một hoặc nhiều bảng cơ sở. Mọi thao tác trên View thực chất sẽ được phản ánh xuống các bảng gốc. Lợi ích: Đơn giản hóa truy vấn phức tạp: Một câu lệnh JOIN phức tạp qua nhiều bảng có thể được gói gọn trong một View. Sau đó, người dùng chỉ cần thực hiện một câu lệnh SELECT đơn giản từ View đó. Tăng cường bảo mật: Cho phép giới hạn quyền truy cập của người dùng. Họ chỉ có thể xem và tương tác với dữ liệu thông qua View (ví dụ: một View không chứa các cột nhạy cảm như lương hoặc thông tin cá nhân). Tính nhất quán: Đảm bảo rằng nhiều ứng dụng và người dùng khác nhau cùng truy cập vào một logic dữ liệu nhất quán được định nghĩa sẵn trong View. Cú pháp: SQL CREATE VIEW v_SanPhamGiaCao AS SELECT TenSanPham, Gia, ChuyenMuc FROM SanPham WHERE Gia \u003e 1000000; Stored Procedure (Thủ tục lưu trữ) Khái niệm: Một Stored Procedure (thường gọi tắt là SP) là một nhóm các câu lệnh SQL đã được biên dịch trước và được lưu trữ ngay trong cơ sở dữ liệu. Nó có thể nhận các tham số đầu vào, thực hiện một chuỗi logic phức tạp và trả về kết quả. Lợi ích: Tái sử dụng mã: Viết một lần, gọi nhiều lần từ các ứng dụng khác nhau mà không cần lặp lại mã. Tăng hiệu suất: Vì các SP đã được biên dịch và tối ưu hóa sẵn, việc thực thi chúng thường nhanh hơn so với việc gửi các câu lệnh SQL riêng lẻ từ ứng dụng qua mạng. Giảm lưu lượng mạng: Thay vì gửi một khối mã SQL dài, ứng dụng chỉ cần gửi một lệnh gọi SP ngắn gọn. Tăng cường bảo mật: Tương tự như View, có thể cấp cho người dùng quyền thực thi một SP mà không cần cấp quyền trực tiếp trên các bảng cơ sở. Điều này giúp kiểm soát chặt chẽ các hành động và là một biện pháp hiệu quả để chống lại các cuộc tấn công SQL Injection. Cú pháp (ví dụ trong SQL Server): SQL CREATE PROCEDURE sp_TimSanPhamTheoGia @GiaToiThieu DECIMAL(10, 2) AS BEGIN SELECT TenSanPham, Gia FROM SanPham WHERE Gia \u003e= @GiaToiThieu; END; Phần 10: Tổng Kết và Lộ Trình Học Tập Tiếp Theo Qua các phần trên, chúng ta đã cùng nhau xây dựng một nền tảng vững chắc về SQL, từ việc hiểu các khái niệm cơ bản về cơ sở dữ liệu quan hệ, phân loại và nắm vững cú pháp của 5 họ lệnh chính (DDL, DML, DQL, DCL, TCL), cho đến việc làm chủ các kỹ thuật mạnh mẽ như JOIN, GROUP BY và các đối tượng nâng cao như Index, View, Stored Procedure.\nTuy nhiên, SQL là một kỹ năng cần được mài giũa qua thực hành liên tục. Kiến thức lý thuyết là quan trọng, nhưng việc áp dụng chúng để giải quyết các bài toán dữ liệu thực tế mới thực sự giúp bạn trở thành một chuyên gia. Các nền tảng như LeetCode, HackerRank hay các bộ dữ liệu công khai là những nguồn tài nguyên tuyệt vời để luyện tập.\nSau khi đã nắm vững các kiến thức trong cẩm nang này, đây là một vài gợi ý cho lộ trình học tập tiếp theo của bạn:\nHàm cửa sổ (Window Functions): Đây là một bước tiến lớn trong phân tích dữ liệu. Các hàm như ROW_NUMBER(), RANK(), DENSE_RANK(), LEAD(), LAG() cho phép thực hiện các phép tính phức tạp trên một “cửa sổ” các hàng liên quan mà không làm thay đổi kết quả của truy vấn chính. Tối ưu hóa truy vấn (Query Optimization): Học cách đọc và hiểu kế hoạch thực thi (Execution Plan) của một câu lệnh SQL để xác định các điểm nghẽn về hiệu suất và tìm cách cải thiện chúng. Chuyên sâu về một RDBMS cụ thể: Mỗi hệ quản trị cơ sở dữ liệu như PostgreSQL, SQL Server, hay MySQL đều có những tính năng và cú pháp đặc thù. Việc tìm hiểu sâu về một hệ thống sẽ mở ra nhiều khả năng mạnh mẽ hơn. Hành trình làm chủ SQL là một cuộc marathon, không phải là một cuộc chạy nước rút. Hy vọng rằng cuốn cẩm nang này sẽ là người bạn đồng hành đáng tin cậy trên chặng đường chinh phục thế giới dữ liệu của bạn.\nNếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!\n","wordCount":"6244","inLanguage":"en","image":"https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-12T00:00:00Z","dateModified":"2025-08-12T00:00:00Z","author":{"@type":"Person","name":"Nagih"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nagih.io.vn/posts/database/sql/"},"publisher":{"@type":"Organization","name":"Nagih | Blog","logo":{"@type":"ImageObject","url":"https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nagih.io.vn/ accesskey=h title="Home (Alt + H)"><img src=https://blog.nagih.io.vn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.nagih.io.vn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nagih.io.vn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nagih.io.vn/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.nagih.io.vn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://nagih.io.vn title=Home><span>Home</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nagih.io.vn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.nagih.io.vn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SQL Overview</h1><div class=post-meta><span title='2025-08-12 00:00:00 +0000 UTC'>August 12, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;6244 words&nbsp;·&nbsp;Nagih&nbsp;|&nbsp;<a href=https://github.com/vuongmanhnghia/posts/content/posts/database/SQL.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng</p><h2 id=phần-1-giới-thiệu---sql-là-gì-và-tại-sao-bạn-cần-phải-học-nó>Phần 1: Giới Thiệu - SQL Là Gì và Tại Sao Bạn Cần Phải Học Nó?<a hidden class=anchor aria-hidden=true href=#phần-1-giới-thiệu---sql-là-gì-và-tại-sao-bạn-cần-phải-học-nó>#</a></h2><h3 id=sql-là-gì>SQL là gì?<a hidden class=anchor aria-hidden=true href=#sql-là-gì>#</a></h3><p>SQL, viết tắt của <strong>Structured Query Language</strong> (Ngôn ngữ Truy vấn có Cấu trúc), là ngôn ngữ tiêu chuẩn được sử dụng để giao tiếp, quản lý và thao tác với các cơ sở dữ liệu quan hệ. Cần phải nhấn mạnh rằng SQL không phải là một ngôn ngữ lập trình đa năng như Python hay Java, mà là một ngôn ngữ chuyên dụng, được thiết kế riêng cho mục đích làm việc với dữ liệu. Một trong những ưu điểm lớn nhất của SQL là nó không đòi hỏi kỹ năng mã hóa phức tạp, thay vào đó, nó sử dụng các từ khóa tiếng Anh gần gũi và dễ hiểu như</p><p><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, giúp người dùng dễ dàng tiếp cận và sử dụng.</p><h3 id=lịch-sử-hình-thành>Lịch sử hình thành<a hidden class=anchor aria-hidden=true href=#lịch-sử-hình-thành>#</a></h3><p>SQL ra đời vào những năm 1970, được phát triển bởi hai kỹ sư của IBM là Donald D. Chamberlin và Raymond F. Boyce. Ngôn ngữ này được xây dựng dựa trên nền tảng lý thuyết của mô hình cơ sở dữ liệu quan hệ do Tiến sĩ Edgar F. Codd, cũng là một nhà khoa học của IBM, đề xuất vào năm 1970. Ban đầu, nó có tên là SEQUEL (Structured English Query Language), nhưng sau đó được rút gọn thành SQL do một tranh chấp về thương hiệu. Kể từ đó, SQL đã trở thành một tiêu chuẩn công nghiệp được công nhận toàn cầu.</p><h3 id=vai-trò-và-ứng-dụng-thực-tế>Vai trò và ứng dụng thực tế<a hidden class=anchor aria-hidden=true href=#vai-trò-và-ứng-dụng-thực-tế>#</a></h3><p>Ngày nay, SQL là một kỹ năng không thể thiếu đối với nhiều vị trí trong ngành công nghệ, từ nhà phân tích dữ liệu, nhà khoa học dữ liệu, lập trình viên backend cho đến quản trị viên cơ sở dữ liệu. Sự phổ biến của nó đến từ khả năng ứng dụng trong vô số lĩnh vực:</p><ul><li><strong>Phân tích kinh doanh (Business Intelligence):</strong> Các chuyên gia sử dụng SQL để trích xuất, tổng hợp và phân tích dữ liệu từ các hệ thống lớn, nhằm tìm ra các xu hướng (insights) kinh doanh, tạo báo cáo và hỗ trợ việc ra quyết định.</li><li><strong>Phát triển ứng dụng:</strong> Hầu hết các ứng dụng web và di động đều cần một nơi để lưu trữ dữ liệu người dùng, thông tin sản phẩm, đơn hàng, v.v. SQL đóng vai trò là cầu nối ở tầng backend, giúp ứng dụng quản lý và thao tác với các dữ liệu này.</li><li><strong>Ngành Game:</strong> Các trò chơi điện tử sử dụng cơ sở dữ liệu để lưu trữ và quản lý một lượng lớn thông tin như hồ sơ người chơi, điểm số, vật phẩm và thành tích.</li><li><strong>Hệ thống giáo dục:</strong> Các trường học và tổ chức giáo dục dùng SQL để quản lý hồ sơ sinh viên, thông tin khóa học, điểm số và các hoạt động hành chính khác.</li></ul><h3 id=các-hệ-quản-trị-cơ-sở-dữ-liệu-quan-hệ-rdbms-phổ-biến>Các Hệ Quản trị Cơ sở dữ liệu Quan hệ (RDBMS) phổ biến<a hidden class=anchor aria-hidden=true href=#các-hệ-quản-trị-cơ-sở-dữ-liệu-quan-hệ-rdbms-phổ-biến>#</a></h3><p>Một điểm quan trọng cần làm rõ là sự khác biệt giữa SQL và các Hệ Quản trị Cơ sở dữ liệu Quan hệ (Relational Database Management System - RDBMS). SQL là ngôn ngữ, trong khi RDBMS là phần mềm, là hệ thống thực thi các câu lệnh SQL đó. Có thể hình dung SQL như &ldquo;tiếng Anh&rdquo;, còn RDBMS như một &ldquo;nhà xuất bản&rdquo; sử dụng tiếng Anh để tạo ra sách. Việc nhầm lẫn giữa SQL và MySQL là rất phổ biến; MySQL chỉ là một trong nhiều RDBMS sử dụng ngôn ngữ SQL.</p><p>Một số RDBMS phổ biến hiện nay bao gồm:</p><ul><li><strong>MySQL:</strong> Một hệ quản trị CSDL quan hệ mã nguồn mở rất phổ biến, đặc biệt trong các ứng dụng web.</li><li><strong>PostgreSQL:</strong> Một hệ quản trị CSDL quan hệ mã nguồn mở mạnh mẽ, nổi tiếng với sự tuân thủ chuẩn SQL và các tính năng nâng cao.</li><li><strong>Microsoft SQL Server:</strong> Một sản phẩm thương mại của Microsoft, được sử dụng rộng rãi trong các môi trường doanh nghiệp, đặc biệt là các tổ chức sử dụng hệ sinh thái Windows.</li><li><strong>Oracle Database:</strong> Một hệ quản trị CSDL thương mại hàng đầu, thường được các tập đoàn lớn sử dụng cho các ứng dụng quan trọng và yêu cầu hiệu suất cao.</li></ul><h2 id=phần-2-nền-tảng-của-sql---hiểu-về-cơ-sở-dữ-liệu-quan-hệ>Phần 2: Nền Tảng Của SQL - Hiểu Về Cơ Sở Dữ Liệu Quan Hệ<a hidden class=anchor aria-hidden=true href=#phần-2-nền-tảng-của-sql---hiểu-về-cơ-sở-dữ-liệu-quan-hệ>#</a></h2><p>Trước khi viết những câu lệnh SQL đầu tiên, việc nắm vững các khái niệm nền tảng của cơ sở dữ liệu quan hệ là điều kiện tiên quyết. Đây chính là cấu trúc mà SQL được thiết kế để tương tác.</p><h3 id=các-khái-niệm-cốt-lõi>Các khái niệm cốt lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi>#</a></h3><ul><li><strong>Cơ sở dữ liệu (Database):</strong> Là một tập hợp các thông tin có liên quan đến nhau, được tổ chức và lưu trữ một cách có hệ thống trên máy tính để có thể dễ dàng truy cập và quản lý.</li><li><strong>Cơ sở dữ liệu quan hệ (Relational Database):</strong> Là một loại cơ sở dữ liệu mà trong đó dữ liệu được tổ chức thành các bảng (tables) có cấu trúc chặt chẽ. Mô hình này được E.F. Codd đề xuất vào năm 1970 và đã trở thành mô hình thống trị trong quản lý dữ liệu suốt nhiều thập kỷ.</li><li><strong>Bảng (Table):</strong> Là thành phần cấu trúc cơ bản nhất trong CSDL quan hệ, bao gồm các hàng và cột. Mỗi bảng đại diện cho một loại thực thể, ví dụ như bảng <code>SinhVien</code>, bảng <code>SanPham</code>.</li><li><strong>Hàng (Row) và Cột (Column):</strong><ul><li><strong>Cột (Column/Field/Attribute):</strong> Đại diện cho một thuộc tính hoặc một mẩu thông tin mô tả thực thể. Ví dụ, trong bảng <code>SinhVien</code>, các cột có thể là <code>MaSinhVien</code>, <code>HoTen</code>, <code>NgaySinh</code>.</li><li><strong>Hàng (Row/Record/Tuple):</strong> Đại diện cho một bản ghi dữ liệu cụ thể, một thực thể đơn lẻ trong bảng. Ví dụ, một hàng trong bảng <code>SinhVien</code> chứa thông tin đầy đủ của một sinh viên cụ thể.</li></ul></li></ul><h3 id=chìa-khóa-của-sự-toàn-vẹn>Chìa khóa của sự toàn vẹn<a hidden class=anchor aria-hidden=true href=#chìa-khóa-của-sự-toàn-vẹn>#</a></h3><p>Để đảm bảo dữ liệu luôn chính xác và nhất quán, CSDL quan hệ sử dụng các loại &ldquo;khóa&rdquo;.</p><ul><li><strong>Khóa chính (Primary Key):</strong> Là một hoặc nhiều cột được sử dụng để xác định <em>duy nhất</em> mỗi hàng trong một bảng. Giá trị trong cột khóa chính không được phép trống (<code>NULL</code>) và phải là duy nhất trong toàn bộ bảng. Đây là &ldquo;chứng minh nhân dân&rdquo; của mỗi hàng.</li><li><strong>Khóa ngoại (Foreign Key):</strong> Là một cột (hoặc một nhóm cột) trong một bảng dùng để thiết lập một liên kết đến khóa chính của một bảng khác. Khóa ngoại là cơ chế để thực thi <em>toàn vẹn tham chiếu</em> (referential integrity), đảm bảo rằng mối quan hệ giữa các bảng luôn hợp lệ. Ví dụ, trong bảng <code>DonHang</code>, cột <code>MaKhachHang</code> sẽ là khóa ngoại tham chiếu đến cột <code>MaKhachHang</code> (khóa chính) trong bảng <code>KhachHang</code>.</li></ul><h3 id=các-kiểu-dữ-liệu-data-types>Các kiểu dữ liệu (Data Types)<a hidden class=anchor aria-hidden=true href=#các-kiểu-dữ-liệu-data-types>#</a></h3><p>Mỗi cột trong một bảng phải được gán một kiểu dữ liệu cụ thể. Kiểu dữ liệu định nghĩa loại giá trị mà cột đó có thể chứa, ví dụ như số nguyên, văn bản, ngày tháng, v.v.. Việc chọn đúng kiểu dữ liệu không chỉ đảm bảo tính toàn vẹn mà còn giúp tối ưu hóa không gian lưu trữ và hiệu suất truy vấn.</p><p>Mặc dù SQL có một bộ chuẩn, các RDBMS khác nhau có thể có những tên gọi và đặc điểm riêng cho các kiểu dữ liệu. Việc hiểu rõ sự khác biệt này là rất quan trọng khi làm việc trên nhiều hệ thống.</p><p><strong>Bảng so sánh các kiểu dữ liệu phổ biến</strong></p><table><thead><tr><th>Loại Dữ Liệu</th><th>SQL Server</th><th>MySQL</th><th>Oracle</th><th>Mô tả chung</th></tr></thead><tbody><tr><td><strong>Chuỗi Ký Tự</strong></td><td><code>VARCHAR(n)</code>, <code>NVARCHAR(n)</code>, <code>VARCHAR(MAX)</code></td><td><code>VARCHAR(n)</code>, <code>TEXT</code></td><td><code>VARCHAR2(n)</code>, <code>CLOB</code></td><td>Lưu trữ văn bản. Kiểu có tiền tố <code>N</code> (ví dụ: <code>NVARCHAR</code>) dùng để lưu trữ ký tự Unicode (đa ngôn ngữ)</td></tr><tr><td><strong>Số Nguyên</strong></td><td><code>TINYINT</code>, <code>SMALLINT</code>, <code>INT</code>, <code>BIGINT</code></td><td><code>TINYINT</code>, <code>SMALLINT</code>, <code>INT</code>, <code>BIGINT</code></td><td><code>NUMBER(p)</code></td><td>Lưu trữ các số không có phần thập phân, với các phạm vi khác nhau</td></tr><tr><td><strong>Số Thực</strong></td><td><code>FLOAT</code>, <code>REAL</code>, <code>DECIMAL(p,s)</code></td><td><code>FLOAT</code>, <code>DOUBLE</code>, <code>DECIMAL(p,s)</code></td><td><code>NUMBER(p,s)</code>, <code>FLOAT</code></td><td>Lưu trữ các số có phần thập phân. <code>DECIMAL</code> dùng cho các giá trị cần độ chính xác cao như tiền tệ</td></tr><tr><td><strong>Ngày & Giờ</strong></td><td><code>DATE</code>, <code>TIME</code>, <code>DATETIME2</code>, <code>SMALLDATETIME</code></td><td><code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code></td><td><code>DATE</code>, <code>TIMESTAMP</code></td><td>Lưu trữ thông tin về ngày, giờ hoặc cả hai</td></tr><tr><td><strong>Logic/Bit</strong></td><td><code>BIT</code></td><td><code>BOOLEAN</code> (thực chất là <code>TINYINT(1)</code>)</td><td>(Không có kiểu riêng, thường dùng <code>NUMBER(1)</code>)</td><td>Lưu trữ giá trị logic True/False (thường là 1/0)</td></tr></tbody></table><h3 id=các-ràng-buộc-constraints>Các ràng buộc (Constraints)<a hidden class=anchor aria-hidden=true href=#các-ràng-buộc-constraints>#</a></h3><p>Ràng buộc là các quy tắc được áp dụng trên các cột của bảng để đảm bảo tính chính xác và toàn vẹn của dữ liệu. Ngoài khóa chính và khóa ngoại, các ràng buộc phổ biến khác bao gồm:</p><ul><li><code>NOT NULL</code>: Đảm bảo một cột không thể có giá trị <code>NULL</code> (trống).</li><li><code>UNIQUE</code>: Đảm bảo tất cả các giá trị trong một cột phải là duy nhất.</li><li><code>CHECK</code>: Đảm bảo rằng tất cả các giá trị trong một cột thỏa mãn một điều kiện cụ thể (ví dụ: <code>Tuoi > 18</code>).</li><li><code>DEFAULT</code>: Cung cấp một giá trị mặc định cho một cột khi không có giá trị nào được chỉ định lúc chèn dữ liệu.</li></ul><h2 id=phần-3-phân-loại-lệnh-sql---sơ-đồ-tư-duy-để-làm-chủ-sql>Phần 3: Phân Loại Lệnh SQL - Sơ Đồ Tư Duy Để Làm Chủ SQL<a hidden class=anchor aria-hidden=true href=#phần-3-phân-loại-lệnh-sql---sơ-đồ-tư-duy-để-làm-chủ-sql>#</a></h2><p>Để hệ thống hóa kiến thức và hiểu rõ mục đích của từng câu lệnh, SQL được chia thành các nhóm lệnh con. Cách phân loại phổ biến và hiện đại nhất chia SQL thành 5 họ lệnh chính. Việc hiểu rõ sự phân chia này giống như có một bản đồ tư duy, giúp người học biết chính xác nên dùng công cụ nào cho công việc nào.</p><ul><li><strong>DDL (Data Definition Language - Ngôn ngữ Định nghĩa Dữ liệu):</strong> Các lệnh này được sử dụng để định nghĩa, tạo, thay đổi và xóa cấu trúc của các đối tượng trong cơ sở dữ liệu như bảng, chỉ mục, hay view.</li><li><strong>DML (Data Manipulation Language - Ngôn ngữ Thao tác Dữ liệu):</strong> Các lệnh này dùng để quản lý dữ liệu bên trong các bảng, bao gồm việc thêm, cập nhật và xóa dữ liệu.</li><li><strong>DQL (Data Query Language - Ngôn ngữ Truy vấn Dữ liệu):</strong> Họ lệnh này chỉ có một thành viên duy nhất và quan trọng nhất là <code>SELECT</code>. Nó được dùng để truy xuất và đọc dữ liệu từ cơ sở dữ liệu.</li><li><strong>DCL (Data Control Language - Ngôn ngữ Điều khiển Dữ liệu):</strong> Các lệnh này liên quan đến việc quản lý quyền truy cập và bảo mật, cho phép hoặc thu hồi quyền của người dùng trên các đối tượng cơ sở dữ liệu.</li><li><strong>TCL (Transaction Control Language - Ngôn ngữ Điều khiển Giao dịch):</strong> Các lệnh này quản lý các giao dịch (transactions) để đảm bảo tính toàn vẹn và nhất quán của dữ liệu khi thực hiện một chuỗi các thao tác.</li></ul><p>Một số tài liệu cũ hoặc một số hệ thống có thể gộp lệnh <code>SELECT</code> vào nhóm DML, vì nó cũng là một dạng &ldquo;thao tác&rdquo; với dữ liệu (thao tác đọc). Tuy nhiên, cách phân loại hiện đại tách</p><p><code>SELECT</code> thành một họ riêng là DQL mang lại sự rõ ràng và logic hơn. Việc tách biệt này nhấn mạnh sự khác biệt cơ bản giữa các hành động <strong>thay đổi trạng thái</strong> của dữ liệu (ghi - write) của DML và hành động <strong>chỉ đọc trạng thái</strong> (đọc - read) của DQL. Đối với người học, việc phân biệt rạch ròi giữa &ldquo;đọc&rdquo; và &ldquo;ghi&rdquo; là cực kỳ quan trọng để hiểu sâu hơn về các vấn đề như hiệu suất, khóa (locking) và bảo mật trong cơ sở dữ liệu.</p><p><strong>Bảng tổng quan các lệnh SQL</strong></p><p>Bảng dưới đây cung cấp một cái nhìn tổng thể về các họ lệnh và các lệnh chính thuộc mỗi họ, đóng vai trò như một bản đồ để định hướng trong suốt quá trình học.</p><table><thead><tr><th>Họ Lệnh</th><th>Tên Đầy Đủ</th><th>Mục Đích</th><th>Các Lệnh Chính</th></tr></thead><tbody><tr><td><strong>DDL</strong></td><td>Data Definition Language</td><td>Định nghĩa, thay đổi cấu trúc CSDL</td><td><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>TRUNCATE</code></td></tr><tr><td><strong>DML</strong></td><td>Data Manipulation Language</td><td>Thêm, sửa, xóa dữ liệu</td><td><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></td></tr><tr><td><strong>DQL</strong></td><td>Data Query Language</td><td>Truy vấn, đọc dữ liệu</td><td><code>SELECT</code></td></tr><tr><td><strong>DCL</strong></td><td>Data Control Language</td><td>Quản lý quyền truy cập</td><td><code>GRANT</code>, <code>REVOKE</code></td></tr><tr><td><strong>TCL</strong></td><td>Transaction Control Language</td><td>Quản lý các giao dịch</td><td><code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code></td></tr></tbody></table><h2 id=phần-4-ddl---xây-dựng-và-quản-lý-ngôi-nhà-dữ-liệu>Phần 4: DDL - Xây Dựng và Quản Lý &ldquo;Ngôi Nhà&rdquo; Dữ Liệu<a hidden class=anchor aria-hidden=true href=#phần-4-ddl---xây-dựng-và-quản-lý-ngôi-nhà-dữ-liệu>#</a></h2><p>Các lệnh DDL là những công cụ đầu tiên bạn cần đến khi bắt đầu một dự án, dùng để xây dựng nên &ldquo;khung xương&rdquo; cho cơ sở dữ liệu của mình.</p><ul><li><code>CREATE DATABASE</code>, <code>CREATE TABLE</code>: Được dùng để tạo mới một cơ sở dữ liệu hoặc một bảng. Khi tạo bảng, chúng ta cần định nghĩa các cột, kiểu dữ liệu cho từng cột và các ràng buộc cần thiết như khóa chính (<code>PRIMARY KEY</code>) hay <code>NOT NULL</code>.<ul><li>Ví dụ tạo bảng:
SQL<pre tabindex=0><code>CREATE TABLE SinhVien (
    MaSV INT PRIMARY KEY,
    HoTen NVARCHAR(100) NOT NULL,
    NgaySinh DATE
);
</code></pre></li></ul></li><li><code>ALTER TABLE</code>: Lệnh này cho phép sửa đổi cấu trúc của một bảng đã tồn tại. Các thao tác phổ biến bao gồm thêm cột (<code>ADD COLUMN</code>), xóa cột (<code>DROP COLUMN</code>), hoặc thay đổi kiểu dữ liệu của một cột (<code>MODIFY COLUMN</code> hoặc <code>ALTER COLUMN</code>).<ul><li>Ví dụ thêm cột:<pre tabindex=0><code>ALTER TABLE SinhVien ADD Email VARCHAR(255);
</code></pre></li></ul></li><li><code>DROP DATABASE</code>, <code>DROP TABLE</code>: Xóa vĩnh viễn một cơ sở dữ liệu hoặc một bảng, bao gồm cả cấu trúc, dữ liệu, chỉ mục và các ràng buộc liên quan. Đây là một hành động cực kỳ nguy hiểm và không thể hoàn tác nếu không có bản sao lưu (backup).</li><li><code>TRUNCATE TABLE</code>: Xóa toàn bộ dữ liệu bên trong một bảng một cách nhanh chóng nhưng vẫn giữ lại cấu trúc của bảng (tên cột, kiểu dữ liệu, chỉ mục, v.v.). Lệnh này hữu ích khi cần dọn sạch dữ liệu trong một bảng tạm để nạp dữ liệu mới.</li></ul><h3 id=so-sánh-chuyên-sâu-delete-truncate-và-drop>So sánh chuyên sâu: DELETE, TRUNCATE, và DROP<a hidden class=anchor aria-hidden=true href=#so-sánh-chuyên-sâu-delete-truncate-và-drop>#</a></h3><p>Người mới bắt đầu thường nhầm lẫn giữa ba lệnh này vì chúng đều liên quan đến việc &ldquo;xóa&rdquo;. Tuy nhiên, chúng hoạt động theo những cách rất khác nhau và có những hệ quả riêng biệt.</p><ol><li><p><strong>Phân loại lệnh:</strong> <code>DELETE</code> là một lệnh DML (Thao tác dữ liệu), trong khi <code>TRUNCATE</code> và <code>DROP</code> là các lệnh DDL (Định nghĩa dữ liệu). Sự khác biệt này không chỉ mang tính học thuật mà còn dẫn đến những khác biệt về cơ chế hoạt động.</p></li><li><p><strong>Cơ chế hoạt động và Hiệu suất:</strong></p><ul><li><code>DELETE</code>: Xóa các hàng một cách có chọn lọc (nếu có mệnh đề <code>WHERE</code>) hoặc toàn bộ. Nó xóa từng hàng một và ghi lại mỗi hành động xóa vào nhật ký giao dịch (transaction log). Điều này làm cho <code>DELETE</code> chậm hơn nhưng cho phép hoàn tác (<code>ROLLBACK</code>) và có thể kích hoạt các <code>TRIGGER</code> (hành động tự động) trên bảng.</li><li><code>TRUNCATE</code>: Xóa tất cả các hàng trong bảng bằng cách giải phóng các trang dữ liệu (data pages) chứa dữ liệu của bảng. Nó không ghi log cho từng hàng nên thực thi nhanh hơn rất nhiều so với <code>DELETE</code> trên các bảng lớn. <code>TRUNCATE</code> không kích hoạt <code>TRIGGER</code> và thường không thể <code>ROLLBACK</code> một cách dễ dàng.</li><li><code>DROP</code>: Xóa toàn bộ đối tượng bảng, bao gồm cả cấu trúc và dữ liệu. Bảng đó sẽ không còn tồn tại trong cơ sở dữ liệu.</li></ul></li><li><p><strong>Trường hợp sử dụng:</strong></p><ul><li><strong>Dùng <code>DELETE</code></strong> khi cần xóa dữ liệu có điều kiện (<code>WHERE</code>), muốn kích hoạt <code>TRIGGER</code>, hoặc cần khả năng hoàn tác. Ví dụ: Xóa một khách hàng cụ thể đã không hoạt động trong 2 năm.</li><li><strong>Dùng <code>TRUNCATE</code></strong> khi cần xóa sạch dữ liệu của một bảng lớn một cách nhanh chóng và reset lại các giá trị tự tăng (identity), không quan tâm đến <code>TRIGGER</code>. Ví dụ: Dọn dẹp một bảng tạm (staging table) trước mỗi lần nhập dữ liệu hàng loạt.</li><li><strong>Dùng <code>DROP</code></strong> khi muốn loại bỏ hoàn toàn một bảng không còn được sử dụng khỏi cơ sở dữ liệu.</li></ul></li></ol><p>Việc lựa chọn đúng lệnh phụ thuộc vào mục đích cụ thể, yêu cầu về hiệu suất và khả năng phục hồi dữ liệu.</p><h2 id=phần-5-dml---thêm-sửa-xóa-dữ-liệu>Phần 5: DML - &ldquo;Thêm, Sửa, Xóa&rdquo; Dữ Liệu<a hidden class=anchor aria-hidden=true href=#phần-5-dml---thêm-sửa-xóa-dữ-liệu>#</a></h2><p>Sau khi đã có &ldquo;ngôi nhà&rdquo; (cấu trúc bảng), các lệnh DML giúp chúng ta đưa &ldquo;đồ đạc&rdquo; (dữ liệu) vào, sắp xếp lại hoặc loại bỏ chúng.</p><ul><li><code>INSERT INTO</code>: Dùng để chèn một hoặc nhiều hàng dữ liệu mới vào một bảng.<ul><li>Cú pháp cơ bản:
SQL<pre tabindex=0><code>INSERT INTO SinhVien (MaSV, HoTen, NgaySinh) VALUES (1, &#39;Nguyễn Văn A&#39;, &#39;2002-01-15&#39;);
</code></pre></li><li>Chèn dữ liệu từ bảng khác: Một kỹ thuật nâng cao và rất hữu ích là sử dụng <code>INSERT INTO... SELECT...</code> để sao chép và chèn dữ liệu từ một bảng khác vào bảng hiện tại.
SQL<pre tabindex=0><code>INSERT INTO SinhVienLuuTru (MaSV, HoTen)
SELECT MaSV, HoTen FROM SinhVien WHERE NgaySinh &lt; &#39;2000-01-01&#39;;
</code></pre></li></ul></li><li><code>UPDATE</code>: Dùng để cập nhật, sửa đổi các bản ghi hiện có trong bảng.
SQL<pre tabindex=0><code>UPDATE SinhVien SET Email = &#39;a.nguyen@example.com&#39; WHERE MaSV = 1;
</code></pre></li><li><code>DELETE</code>: Dùng để xóa một hoặc nhiều bản ghi khỏi bảng.
SQL<pre tabindex=0><code>DELETE FROM SinhVien WHERE MaSV = 1;
</code></pre></li></ul><h3 id=tầm-quan-trọng-sống-còn-của-mệnh-đề-where>Tầm quan trọng sống còn của mệnh đề WHERE<a hidden class=anchor aria-hidden=true href=#tầm-quan-trọng-sống-còn-của-mệnh-đề-where>#</a></h3><p>Một trong những sai lầm nguy hiểm và dễ mắc phải nhất đối với người mới làm việc với SQL là thực thi lệnh <code>UPDATE</code> hoặc <code>DELETE</code> mà quên mất mệnh đề <code>WHERE</code>. Nếu không có</p><p><code>WHERE</code> để chỉ định điều kiện, lệnh sẽ được áp dụng cho <strong>toàn bộ các hàng</strong> trong bảng, dẫn đến việc cập nhật hoặc xóa sạch dữ liệu một cách không mong muốn. Trong môi trường sản xuất, đây là một thảm họa có thể gây mất mát dữ liệu nghiêm trọng.</p><p>Vì vậy, một quy tắc vàng cần phải tuân thủ nghiêm ngặt là: <strong>Luôn luôn viết và kiểm tra câu lệnh <code>SELECT</code> với cùng mệnh đề <code>WHERE</code> trước khi thực thi <code>UPDATE</code> hoặc <code>DELETE</code></strong>.</p><ol><li>Viết câu lệnh <code>SELECT * FROM ten_bang WHERE dieu_kien;</code>.</li><li>Chạy câu lệnh <code>SELECT</code> và kiểm tra kết quả để đảm bảo rằng nó chỉ trả về đúng những hàng mà bạn muốn thay đổi.</li><li>Sau khi đã chắc chắn, thay thế <code>SELECT *</code> bằng <code>UPDATE ten_bang SET...</code> hoặc <code>DELETE</code>.</li></ol><p>Thực hành thói quen này sẽ giúp tránh được những sai lầm tốn kém và đảm bảo an toàn cho dữ liệu.</p><h2 id=phần-6-dql---trái-tim-của-sql-nghệ-thuật-truy-vấn-dữ-liệu>Phần 6: DQL - Trái Tim Của SQL, Nghệ Thuật Truy Vấn Dữ Liệu<a hidden class=anchor aria-hidden=true href=#phần-6-dql---trái-tim-của-sql-nghệ-thuật-truy-vấn-dữ-liệu>#</a></h2><p>Nếu DDL xây dựng cấu trúc và DML quản lý dữ liệu, thì DQL (với lệnh <code>SELECT</code>) chính là công cụ để khai thác giá trị từ dữ liệu đó. Đây là phần được sử dụng thường xuyên nhất trong công việc hàng ngày của một nhà phân tích.</p><h3 id=truy-vấn-cơ-bản>Truy vấn cơ bản<a hidden class=anchor aria-hidden=true href=#truy-vấn-cơ-bản>#</a></h3><ul><li><code>SELECT</code>: Chọn các cột mà bạn muốn hiển thị trong kết quả. Có thể sử dụng <code>*</code> để chọn tất cả các cột.</li><li><code>FROM</code>: Chỉ định bảng nguồn mà bạn muốn lấy dữ liệu từ đó.</li><li><code>DISTINCT</code>: Loại bỏ các hàng có giá trị trùng lặp hoàn toàn trong kết quả trả về.</li></ul><p>SQL</p><pre tabindex=0><code>SELECT DISTINCT ThanhPho FROM KhachHang; -- Lấy danh sách các thành phố duy nhất của khách hàng
</code></pre><h3 id=lọc-dữ-liệu-với-where>Lọc dữ liệu với WHERE<a hidden class=anchor aria-hidden=true href=#lọc-dữ-liệu-với-where>#</a></h3><p>Mệnh đề <code>WHERE</code> được dùng để lọc các hàng, chỉ giữ lại những hàng thỏa mãn một điều kiện nhất định.</p><ul><li><strong>Toán tử so sánh:</strong> <code>=</code>, <code>!=</code> (hoặc <code>&lt;></code>), <code>></code>, <code>&lt;</code>, <code>>=</code>, <code>&lt;=</code></li><li><strong>Toán tử logic:</strong> <code>AND</code>, <code>OR</code>, <code>NOT</code> để kết hợp nhiều điều kiện.</li><li><strong>Toán tử nâng cao:</strong><ul><li><code>IN</code>: Kiểm tra xem giá trị của một cột có nằm trong một danh sách các giá trị cho trước hay không.</li><li><code>BETWEEN</code>: Lọc các giá trị nằm trong một khoảng (bao gồm cả hai đầu mút).</li><li><code>LIKE</code>: Tìm kiếm dữ liệu văn bản theo một mẫu. Nó thường được kết hợp với các ký tự đại diện: <code>%</code> (đại diện cho không, một hoặc nhiều ký tự) và <code>_</code> (đại diện cho chính xác một ký tự).</li></ul></li></ul><p>SQL</p><pre tabindex=0><code>SELECT * FROM SanPham
WHERE Gia BETWEEN 100000 AND 500000
AND TenSanPham LIKE &#39;Áo sơ mi%&#39;;
</code></pre><h3 id=sắp-xếp-và-giới-hạn>Sắp xếp và Giới hạn<a hidden class=anchor aria-hidden=true href=#sắp-xếp-và-giới-hạn>#</a></h3><ul><li><code>ORDER BY</code>: Sắp xếp tập kết quả theo một hoặc nhiều cột. <code>ASC</code> (Ascending) là sắp xếp tăng dần (mặc định), và <code>DESC</code> (Descending) là giảm dần.</li><li><code>LIMIT</code> / <code>TOP</code>: Giới hạn số lượng hàng được trả về. Cú pháp có sự khác biệt giữa các RDBMS: MySQL và PostgreSQL sử dụng <code>LIMIT</code>, trong khi SQL Server sử dụng <code>TOP</code>.</li></ul><p>SQL</p><pre tabindex=0><code>-- Lấy 5 sản phẩm đắt nhất (MySQL/PostgreSQL)
SELECT TenSanPham, Gia
FROM SanPham
ORDER BY Gia DESC
LIMIT 5;

-- Lấy 5 sản phẩm đắt nhất (SQL Server)
SELECT TOP 5 TenSanPham, Gia
FROM SanPham
ORDER BY Gia DESC;
</code></pre><h3 id=các-hàm-tổng-hợp-aggregate-functions>Các hàm tổng hợp (Aggregate Functions)<a hidden class=anchor aria-hidden=true href=#các-hàm-tổng-hợp-aggregate-functions>#</a></h3><p>Các hàm này thực hiện một phép tính trên một tập hợp các hàng và trả về một giá trị duy nhất, tóm tắt cho tập hợp đó.</p><ul><li><code>COUNT()</code>: Đếm số lượng hàng.</li><li><code>SUM()</code>: Tính tổng các giá trị (chỉ áp dụng cho cột số).</li><li><code>AVG()</code>: Tính giá trị trung bình (chỉ áp dụng cho cột số).</li><li><code>MAX()</code>: Tìm giá trị lớn nhất.</li><li><code>MIN()</code>: Tìm giá trị nhỏ nhất.</li></ul><h3 id=gom-nhóm-dữ-liệu>Gom nhóm dữ liệu<a hidden class=anchor aria-hidden=true href=#gom-nhóm-dữ-liệu>#</a></h3><ul><li><code>GROUP BY</code>: Nhóm các hàng có cùng giá trị trong một hoặc nhiều cột lại với nhau thành các hàng tóm tắt. Lệnh này gần như luôn đi kèm với các hàm tổng hợp để thực hiện tính toán trên mỗi nhóm.</li><li><code>HAVING</code>: Được sử dụng sau <code>GROUP BY</code> để lọc các nhóm dựa trên một điều kiện. Điều kiện này thường áp dụng cho kết quả của một hàm tổng hợp.</li></ul><p>SQL</p><pre tabindex=0><code>SELECT ChuyenMuc, COUNT(*) AS SoLuongSanPham
FROM SanPham
GROUP BY ChuyenMuc
HAVING COUNT(*) &gt; 10; -- Chỉ hiển thị các chuyên mục có nhiều hơn 10 sản phẩm
</code></pre><h3 id=thứ-tự-thực-thi-logic-và-sự-khác-biệt-giữa-where-và-having>Thứ tự thực thi logic và sự khác biệt giữa WHERE và HAVING<a hidden class=anchor aria-hidden=true href=#thứ-tự-thực-thi-logic-và-sự-khác-biệt-giữa-where-và-having>#</a></h3><p>Một trong những điểm gây nhầm lẫn nhất cho người mới học SQL là sự khác biệt giữa <code>WHERE</code> và <code>HAVING</code>. Cả hai đều dùng để lọc, nhưng chúng hoạt động ở các giai đoạn khác nhau trong quá trình xử lý truy vấn của cơ sở dữ liệu. Mặc dù chúng ta viết câu lệnh theo thứ tự</p><p><code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code>, <code>ORDER BY</code>, hệ quản trị CSDL không thực thi theo thứ tự đó. Thứ tự xử lý logic thực tế là:</p><ol><li><code>FROM</code> và <code>JOIN</code>: Xác định và kết hợp các bảng nguồn.</li><li><code>WHERE</code>: Lọc các hàng riêng lẻ dựa trên các điều kiện.</li><li><code>GROUP BY</code>: Gom các hàng đã được lọc thành các nhóm.</li><li><code>HAVING</code>: Lọc các nhóm đã được tạo.</li><li><code>SELECT</code>: Chọn các cột cuối cùng và tính toán các biểu thức.</li><li><code>DISTINCT</code>: Loại bỏ các hàng trùng lặp.</li><li><code>ORDER BY</code>: Sắp xếp tập kết quả cuối cùng.</li><li><code>LIMIT</code> / <code>TOP</code>: Lấy ra một phần của kết quả đã sắp xếp.</li></ol><p>Từ thứ tự này, có thể rút ra kết luận:</p><ul><li><code>WHERE</code> được thực thi ở bước 2, <strong>trước khi</strong> dữ liệu được gom nhóm (bước 3). Do đó, <code>WHERE</code> chỉ có thể lọc dựa trên dữ liệu của từng hàng riêng lẻ và không thể sử dụng các hàm tổng hợp (như <code>SUM()</code>, <code>COUNT()</code>) vì chúng chưa được tính toán.</li><li><code>HAVING</code> được thực thi ở bước 4, <strong>sau khi</strong> dữ liệu đã được gom nhóm và các hàm tổng hợp đã được tính toán cho mỗi nhóm. Do đó, <code>HAVING</code> được thiết kế đặc biệt để lọc dựa trên kết quả của các hàm tổng hợp.</li></ul><p>Một cách dễ hình dung: <code>WHERE</code> là bộ lọc &ldquo;đầu vào&rdquo; cho các hàng, còn <code>HAVING</code> là bộ lọc &ldquo;đầu ra&rdquo; cho các nhóm.</p><h2 id=phần-7-sức-mạnh-kết-nối---làm-chủ-các-loại-join>Phần 7: Sức Mạnh Kết Nối - Làm Chủ Các Loại JOIN<a hidden class=anchor aria-hidden=true href=#phần-7-sức-mạnh-kết-nối---làm-chủ-các-loại-join>#</a></h2><p>Trong một cơ sở dữ liệu quan hệ được thiết kế tốt, dữ liệu thường được chia nhỏ ra nhiều bảng để tránh lặp lại và đảm bảo tính nhất quán. Lệnh <code>JOIN</code> chính là công cụ mạnh mẽ cho phép chúng ta kết hợp dữ liệu từ hai hoặc nhiều bảng này lại với nhau dựa trên các cột có liên quan (thường là cặp khóa chính - khóa ngoại).</p><h3 id=phân-tích-chi-tiết-từng-loại-join>Phân tích chi tiết từng loại JOIN<a hidden class=anchor aria-hidden=true href=#phân-tích-chi-tiết-từng-loại-join>#</a></h3><ul><li><code>INNER JOIN</code> (hoặc <code>JOIN</code>): Đây là loại <code>JOIN</code> phổ biến nhất. Nó trả về các bản ghi chỉ khi có giá trị khớp ở cả hai bảng tham gia. Về mặt lý thuyết tập hợp, đây chính là phép giao (intersection).</li><li><code>LEFT JOIN</code> (hoặc <code>LEFT OUTER JOIN</code>): Trả về <strong>tất cả</strong> các bản ghi từ bảng bên trái và các bản ghi khớp từ bảng bên phải. Nếu không có sự khớp nối, các cột tương ứng của bảng bên phải sẽ có giá trị <code>NULL</code>.</li><li><code>RIGHT JOIN</code> (hoặc <code>RIGHT OUTER JOIN</code>): Hoạt động ngược lại với <code>LEFT JOIN</code>. Nó trả về <strong>tất cả</strong> các bản ghi từ bảng bên phải và các bản ghi khớp từ bảng bên trái. Nếu không có sự khớp nối, các cột của bảng bên trái sẽ có giá trị <code>NULL</code>.</li><li><code>FULL OUTER JOIN</code>: Kết hợp kết quả của cả <code>LEFT JOIN</code> và <code>RIGHT JOIN</code>. Nó trả về tất cả các bản ghi khi có sự khớp ở một trong hai bảng. Nếu một hàng ở bảng này không có hàng khớp ở bảng kia, các cột của bảng kia sẽ là <code>NULL</code>. Đây là phép hợp (union) của hai tập hợp.</li><li><code>CROSS JOIN</code>: Trả về tích Descartes của hai bảng. Nó kết hợp mỗi hàng của bảng thứ nhất với tất cả các hàng của bảng thứ hai. Loại <code>JOIN</code> này có thể tạo ra một tập kết quả rất lớn và cần được sử dụng một cách cẩn trọng.</li><li><code>SELF JOIN</code>: Đây không phải là một loại <code>JOIN</code> riêng biệt mà là một kỹ thuật, trong đó một bảng được kết nối với chính nó. Kỹ thuật này rất hữu ích để truy vấn các dữ liệu có cấu trúc phân cấp, ví dụ như trong một bảng <code>NhanVien</code>, có cột <code>MaNguoiQuanLy</code> tham chiếu trở lại cột <code>MaNhanVien</code> trong cùng bảng đó.</li></ul><p><strong>Bảng so sánh các loại JOIN</strong></p><table><thead><tr><th>Loại JOIN</th><th>Kết Quả Trả Về</th><th>Kịch Bản Sử Dụng Điển Hình</th></tr></thead><tbody><tr><td><strong>INNER JOIN</strong></td><td>Chỉ các hàng có khóa khớp ở cả hai bảng.</td><td>Lấy danh sách khách hàng đã từng đặt hàng.</td></tr><tr><td><strong>LEFT JOIN</strong></td><td>Tất cả hàng từ bảng trái, và hàng khớp từ bảng phải.</td><td>Lấy danh sách tất cả khách hàng và đơn hàng của họ (kể cả những khách hàng chưa từng đặt hàng).</td></tr><tr><td><strong>RIGHT JOIN</strong></td><td>Tất cả hàng từ bảng phải, và hàng khớp từ bảng trái.</td><td>Lấy danh sách tất cả sản phẩm và thông tin người đã mua chúng (kể cả những sản phẩm chưa từng được bán).</td></tr><tr><td><strong>FULL OUTER JOIN</strong></td><td>Tất cả hàng từ cả hai bảng.</td><td>Lấy danh sách tất cả nhân viên và tất cả phòng ban, ghép nối thông tin nếu nhân viên thuộc phòng ban đó.</td></tr><tr><td><strong>CROSS JOIN</strong></td><td>Mọi tổ hợp hàng có thể có giữa hai bảng.</td><td>Tạo dữ liệu thử nghiệm, ví dụ: ghép mọi size áo với mọi màu sắc để tạo danh sách sản phẩm.</td></tr><tr><td><strong>SELF JOIN</strong></td><td>Bảng tự kết nối với chính nó.</td><td>Tìm tên của mỗi nhân viên và tên của người quản lý trực tiếp của họ trong cùng một bảng nhân sự.</td></tr></tbody></table><h2 id=phần-8-giao-dịch-và-bảo-mật---đảm-bảo-an-toàn-dữ-liệu>Phần 8: Giao Dịch và Bảo Mật - Đảm Bảo An Toàn Dữ Liệu<a hidden class=anchor aria-hidden=true href=#phần-8-giao-dịch-và-bảo-mật---đảm-bảo-an-toàn-dữ-liệu>#</a></h2><p>Việc thao tác với dữ liệu không chỉ dừng lại ở truy vấn mà còn phải đảm bảo tính toàn vẹn và bảo mật. Đây là lúc các lệnh TCL và DCL phát huy vai trò.</p><h3 id=tcl---transaction-control-language>TCL - Transaction Control Language<a hidden class=anchor aria-hidden=true href=#tcl---transaction-control-language>#</a></h3><p>Một <strong>giao dịch (transaction)</strong> là một chuỗi các thao tác SQL được thực hiện như một đơn vị công việc logic duy nhất. Nguyên tắc của giao dịch là &ldquo;hoặc tất cả thành công, hoặc tất cả thất bại&rdquo;. Ví dụ kinh điển là giao dịch chuyển tiền: việc trừ tiền từ tài khoản A và cộng tiền vào tài khoản B phải cùng xảy ra, nếu một trong hai bước thất bại, toàn bộ giao dịch phải được hủy bỏ.</p><p>Độ tin cậy của giao dịch được đảm bảo bởi bốn thuộc tính, gọi là <strong>ACID</strong>:</p><ul><li><strong>Atomicity (Tính nguyên tử):</strong> Giao dịch là không thể chia nhỏ.</li><li><strong>Consistency (Tính nhất quán):</strong> Giao dịch đưa cơ sở dữ liệu từ một trạng thái hợp lệ này sang một trạng thái hợp lệ khác.</li><li><strong>Isolation (Tính cô lập):</strong> Các giao dịch đồng thời không ảnh hưởng lẫn nhau.</li><li><strong>Durability (Tính bền vững):</strong> Một khi giao dịch đã được xác nhận thành công, các thay đổi của nó sẽ tồn tại vĩnh viễn, ngay cả khi hệ thống gặp sự cố. 20</li></ul><p>Các lệnh TCL chính bao gồm:</p><ul><li><code>COMMIT</code>: Lưu vĩnh viễn các thay đổi của giao dịch hiện tại vào cơ sở dữ liệu.</li><li><code>ROLLBACK</code>: Hủy bỏ tất cả các thay đổi đã được thực hiện trong giao dịch hiện tại, đưa cơ sở dữ liệu trở về trạng thái trước khi giao dịch bắt đầu.</li><li><code>SAVEPOINT</code>: Đặt một điểm lưu tạm thời bên trong một giao dịch. Điều này cho phép <code>ROLLBACK</code> về một điểm cụ thể mà không cần phải hủy bỏ toàn bộ giao dịch.</li></ul><h3 id=dcl---data-control-language>DCL - Data Control Language<a hidden class=anchor aria-hidden=true href=#dcl---data-control-language>#</a></h3><p>DCL là nhóm lệnh dùng để quản lý quyền truy cập của người dùng đối với các đối tượng trong cơ sở dữ liệu, đảm bảo rằng chỉ những người được ủy quyền mới có thể thực hiện các hành động nhất định.</p><ul><li><code>GRANT</code>: Cấp quyền cho một người dùng hoặc một nhóm người dùng. Ví dụ: cấp quyền <code>SELECT</code>, <code>INSERT</code> trên một bảng cụ thể.</li><li><code>REVOKE</code>: Thu hồi lại các quyền đã được cấp trước đó.</li></ul><p>SQL</p><pre tabindex=0><code>-- Cấp quyền SELECT trên bảng SanPham cho người dùng &#39;analyst&#39;
GRANT SELECT ON SanPham TO analyst;

-- Thu hồi quyền INSERT trên bảng SanPham từ người dùng &#39;analyst&#39;
REVOKE INSERT ON SanPham FROM analyst;
</code></pre><p>Việc cấp quyền trực tiếp trên các bảng dữ liệu gốc đôi khi có thể làm lộ thông tin nhạy cảm (ví dụ: cột <code>Luong</code> trong bảng <code>NhanVien</code>). Để giải quyết vấn đề này, DCL thường được sử dụng kết hợp với các đối tượng cơ sở dữ liệu khác như <code>View</code> và <code>Stored Procedure</code> để tạo ra một cơ chế bảo mật đa lớp và linh hoạt hơn. Thay vì cấp quyền <code>SELECT</code> trực tiếp trên bảng <code>NhanVien</code>, quản trị viên có thể tạo một <code>View</code> không chứa cột <code>Luong</code> và chỉ cấp quyền <code>SELECT</code> trên <code>View</code> đó cho người dùng. Tương tự, thay vì cấp quyền</p><p><code>UPDATE</code> trên bảng, quản trị viên có thể tạo một <code>Stored Procedure</code> để thực hiện một hành động cụ thể (như tăng lương) và chỉ cấp quyền thực thi (<code>EXECUTE</code>) thủ tục đó. Cách tiếp cận này che giấu cấu trúc dữ liệu phức tạp và giới hạn các hành động mà người dùng có thể thực hiện, tăng cường đáng kể tính bảo mật.</p><h2 id=phần-9-tối-ưu-hóa-và-các-đối-tượng-nâng-cao>Phần 9: Tối Ưu Hóa và Các Đối Tượng Nâng Cao<a hidden class=anchor aria-hidden=true href=#phần-9-tối-ưu-hóa-và-các-đối-tượng-nâng-cao>#</a></h2><p>Để làm việc hiệu quả với các hệ thống cơ sở dữ liệu lớn, việc hiểu và sử dụng các đối tượng nâng cao để tối ưu hóa hiệu suất là vô cùng cần thiết.</p><h3 id=index-chỉ-mục>Index (Chỉ mục)<a hidden class=anchor aria-hidden=true href=#index-chỉ-mục>#</a></h3><ul><li><strong>Khái niệm:</strong> Một chỉ mục (Index) là một cấu trúc dữ liệu đặc biệt được sử dụng để tăng tốc độ truy xuất dữ liệu từ một bảng. Nó hoạt động tương tự như mục lục ở cuối một cuốn sách. Thay vì phải lật từng trang (quét toàn bộ bảng - table scan) để tìm thông tin, cơ sở dữ liệu có thể sử dụng chỉ mục để đi thẳng đến vị trí của dữ liệu cần tìm.</li><li><strong>Lợi ích và Đánh đổi:</strong> Lợi ích chính của chỉ mục là tăng tốc đáng kể các truy vấn <code>SELECT</code> có mệnh đề <code>WHERE</code> hoặc các phép <code>JOIN</code>. Tuy nhiên, nó cũng có một cái giá phải trả: các thao tác ghi dữ liệu (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) sẽ trở nên chậm hơn, vì ngoài việc thay đổi dữ liệu trong bảng, cơ sở dữ liệu còn phải cập nhật cả cấu trúc của chỉ mục. Do đó, cần cân nhắc kỹ lưỡng việc tạo chỉ mục trên các bảng có tần suất ghi dữ liệu cao.</li><li><strong>Cú pháp:</strong>
SQL<pre tabindex=0><code>CREATE INDEX idx_TenSanPham ON SanPham (TenSanPham);
</code></pre></li></ul><h3 id=view-khung-nhìn>View (Khung nhìn)<a hidden class=anchor aria-hidden=true href=#view-khung-nhìn>#</a></h3><ul><li><strong>Khái niệm:</strong> Một View là một &ldquo;bảng ảo&rdquo; (virtual table), được định nghĩa bởi một câu lệnh <code>SELECT</code>. View không lưu trữ dữ liệu của riêng nó mà chỉ đơn giản là một &ldquo;cửa sổ&rdquo; để nhìn vào dữ liệu từ một hoặc nhiều bảng cơ sở. Mọi thao tác trên View thực chất sẽ được phản ánh xuống các bảng gốc.</li><li><strong>Lợi ích:</strong><ul><li><strong>Đơn giản hóa truy vấn phức tạp:</strong> Một câu lệnh <code>JOIN</code> phức tạp qua nhiều bảng có thể được gói gọn trong một View. Sau đó, người dùng chỉ cần thực hiện một câu lệnh <code>SELECT</code> đơn giản từ View đó.</li><li><strong>Tăng cường bảo mật:</strong> Cho phép giới hạn quyền truy cập của người dùng. Họ chỉ có thể xem và tương tác với dữ liệu thông qua View (ví dụ: một View không chứa các cột nhạy cảm như lương hoặc thông tin cá nhân).</li><li><strong>Tính nhất quán:</strong> Đảm bảo rằng nhiều ứng dụng và người dùng khác nhau cùng truy cập vào một logic dữ liệu nhất quán được định nghĩa sẵn trong View.</li></ul></li><li><strong>Cú pháp:</strong>
SQL<pre tabindex=0><code>CREATE VIEW v_SanPhamGiaCao AS
SELECT TenSanPham, Gia, ChuyenMuc
FROM SanPham
WHERE Gia &gt; 1000000;
</code></pre></li></ul><h3 id=stored-procedure-thủ-tục-lưu-trữ>Stored Procedure (Thủ tục lưu trữ)<a hidden class=anchor aria-hidden=true href=#stored-procedure-thủ-tục-lưu-trữ>#</a></h3><ul><li><strong>Khái niệm:</strong> Một Stored Procedure (thường gọi tắt là SP) là một nhóm các câu lệnh SQL đã được biên dịch trước và được lưu trữ ngay trong cơ sở dữ liệu. Nó có thể nhận các tham số đầu vào, thực hiện một chuỗi logic phức tạp và trả về kết quả.</li><li><strong>Lợi ích:</strong><ul><li><strong>Tái sử dụng mã:</strong> Viết một lần, gọi nhiều lần từ các ứng dụng khác nhau mà không cần lặp lại mã.</li><li><strong>Tăng hiệu suất:</strong> Vì các SP đã được biên dịch và tối ưu hóa sẵn, việc thực thi chúng thường nhanh hơn so với việc gửi các câu lệnh SQL riêng lẻ từ ứng dụng qua mạng.</li><li><strong>Giảm lưu lượng mạng:</strong> Thay vì gửi một khối mã SQL dài, ứng dụng chỉ cần gửi một lệnh gọi SP ngắn gọn.</li><li><strong>Tăng cường bảo mật:</strong> Tương tự như View, có thể cấp cho người dùng quyền thực thi một SP mà không cần cấp quyền trực tiếp trên các bảng cơ sở. Điều này giúp kiểm soát chặt chẽ các hành động và là một biện pháp hiệu quả để chống lại các cuộc tấn công SQL Injection.</li></ul></li><li><strong>Cú pháp (ví dụ trong SQL Server):</strong>
SQL<pre tabindex=0><code>CREATE PROCEDURE sp_TimSanPhamTheoGia
    @GiaToiThieu DECIMAL(10, 2)
AS
BEGIN
    SELECT TenSanPham, Gia FROM SanPham WHERE Gia &gt;= @GiaToiThieu;
END;
</code></pre></li></ul><h2 id=phần-10-tổng-kết-và-lộ-trình-học-tập-tiếp-theo>Phần 10: Tổng Kết và Lộ Trình Học Tập Tiếp Theo<a hidden class=anchor aria-hidden=true href=#phần-10-tổng-kết-và-lộ-trình-học-tập-tiếp-theo>#</a></h2><p>Qua các phần trên, chúng ta đã cùng nhau xây dựng một nền tảng vững chắc về SQL, từ việc hiểu các khái niệm cơ bản về cơ sở dữ liệu quan hệ, phân loại và nắm vững cú pháp của 5 họ lệnh chính (DDL, DML, DQL, DCL, TCL), cho đến việc làm chủ các kỹ thuật mạnh mẽ như <code>JOIN</code>, <code>GROUP BY</code> và các đối tượng nâng cao như <code>Index</code>, <code>View</code>, <code>Stored Procedure</code>.</p><p>Tuy nhiên, SQL là một kỹ năng cần được mài giũa qua thực hành liên tục. Kiến thức lý thuyết là quan trọng, nhưng việc áp dụng chúng để giải quyết các bài toán dữ liệu thực tế mới thực sự giúp bạn trở thành một chuyên gia. Các nền tảng như LeetCode, HackerRank hay các bộ dữ liệu công khai là những nguồn tài nguyên tuyệt vời để luyện tập.</p><p>Sau khi đã nắm vững các kiến thức trong cẩm nang này, đây là một vài gợi ý cho lộ trình học tập tiếp theo của bạn:</p><ul><li><strong>Hàm cửa sổ (Window Functions):</strong> Đây là một bước tiến lớn trong phân tích dữ liệu. Các hàm như <code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code>, <code>LEAD()</code>, <code>LAG()</code> cho phép thực hiện các phép tính phức tạp trên một &ldquo;cửa sổ&rdquo; các hàng liên quan mà không làm thay đổi kết quả của truy vấn chính.</li><li><strong>Tối ưu hóa truy vấn (Query Optimization):</strong> Học cách đọc và hiểu kế hoạch thực thi (Execution Plan) của một câu lệnh SQL để xác định các điểm nghẽn về hiệu suất và tìm cách cải thiện chúng.</li><li><strong>Chuyên sâu về một RDBMS cụ thể:</strong> Mỗi hệ quản trị cơ sở dữ liệu như PostgreSQL, SQL Server, hay MySQL đều có những tính năng và cú pháp đặc thù. Việc tìm hiểu sâu về một hệ thống sẽ mở ra nhiều khả năng mạnh mẽ hơn.</li></ul><p>Hành trình làm chủ SQL là một cuộc marathon, không phải là một cuộc chạy nước rút. Hy vọng rằng cuốn cẩm nang này sẽ là người bạn đồng hành đáng tin cậy trên chặng đường chinh phục thế giới dữ liệu của bạn.</p><hr><p><em>Nếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nagih.io.vn/tags/sql/>Sql</a></li></ul><nav class=paginav><a class=prev href=https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/><span class=title>« Prev</span><br><span>Docker Overview</span>
</a><a class=next href=https://blog.nagih.io.vn/posts/system/cache/><span class=title>Next »</span><br><span>Cache</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on x" href="https://x.com/intent/tweet/?text=SQL%20Overview&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f&amp;hashtags=sql"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f&amp;title=SQL%20Overview&amp;summary=SQL%20Overview&amp;source=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f&title=SQL%20Overview"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on whatsapp" href="https://api.whatsapp.com/send?text=SQL%20Overview%20-%20https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on telegram" href="https://telegram.me/share/url?text=SQL%20Overview&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SQL Overview on ycombinator" href="https://news.ycombinator.com/submitlink?t=SQL%20Overview&u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdatabase%2fsql%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nagih.io.vn/>Nagih | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>