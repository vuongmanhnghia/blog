<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Labs Operating | Nagih | Blog</title>
<meta name=keywords content="lab"><meta name=description content="1 Số Labs từ Cơ bản tới Nâng cao về Operating"><meta name=author content="Nagih"><link rel=canonical href=https://blog.nagih.io.vn/posts/labs-operating/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://blog.nagih.io.vn/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.nagih.io.vn/posts/labs-operating/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.nagih.io.vn/posts/labs-operating/"><meta property="og:site_name" content="Nagih | Blog"><meta property="og:title" content="Labs Operating"><meta property="og:description" content="1 Số Labs từ Cơ bản tới Nâng cao về Operating"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-23T00:00:00+00:00"><meta property="article:tag" content="Lab"><meta property="og:image" content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Labs Operating"><meta name=twitter:description content="1 Số Labs từ Cơ bản tới Nâng cao về Operating"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nagih.io.vn/posts/"},{"@type":"ListItem","position":2,"name":"Labs Operating","item":"https://blog.nagih.io.vn/posts/labs-operating/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Labs Operating","name":"Labs Operating","description":"1 Số Labs từ Cơ bản tới Nâng cao về Operating\n","keywords":["lab"],"articleBody":"1 Số Labs từ Cơ bản tới Nâng cao về Operating\nTại sao Hệ Điều Hành Vẫn Quan Trọng trong Thế Giới Cloud-Native Trong lĩnh vực DevOps hiện đại, tồn tại một nghịch lý: trong khi các công cụ cấp cao như Kubernetes, Docker và Ansible trừu tượng hóa hệ điều hành bên dưới, việc hiểu sâu về Linux lại trở nên quan trọng hơn bao giờ hết. Hầu hết các công cụ DevOps cốt lõi đều được xây dựng để chạy tốt nhất trên Linux, biến nó thành nền tảng phổ biến cho cơ sở hạ tầng đám mây và tự động hóa.\nHướng dẫn này được thiết kế để nâng tầm kỹ sư từ một người dùng đơn thuần các công cụ này trở thành một kiến trúc sư hiểu rõ hoạt động bên trong của chúng. Hệ điều hành Linux không nên được xem như một hệ thống cũ kỹ, mà là “API” nền tảng, phổ quát cho mọi hoạt động tự động hóa cơ sở hạ tầng. Tám bài lab dưới đây được cấu trúc như một hành trình có phương pháp, phản ánh quy trình xử lý sự cố trong thực tế, bắt đầu từ các kiểm tra hệ thống cơ bản, đi sâu dần vào phân tích hiệu năng, gỡ lỗi nâng cao và cuối cùng là các nguyên tắc cốt lõi của container hóa. Đây không chỉ là một bộ sưu tập các lệnh; nó là một mô hình tư duy về hệ thống.\nLab 1: Điều Hướng và Quản Lý Hệ Thống Tệp Mục tiêu: Xây dựng “trí nhớ cơ bắp” để điều hướng hệ thống tệp Linux và thực hiện các thao tác tệp thiết yếu. Đây là nền tảng để tìm kiếm log, quản lý tệp cấu hình và chuẩn bị các tạo phẩm ứng dụng cho việc triển khai.\nCác Khái Niệm Cốt Lõi Triết lý “Mọi thứ đều là tệp”: Trong Linux, một nguyên tắc cốt lõi là mọi thứ, từ thiết bị phần cứng, socket mạng đến các thư mục, đều được biểu diễn dưới dạng tệp. Điều này cung cấp một giao diện thống nhất để tương tác với toàn bộ hệ thống. Tiêu chuẩn Phân cấp Hệ thống tệp (FHS): Cấu trúc thư mục trong Linux tuân theo một tiêu chuẩn, mang lại sự dễ đoán trong quản trị hệ thống. Các thư mục chính bao gồm /etc cho các tệp cấu hình, /var/log cho các tệp nhật ký, /home cho thư mục người dùng và /usr cho các tiện ích và ứng dụng hệ thống. Thực Hành (Từng bước) Bước 1: Xác định vị trí: Sử dụng lệnh pwd để in ra thư mục làm việc hiện tại và whoami để xác định người dùng hiện tại. Bước 2: Khám phá xung quanh: Sử dụng ls với các cờ phổ biến (-l, -a, -h) để liệt kê nội dung thư mục và hiểu định dạng đầu ra (quyền, chủ sở hữu, kích thước, ngày). Bước 3: Di chuyển: Thực hành điều hướng bằng cd, sử dụng cả đường dẫn tuyệt đối (ví dụ: cd /var/log) và tương đối (ví dụ: cd../..). Bước 4: Tạo và Xóa: Sử dụng touch để tạo các tệp trống, mkdir để tạo thư mục (và -p để tạo các thư mục cha), và rm để xóa tệp và thư mục (-r để xóa đệ quy). Bước 5: Thao tác với tệp: Sử dụng cp để sao chép, mv để di chuyển/đổi tên, và cat để hiển thị nội dung tệp. Lệnh Trường Hợp Sử Dụng Phổ Biến ls Liệt kê nội dung của một thư mục. cd Thay đổi thư mục làm việc hiện tại. pwd In ra đường dẫn đầy đủ của thư mục hiện tại. mkdir Tạo một thư mục mới. rm Xóa tệp hoặc thư mục. cp Sao chép tệp hoặc thư mục. mv Di chuyển hoặc đổi tên tệp hoặc thư mục. touch Tạo một tệp trống hoặc cập nhật dấu thời gian của tệp. cat Hiển thị nội dung của một tệp. head / tail Hiển thị phần đầu hoặc phần cuối của một tệp. Lab 2: Quản Lý Người Dùng, Nhóm và Quyền Truy Cập Mục tiêu: Bảo mật tài nguyên hệ thống bằng cách làm chủ quyền sở hữu tệp và các danh sách kiểm soát truy cập. Kỹ năng này có thể áp dụng trực tiếp vào việc bảo mật môi trường tác tử CI/CD, thiết lập quyền cho các tạo phẩm triển khai và cấu hình quyền truy cập của người dùng trên máy chủ.\nCác Khái Niệm Cốt Lõi Bộ ba Bảo mật: Mô hình quyền trong Linux dựa trên ba thực thể: user (người dùng, chủ sở hữu), group (nhóm), và other (những người khác). Giải mã Quyền: Mỗi thực thể có thể được cấp ba loại quyền cơ bản: read (r) (đọc), write (w) (ghi), và execute (x) (thực thi). Ý nghĩa của các quyền này khác nhau giữa tệp và thư mục. Ví dụ, quyền execute trên một thư mục cho phép người dùng cd vào thư mục đó, trong khi trên một tệp, nó cho phép chạy tệp đó như một chương trình. Thực Hành (Từng bước) Bước 1: Quản trị Người dùng và Nhóm: Tạo một người dùng mới với useradd, đặt mật khẩu với passwd, và tạo một nhóm mới với groupadd. Thêm người dùng vào nhóm vừa tạo.\nBước 2: Thay đổi Quyền sở hữu: Sử dụng chown để thay đổi chủ sở hữu của một tệp và chgrp (hoặc chown user:group) để thay đổi nhóm sở hữu. Luôn sử dụng\nsudo cho các hoạt động này khi cần thiết.\nBước 3: Sửa đổi Quyền bằng Ký hiệu Tượng trưng: Sử dụng chmod với ký hiệu tượng trưng (u+x, g-w, o=r) để thay đổi quyền một cách chi tiết và dễ đọc.\nBước 4: Sửa đổi Quyền bằng Ký hiệu Bát phân (Số): Giới thiệu các giá trị số (r=4, w=2, x=1) và trình bày cách thiết lập các quyền phổ biến như chmod 755 cho các tập lệnh và chmod 644 cho các tệp web.\nGiá trị Bát phân Ký hiệu Tượng trưng Trường Hợp Sử Dụng Phổ Biến 777 rwxrwxrwx Không an toàn, chỉ dùng cho mục đích tạm thời hoặc trong môi trường được kiểm soát chặt chẽ. 755 rwxr-xr-x Các tập lệnh thực thi, các thư mục cần người khác truy cập. 644 rw-r--r-- Các tệp nội dung web, tệp cấu hình chỉ đọc cho người khác. 600 rw------- Các tệp nhạy cảm như khóa riêng SSH, chỉ chủ sở hữu mới có thể đọc/ghi. Lab 3: Quản Lý Tiến Trình và Giám Sát Thời Gian Thực Mục tiêu: Học cách xem những gì đang chạy trên hệ thống, diễn giải việc sử dụng tài nguyên và quản lý các tiến trình hoạt động sai. Đây là tuyến phòng thủ đầu tiên khi khắc phục sự cố một ứng dụng chạy chậm hoặc không phản hồi, ngay cả bên trong một container.\nCác Khái Niệm Cốt Lõi Vòng đời Tiến trình: Một tiến trình là một thực thể của một chương trình đang chạy. Mỗi tiến trình có một Mã định danh Tiến trình (PID) duy nhất và có thể ở các trạng thái khác nhau như đang chạy (running), đang ngủ (sleeping), hoặc zombie (xác sống). Thực Hành (Từng bước) Bước 1: Liệt kê Tiến trình Tĩnh: Sử dụng ps aux để có một ảnh chụp nhanh chi tiết về tất cả các tiến trình đang chạy. Phân tích các cột chính: USER, PID, %CPU, %MEM, COMMAND. Bước 2: Giám sát Thời gian thực với top: Khởi chạy top và giải thích khu vực tóm tắt (tải trung bình, tác vụ, trạng thái CPU, bộ nhớ) và danh sách tiến trình tương tác. Trình bày cách sắp xếp theo bộ nhớ (M) và CPU (P). Bước 3: Giám sát Nâng cao với htop: Giới thiệu htop như một giải pháp thay thế thân thiện và tương tác hơn cho top. Hướng dẫn người dùng qua các tính năng chính của nó: hiển thị mã màu, cuộn dễ dàng, chế độ xem cây (F5), tìm kiếm (F3), và sắp xếp (F6). Bước 4: Chấm dứt Tiến trình: Sử dụng lệnh kill với PID để gửi tín hiệu. Giải thích sự khác biệt giữa SIGTERM (chấm dứt nhẹ nhàng, kill ) và SIGKILL (chấm dứt cưỡng bức, kill -9 ). Trình bày cách chấm dứt một tiến trình trực tiếp từ htop (F9). Các kỹ năng trong bài lab này không chỉ dành cho các máy chủ truyền thống; chúng là những công cụ chính để gỡ lỗi bên trong một container đang chạy. Khi một container sử dụng quá nhiều CPU hoặc bộ nhớ, quy trình chẩn đoán tiêu chuẩn là docker exec -it bash theo sau là htop hoặc ps aux. Kubernetes hoặc Docker có thể cho biết rằng một container không khỏe mạnh, nhưng để tìm ra lý do tại sao, cần phải kiểm tra không gian tiến trình bị cô lập bên trong nó bằng chính các công cụ đã học.\nLab 4: Phân Tích Hiệu Năng Bộ Nhớ và I/O Đĩa Mục tiêu: Vượt ra ngoài việc giám sát CPU để chẩn đoán hai trong số những nút thắt hiệu năng phổ biến nhất: áp lực bộ nhớ và I/O đĩa chậm.\nCác Khái Niệm Cốt Lõi Mô hình Bộ nhớ Linux: Giải thích sự khác biệt giữa bộ nhớ used (đã sử dụng) và available (khả dụng), nhấn mạnh vai trò của buff/cache. Giải mã lý do tại sao “bộ nhớ trống thấp” thường là bình thường trong Linux. Giới thiệu về Bộ nhớ ảo, Hoán đổi (Swapping) và nguy cơ của Trình tiêu diệt Hết bộ nhớ (OOM Killer). Các Chỉ số I/O Đĩa: Xác định các chỉ số hiệu năng chính (KPI): IOPS (số thao tác mỗi giây), Thông lượng (MB/s), và Độ trễ/await (thời gian cho mỗi thao tác). Thực Hành (Từng bước) Bước 1: Phân tích Sử dụng Bộ nhớ: Sử dụng free -h để có cái nhìn tổng quan dễ đọc về việc sử dụng RAM và swap. Giải thích từng cột (total, used, free, buff/cache, available). Bước 2: Giám sát I/O Đĩa với iostat: Chạy iostat -x 1 để có cái nhìn thời gian thực, mở rộng về các thống kê đĩa. Tập trung vào việc diễn giải các cột quan trọng nhất: r/s, w/s (IOPS), rMB/s, wMB/s (Thông lượng), await (Độ trễ), và %util (Độ bão hòa). Bước 3: Xác định các Tiến trình Gây Tải I/O nặng với iotop: Sử dụng sudo iotop để xem một giao diện giống top của các tiến trình được xếp hạng theo I/O đĩa hiện tại của chúng. Điều này trả lời trực tiếp câu hỏi, “Tiến trình nào đang làm quá tải đĩa?”. Các chỉ số thu thập được trong bài lab này không phải là những con số tùy ý; chúng là dữ liệu thô cung cấp cho các khuôn khổ độ tin cậy cấp cao hơn như “Bốn Tín hiệu Vàng” của SRE của Google (Độ trễ, Lưu lượng, Lỗi, Độ bão hòa). Việc học cách đo lường chúng tại nguồn là một bước tiến từ quản trị hệ thống đơn thuần sang kỹ thuật đảm bảo độ tin cậy. Ví dụ, cột\nawait trong iostat là một thước đo trực tiếp về Độ trễ I/O đĩa. Các cột IOPS và thông lượng là thước đo trực tiếp về Lưu lượng đĩa. Cột %util trong iostat và %iowait từ top là các chỉ số trực tiếp về Độ bão hòa của đĩa và CPU. Bằng cách hiểu mối liên hệ này, ta có thể chẩn đoán các vấn đề hiệu năng với một tư duy chiến lược, tập trung vào các chỉ số thực sự quan trọng đối với sức khỏe của dịch vụ.\nLab 5: Các Lệnh Mạng và Xử Lý Sự Cố Thiết Yếu Mục tiêu: Xây dựng một bộ công cụ mạnh mẽ để chẩn đoán các vấn đề mạng, từ kiểm tra kết nối cơ bản đến kiểm tra các kết nối đang hoạt động và các vấn đề DNS—một công việc hàng ngày trong môi trường microservices.\nCác Khái Niệm Cốt Lõi Các khái niệm cơ bản về mạng bao gồm giao diện mạng, địa chỉ IP, cổng và socket, là những thành phần nền tảng cho mọi giao tiếp trên mạng.\nThực Hành (Từng bước) Bước 1: Kiểm tra Cấu hình Cục bộ: Sử dụng ip addr (thay thế hiện đại cho ifconfig) để xem các giao diện mạng và địa chỉ IP của chúng. Bước 2: Kiểm tra Kết nối Cơ bản: Sử dụng ping để kiểm tra khả năng tiếp cận và độ trễ, và traceroute để vạch ra đường đi của gói tin mạng đến một đích. Bước 3: Xử lý Sự cố DNS: Sử dụng dig và host để truy vấn các bản ghi DNS (A, CNAME, MX) và thực hiện tra cứu ngược. Điều này rất quan trọng để gỡ lỗi các vấn đề phát hiện dịch vụ (service discovery). Bước 4: Kiểm tra các Kết nối Đang hoạt động: Giới thiệu ss là công cụ thay thế hiện đại, nhanh hơn cho netstat. Sử dụng ss -tulpn để tìm các cổng đang lắng nghe và các tiến trình sử dụng chúng. Đây là chìa khóa để trả lời “Ứng dụng của tôi có đang lắng nghe trên đúng cổng không?” và “Cái gì đang kết nối với dịch vụ của tôi?”. Bước 5: Tương tác với Dịch vụ Web: Sử dụng curl để thực hiện các yêu cầu HTTP, xem các tiêu đề phản hồi (-I), và nhận chi tiết kết nối đầy đủ (-v), rất cần thiết để kiểm tra API và máy chủ web. Lệnh netstat Cũ Lệnh ss Hiện Đại Mục Đích netstat -tulpn ss -tulpn Liệt kê tất cả các cổng TCP/UDP đang lắng nghe và các tiến trình liên quan. netstat -tan ss -tan Hiển thị tất cả các kết nối TCP (cả đang lắng nghe và đã thiết lập). netstat -tun ss -tun Hiển thị tất cả các kết nối TCP và UDP. Lab 6: Thám Tử - Xử Lý Sự Cố Nâng Cao với strace Mục tiêu: Học cách sử dụng strace như công cụ gỡ lỗi tối thượng để xem chính xác một ứng dụng đang làm gì ở cấp độ lời gọi hệ thống, khi mà log và giám sát không đủ thông tin.\nCác Khái Niệm Cốt Lõi Ranh giới Kernel-Userspace: Lời gọi hệ thống (syscalls) là giao diện mà qua đó các ứng dụng yêu cầu dịch vụ từ nhân Linux (ví dụ: mở một tệp, gửi dữ liệu mạng). strace chặn và giải mã các lời gọi này, cung cấp một cái nhìn không bị che giấu về hoạt động của chương trình. Thực Hành (Từng bước) Bước 1: Truy vết Cơ bản: Chạy một lệnh đơn giản dưới strace (ví dụ: strace ls) để xem luồng đầu ra và hiểu định dạng của nó. Bước 2: Gắn vào một Tiến trình Đang chạy: Tìm PID của một tiến trình đang chạy (sử dụng ps hoặc htop từ Lab 3) và gắn vào nó với strace -p . Bước 3: Lọc Nhiễu: Sức mạnh thực sự của strace nằm ở khả năng lọc. Trình bày cách truy vết các syscall cụ thể với -e: Sự cố Truy cập Tệp: Sử dụng strace -e trace=file để gỡ lỗi các lỗi “Permission denied” hoặc “No such file or directory” bằng cách xem chính xác đường dẫn tệp nào đang bị lỗi. Sự cố Mạng: Sử dụng strace -e trace=network để xem các lời gọi connect, sendto, recvfrom, giúp gỡ lỗi các kết nối mạng chậm hoặc thất bại. Bước 4: Phân tích Hiệu năng: Giới thiệu cờ -T để hiển thị thời gian đã dành cho mỗi syscall, giúp xác định các nút thắt hiệu năng nơi ứng dụng đang chờ một thao tác I/O chậm. Log ứng dụng, các chỉ số và tài liệu mô tả những gì một chương trình nên làm. strace tiết lộ những gì nó thực sự đang làm. Nó là nguồn sự thật tối thượng để gỡ lỗi, bỏ qua tất cả các lớp trừu tượng ở cấp độ ứng dụng. Khi các công cụ khác cung cấp thông tin sai lệch hoặc im lặng, strace cung cấp một bản ghi khách quan, không bị lọc về ý định của chương trình, biến nó thành một kỹ năng quan trọng để giải quyết những lỗi “không thể”.\nLab 7: Các Thành Phần Xây Dựng Container: Namespaces Mục tiêu: Giải mã công nghệ container bằng cách trình bày thực tế cách các namespace của Linux tạo ra môi trường bị cô lập cho các tiến trình, mạng và hệ thống tệp.\nCác Khái Niệm Cốt Lõi Namespaces là gì? Namespaces là một tính năng của nhân Linux giúp phân vùng các tài nguyên hệ thống toàn cục sao cho một tiến trình bên trong một namespace nghĩ rằng nó có một phiên bản riêng của tài nguyên đó (ví dụ: cây tiến trình riêng, ngăn xếp mạng riêng). Đây là cốt lõi của sự cô lập container. Các loại Namespaces: Các loại namespace chính bao gồm PID (Process ID), Net (Network), MNT (Mount), UTS (Hostname), và User. Bài lab này sẽ tập trung vào namespace Mạng (net) như một ví dụ trực quan nhất. Thực Hành (Từng bước) Bước 1: Tạo Network Namespaces: Sử dụng ip netns add để tạo hai namespace mạng riêng biệt (ví dụ: ns1, ns2). Bước 2: Xác minh Sự cô lập: Chạy ip netns exec ip addr để cho thấy mỗi namespace chỉ có giao diện lo riêng của nó và đang ở trạng thái DOWN. Bước 3: Tạo một “Cáp Mạng Ảo”: Sử dụng ip link add veth-ns1 type veth peer name veth-ns2 để tạo một cặp ethernet ảo (một “dây cáp mạng” ảo). Bước 4: Kết nối các Namespaces: “Cắm” mỗi đầu của cáp ảo vào một namespace bằng cách sử dụng ip link set netns . Bước 5: Cấu hình Mạng bị cô lập: Bên trong mỗi namespace, gán một địa chỉ IP cho giao diện veth (ip netns exec ip addr add...) và bật giao diện lên (ip netns exec ip link set... up). Bước 6: Kiểm tra Giao tiếp: Sử dụng ip netns exec ns1 ping để cho thấy hai môi trường bị cô lập giờ đây có thể giao tiếp với nhau qua mạng riêng của chúng, nhưng vẫn vô hình đối với máy chủ chủ (host). Lab 8: Người Quản Lý - Quản Lý Tài Nguyên với Control Groups (cgroups) Mục tiêu: Bổ sung cho sự cô lập từ Lab 7, bài lab này trình bày cách sử dụng cgroups để giới hạn tài nguyên (CPU, bộ nhớ) mà một tiến trình có thể tiêu thụ, hoàn thiện bức tranh về container hóa.\nCác Khái Niệm Cốt Lõi cgroups là gì? cgroups (control groups) là một tính năng của nhân Linux để giới hạn, tính toán và ưu tiên việc sử dụng tài nguyên cho một tập hợp các tiến trình. Trong khi namespaces cung cấp sự cô lập (“những gì bạn có thể thấy”), cgroups cung cấp sự giới hạn (“những gì bạn có thể sử dụng”). Controllers/Subsystems: cgroups được quản lý thông qua các hệ thống con như memory, cpu, và blkio, mỗi hệ thống con kiểm soát một tài nguyên cụ thể. Thực Hành (Từng bước) Bước 1: Tạo một cgroup: Sử dụng cgcreate -g memory,cpu:/my-app-group để tạo một cgroup mới được quản lý bởi các controller bộ nhớ và CPU. Hoặc, có thể tạo thư mục thủ công trong hệ thống tệp ảo /sys/fs/cgroup/. Bước 2: Đặt Giới hạn Bộ nhớ: Sử dụng echo \"100M\" \u003e /sys/fs/cgroup/memory/my-app-group/memory.limit_in_bytes để đặt giới hạn bộ nhớ 100MB. Bước 3: Đặt Giới hạn CPU: Trình bày cách đặt hạn ngạch CPU. Ví dụ, echo 50000 \u003e.../cpu.cfs_quota_us và echo 100000 \u003e.../cpu.cfs_period_us để giới hạn tiến trình ở mức 50% của một lõi CPU. Bước 4: Chạy một Tiến trình trong cgroup: Sử dụng cgexec -g memory,cpu:/my-app-group để chạy một tiến trình trong các giới hạn này. Bước 5: Quan sát Giới hạn: Giám sát tiến trình bằng htop và xem nó bị điều tiết (CPU) hoặc bị OOM killer chấm dứt khi vượt quá giới hạn bộ nhớ. Kiểm tra các tệp kế toán của cgroup (memory.usage_in_bytes, memory.failcnt) để thấy việc thực thi giới hạn trong thực tế. Các bài lab 7 và 8 không chỉ là các bài tập lý thuyết; chúng là một minh chứng thực tế về những gì Kubernetes làm “dưới mui xe” mỗi khi nó lập lịch cho một Pod. Sự cô lập mạng của một Pod là một network namespace. Dòng resources: { limits: { memory: \"100Mi\" } } trong tệp YAML của Pod được dịch trực tiếp thành một cấu hình cgroup trên node. Do đó, việc gỡ lỗi một Pod bị OOMKilled trong Kubernetes về cơ bản là việc hiểu sự tương tác giữa ứng dụng và giới hạn bộ nhớ cgroup do Kubelet áp đặt. Hướng dẫn này kết nối tệp YAML trừu tượng của Kubernetes với các tính năng cụ thể của nhân Linux, trao quyền cho kỹ sư để suy luận về hành vi của container từ các nguyên tắc cơ bản, giúp họ trở thành một người vận hành và xử lý sự cố Kubernetes hiệu quả hơn nhiều.\nNếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!\n","wordCount":"3639","inLanguage":"en","image":"https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-23T00:00:00Z","dateModified":"2025-08-23T00:00:00Z","author":{"@type":"Person","name":"Nagih"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nagih.io.vn/posts/labs-operating/"},"publisher":{"@type":"Organization","name":"Nagih | Blog","logo":{"@type":"ImageObject","url":"https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nagih.io.vn/ accesskey=h title="Home (Alt + H)"><img src=https://blog.nagih.io.vn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.nagih.io.vn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nagih.io.vn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nagih.io.vn/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.nagih.io.vn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://nagih.io.vn title=Home><span>Home</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nagih.io.vn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.nagih.io.vn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Labs Operating</h1><div class=post-meta><span title='2025-08-23 00:00:00 +0000 UTC'>August 23, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3639 words&nbsp;·&nbsp;Nagih&nbsp;|&nbsp;<a href=https://github.com/vuongmanhnghia/posts/content/posts/system/Labs%20Operating.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#tại-sao-hệ-điều-hành-vẫn-quan-trọng-trong-thế-giới-cloud-native>Tại sao Hệ Điều Hành Vẫn Quan Trọng trong Thế Giới Cloud-Native</a></li><li><a href=#lab-1-điều-hướng-và-quản-lý-hệ-thống-tệp>Lab 1: Điều Hướng và Quản Lý Hệ Thống Tệp</a><ul><li><a href=#các-khái-niệm-cốt-lõi>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-2-quản-lý-người-dùng-nhóm-và-quyền-truy-cập>Lab 2: Quản Lý Người Dùng, Nhóm và Quyền Truy Cập</a><ul><li><a href=#các-khái-niệm-cốt-lõi-1>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-1>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-3-quản-lý-tiến-trình-và-giám-sát-thời-gian-thực>Lab 3: Quản Lý Tiến Trình và Giám Sát Thời Gian Thực</a><ul><li><a href=#các-khái-niệm-cốt-lõi-2>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-2>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-4-phân-tích-hiệu-năng-bộ-nhớ-và-io-đĩa>Lab 4: Phân Tích Hiệu Năng Bộ Nhớ và I/O Đĩa</a><ul><li><a href=#các-khái-niệm-cốt-lõi-3>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-3>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-5-các-lệnh-mạng-và-xử-lý-sự-cố-thiết-yếu>Lab 5: Các Lệnh Mạng và Xử Lý Sự Cố Thiết Yếu</a><ul><li><a href=#các-khái-niệm-cốt-lõi-4>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-4>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-6-thám-tử---xử-lý-sự-cố-nâng-cao-với-strace>Lab 6: Thám Tử - Xử Lý Sự Cố Nâng Cao với <code>strace</code></a><ul><li><a href=#các-khái-niệm-cốt-lõi-5>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-5>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-7-các-thành-phần-xây-dựng-container-namespaces>Lab 7: Các Thành Phần Xây Dựng Container: Namespaces</a><ul><li><a href=#các-khái-niệm-cốt-lõi-6>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-6>Thực Hành (Từng bước)</a></li></ul></li><li><a href=#lab-8-người-quản-lý---quản-lý-tài-nguyên-với-control-groups-cgroups>Lab 8: Người Quản Lý - Quản Lý Tài Nguyên với Control Groups (cgroups)</a><ul><li><a href=#các-khái-niệm-cốt-lõi-7>Các Khái Niệm Cốt Lõi</a></li><li><a href=#thực-hành-từng-bước-7>Thực Hành (Từng bước)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>1 Số Labs từ Cơ bản tới Nâng cao về Operating</p><h2 id=tại-sao-hệ-điều-hành-vẫn-quan-trọng-trong-thế-giới-cloud-native>Tại sao Hệ Điều Hành Vẫn Quan Trọng trong Thế Giới Cloud-Native<a hidden class=anchor aria-hidden=true href=#tại-sao-hệ-điều-hành-vẫn-quan-trọng-trong-thế-giới-cloud-native>#</a></h2><p>Trong lĩnh vực DevOps hiện đại, tồn tại một nghịch lý: trong khi các công cụ cấp cao như Kubernetes, Docker và Ansible trừu tượng hóa hệ điều hành bên dưới, việc hiểu sâu về Linux lại trở nên quan trọng hơn bao giờ hết. Hầu hết các công cụ DevOps cốt lõi đều được xây dựng để chạy tốt nhất trên Linux, biến nó thành nền tảng phổ biến cho cơ sở hạ tầng đám mây và tự động hóa.</p><p>Hướng dẫn này được thiết kế để nâng tầm kỹ sư từ một người dùng đơn thuần các công cụ này trở thành một kiến trúc sư hiểu rõ hoạt động bên trong của chúng. Hệ điều hành Linux không nên được xem như một hệ thống cũ kỹ, mà là &ldquo;API&rdquo; nền tảng, phổ quát cho mọi hoạt động tự động hóa cơ sở hạ tầng. Tám bài lab dưới đây được cấu trúc như một hành trình có phương pháp, phản ánh quy trình xử lý sự cố trong thực tế, bắt đầu từ các kiểm tra hệ thống cơ bản, đi sâu dần vào phân tích hiệu năng, gỡ lỗi nâng cao và cuối cùng là các nguyên tắc cốt lõi của container hóa. Đây không chỉ là một bộ sưu tập các lệnh; nó là một mô hình tư duy về hệ thống.</p><h2 id=lab-1-điều-hướng-và-quản-lý-hệ-thống-tệp>Lab 1: Điều Hướng và Quản Lý Hệ Thống Tệp<a hidden class=anchor aria-hidden=true href=#lab-1-điều-hướng-và-quản-lý-hệ-thống-tệp>#</a></h2><p><strong>Mục tiêu:</strong> Xây dựng &ldquo;trí nhớ cơ bắp&rdquo; để điều hướng hệ thống tệp Linux và thực hiện các thao tác tệp thiết yếu. Đây là nền tảng để tìm kiếm log, quản lý tệp cấu hình và chuẩn bị các tạo phẩm ứng dụng cho việc triển khai.</p><h3 id=các-khái-niệm-cốt-lõi>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi>#</a></h3><ul><li><strong>Triết lý &ldquo;Mọi thứ đều là tệp&rdquo;:</strong> Trong Linux, một nguyên tắc cốt lõi là mọi thứ, từ thiết bị phần cứng, socket mạng đến các thư mục, đều được biểu diễn dưới dạng tệp. Điều này cung cấp một giao diện thống nhất để tương tác với toàn bộ hệ thống.</li><li><strong>Tiêu chuẩn Phân cấp Hệ thống tệp (FHS):</strong> Cấu trúc thư mục trong Linux tuân theo một tiêu chuẩn, mang lại sự dễ đoán trong quản trị hệ thống. Các thư mục chính bao gồm <code>/etc</code> cho các tệp cấu hình, <code>/var/log</code> cho các tệp nhật ký, <code>/home</code> cho thư mục người dùng và <code>/usr</code> cho các tiện ích và ứng dụng hệ thống.</li></ul><h3 id=thực-hành-từng-bước>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước>#</a></h3><ol><li><strong>Bước 1: Xác định vị trí:</strong> Sử dụng lệnh <code>pwd</code> để in ra thư mục làm việc hiện tại và <code>whoami</code> để xác định người dùng hiện tại.</li><li><strong>Bước 2: Khám phá xung quanh:</strong> Sử dụng <code>ls</code> với các cờ phổ biến (<code>-l</code>, <code>-a</code>, <code>-h</code>) để liệt kê nội dung thư mục và hiểu định dạng đầu ra (quyền, chủ sở hữu, kích thước, ngày).</li><li><strong>Bước 3: Di chuyển:</strong> Thực hành điều hướng bằng <code>cd</code>, sử dụng cả đường dẫn tuyệt đối (ví dụ: <code>cd /var/log</code>) và tương đối (ví dụ: <code>cd../..</code>).</li><li><strong>Bước 4: Tạo và Xóa:</strong> Sử dụng <code>touch</code> để tạo các tệp trống, <code>mkdir</code> để tạo thư mục (và <code>-p</code> để tạo các thư mục cha), và <code>rm</code> để xóa tệp và thư mục (<code>-r</code> để xóa đệ quy).</li><li><strong>Bước 5: Thao tác với tệp:</strong> Sử dụng <code>cp</code> để sao chép, <code>mv</code> để di chuyển/đổi tên, và <code>cat</code> để hiển thị nội dung tệp.</li></ol><table><thead><tr><th>Lệnh</th><th>Trường Hợp Sử Dụng Phổ Biến</th></tr></thead><tbody><tr><td><code>ls</code></td><td>Liệt kê nội dung của một thư mục.</td></tr><tr><td><code>cd</code></td><td>Thay đổi thư mục làm việc hiện tại.</td></tr><tr><td><code>pwd</code></td><td>In ra đường dẫn đầy đủ của thư mục hiện tại.</td></tr><tr><td><code>mkdir</code></td><td>Tạo một thư mục mới.</td></tr><tr><td><code>rm</code></td><td>Xóa tệp hoặc thư mục.</td></tr><tr><td><code>cp</code></td><td>Sao chép tệp hoặc thư mục.</td></tr><tr><td><code>mv</code></td><td>Di chuyển hoặc đổi tên tệp hoặc thư mục.</td></tr><tr><td><code>touch</code></td><td>Tạo một tệp trống hoặc cập nhật dấu thời gian của tệp.</td></tr><tr><td><code>cat</code></td><td>Hiển thị nội dung của một tệp.</td></tr><tr><td><code>head</code> / <code>tail</code></td><td>Hiển thị phần đầu hoặc phần cuối của một tệp.</td></tr></tbody></table><h2 id=lab-2-quản-lý-người-dùng-nhóm-và-quyền-truy-cập>Lab 2: Quản Lý Người Dùng, Nhóm và Quyền Truy Cập<a hidden class=anchor aria-hidden=true href=#lab-2-quản-lý-người-dùng-nhóm-và-quyền-truy-cập>#</a></h2><p><strong>Mục tiêu:</strong> Bảo mật tài nguyên hệ thống bằng cách làm chủ quyền sở hữu tệp và các danh sách kiểm soát truy cập. Kỹ năng này có thể áp dụng trực tiếp vào việc bảo mật môi trường tác tử CI/CD, thiết lập quyền cho các tạo phẩm triển khai và cấu hình quyền truy cập của người dùng trên máy chủ.</p><h3 id=các-khái-niệm-cốt-lõi-1>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-1>#</a></h3><ul><li><strong>Bộ ba Bảo mật:</strong> Mô hình quyền trong Linux dựa trên ba thực thể: <code>user</code> (người dùng, chủ sở hữu), <code>group</code> (nhóm), và <code>other</code> (những người khác).</li><li><strong>Giải mã Quyền:</strong> Mỗi thực thể có thể được cấp ba loại quyền cơ bản: <code>read (r)</code> (đọc), <code>write (w)</code> (ghi), và <code>execute (x)</code> (thực thi). Ý nghĩa của các quyền này khác nhau giữa tệp và thư mục. Ví dụ, quyền <code>execute</code> trên một thư mục cho phép người dùng <code>cd</code> vào thư mục đó, trong khi trên một tệp, nó cho phép chạy tệp đó như một chương trình.</li></ul><h3 id=thực-hành-từng-bước-1>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-1>#</a></h3><ol><li><p><strong>Bước 1: Quản trị Người dùng và Nhóm:</strong> Tạo một người dùng mới với <code>useradd</code>, đặt mật khẩu với <code>passwd</code>, và tạo một nhóm mới với <code>groupadd</code>. Thêm người dùng vào nhóm vừa tạo.</p></li><li><p><strong>Bước 2: Thay đổi Quyền sở hữu:</strong> Sử dụng <code>chown</code> để thay đổi chủ sở hữu của một tệp và <code>chgrp</code> (hoặc <code>chown user:group</code>) để thay đổi nhóm sở hữu. Luôn sử dụng</p><p><code>sudo</code> cho các hoạt động này khi cần thiết.</p></li><li><p><strong>Bước 3: Sửa đổi Quyền bằng Ký hiệu Tượng trưng:</strong> Sử dụng <code>chmod</code> với ký hiệu tượng trưng (<code>u+x</code>, <code>g-w</code>, <code>o=r</code>) để thay đổi quyền một cách chi tiết và dễ đọc.</p></li><li><p><strong>Bước 4: Sửa đổi Quyền bằng Ký hiệu Bát phân (Số):</strong> Giới thiệu các giá trị số (r=4, w=2, x=1) và trình bày cách thiết lập các quyền phổ biến như <code>chmod 755</code> cho các tập lệnh và <code>chmod 644</code> cho các tệp web.</p></li></ol><table><thead><tr><th>Giá trị Bát phân</th><th>Ký hiệu Tượng trưng</th><th>Trường Hợp Sử Dụng Phổ Biến</th></tr></thead><tbody><tr><td><code>777</code></td><td><code>rwxrwxrwx</code></td><td>Không an toàn, chỉ dùng cho mục đích tạm thời hoặc trong môi trường được kiểm soát chặt chẽ.</td></tr><tr><td><code>755</code></td><td><code>rwxr-xr-x</code></td><td>Các tập lệnh thực thi, các thư mục cần người khác truy cập.</td></tr><tr><td><code>644</code></td><td><code>rw-r--r--</code></td><td>Các tệp nội dung web, tệp cấu hình chỉ đọc cho người khác.</td></tr><tr><td><code>600</code></td><td><code>rw-------</code></td><td>Các tệp nhạy cảm như khóa riêng SSH, chỉ chủ sở hữu mới có thể đọc/ghi.</td></tr></tbody></table><h2 id=lab-3-quản-lý-tiến-trình-và-giám-sát-thời-gian-thực>Lab 3: Quản Lý Tiến Trình và Giám Sát Thời Gian Thực<a hidden class=anchor aria-hidden=true href=#lab-3-quản-lý-tiến-trình-và-giám-sát-thời-gian-thực>#</a></h2><p><strong>Mục tiêu:</strong> Học cách xem những gì đang chạy trên hệ thống, diễn giải việc sử dụng tài nguyên và quản lý các tiến trình hoạt động sai. Đây là tuyến phòng thủ đầu tiên khi khắc phục sự cố một ứng dụng chạy chậm hoặc không phản hồi, ngay cả bên trong một container.</p><h3 id=các-khái-niệm-cốt-lõi-2>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-2>#</a></h3><ul><li><strong>Vòng đời Tiến trình:</strong> Một tiến trình là một thực thể của một chương trình đang chạy. Mỗi tiến trình có một Mã định danh Tiến trình (PID) duy nhất và có thể ở các trạng thái khác nhau như đang chạy (running), đang ngủ (sleeping), hoặc zombie (xác sống).</li></ul><h3 id=thực-hành-từng-bước-2>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-2>#</a></h3><ol><li><strong>Bước 1: Liệt kê Tiến trình Tĩnh:</strong> Sử dụng <code>ps aux</code> để có một ảnh chụp nhanh chi tiết về tất cả các tiến trình đang chạy. Phân tích các cột chính: <code>USER</code>, <code>PID</code>, <code>%CPU</code>, <code>%MEM</code>, <code>COMMAND</code>.</li><li><strong>Bước 2: Giám sát Thời gian thực với <code>top</code>:</strong> Khởi chạy <code>top</code> và giải thích khu vực tóm tắt (tải trung bình, tác vụ, trạng thái CPU, bộ nhớ) và danh sách tiến trình tương tác. Trình bày cách sắp xếp theo bộ nhớ (<code>M</code>) và CPU (<code>P</code>).</li><li><strong>Bước 3: Giám sát Nâng cao với <code>htop</code>:</strong> Giới thiệu <code>htop</code> như một giải pháp thay thế thân thiện và tương tác hơn cho <code>top</code>. Hướng dẫn người dùng qua các tính năng chính của nó: hiển thị mã màu, cuộn dễ dàng, chế độ xem cây (<code>F5</code>), tìm kiếm (<code>F3</code>), và sắp xếp (<code>F6</code>).</li><li><strong>Bước 4: Chấm dứt Tiến trình:</strong> Sử dụng lệnh <code>kill</code> với PID để gửi tín hiệu. Giải thích sự khác biệt giữa <code>SIGTERM</code> (chấm dứt nhẹ nhàng, <code>kill &lt;PID></code>) và <code>SIGKILL</code> (chấm dứt cưỡng bức, <code>kill -9 &lt;PID></code>). Trình bày cách chấm dứt một tiến trình trực tiếp từ <code>htop</code> (<code>F9</code>).</li></ol><p>Các kỹ năng trong bài lab này không chỉ dành cho các máy chủ truyền thống; chúng là những công cụ chính để gỡ lỗi bên trong một container đang chạy. Khi một container sử dụng quá nhiều CPU hoặc bộ nhớ, quy trình chẩn đoán tiêu chuẩn là <code>docker exec -it &lt;container_id> bash</code> theo sau là <code>htop</code> hoặc <code>ps aux</code>. Kubernetes hoặc Docker có thể cho biết <em>rằng</em> một container không khỏe mạnh, nhưng để tìm ra <em>lý do tại sao</em>, cần phải kiểm tra không gian tiến trình bị cô lập bên trong nó bằng chính các công cụ đã học.</p><h2 id=lab-4-phân-tích-hiệu-năng-bộ-nhớ-và-io-đĩa>Lab 4: Phân Tích Hiệu Năng Bộ Nhớ và I/O Đĩa<a hidden class=anchor aria-hidden=true href=#lab-4-phân-tích-hiệu-năng-bộ-nhớ-và-io-đĩa>#</a></h2><p><strong>Mục tiêu:</strong> Vượt ra ngoài việc giám sát CPU để chẩn đoán hai trong số những nút thắt hiệu năng phổ biến nhất: áp lực bộ nhớ và I/O đĩa chậm.</p><h3 id=các-khái-niệm-cốt-lõi-3>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-3>#</a></h3><ul><li><strong>Mô hình Bộ nhớ Linux:</strong> Giải thích sự khác biệt giữa bộ nhớ <code>used</code> (đã sử dụng) và <code>available</code> (khả dụng), nhấn mạnh vai trò của <code>buff/cache</code>. Giải mã lý do tại sao &ldquo;bộ nhớ trống thấp&rdquo; thường là bình thường trong Linux. Giới thiệu về Bộ nhớ ảo, Hoán đổi (Swapping) và nguy cơ của Trình tiêu diệt Hết bộ nhớ (OOM Killer).</li><li><strong>Các Chỉ số I/O Đĩa:</strong> Xác định các chỉ số hiệu năng chính (KPI): IOPS (số thao tác mỗi giây), Thông lượng (MB/s), và Độ trễ/<code>await</code> (thời gian cho mỗi thao tác).</li></ul><h3 id=thực-hành-từng-bước-3>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-3>#</a></h3><ol><li><strong>Bước 1: Phân tích Sử dụng Bộ nhớ:</strong> Sử dụng <code>free -h</code> để có cái nhìn tổng quan dễ đọc về việc sử dụng RAM và swap. Giải thích từng cột (<code>total</code>, <code>used</code>, <code>free</code>, <code>buff/cache</code>, <code>available</code>).</li><li><strong>Bước 2: Giám sát I/O Đĩa với <code>iostat</code>:</strong> Chạy <code>iostat -x 1</code> để có cái nhìn thời gian thực, mở rộng về các thống kê đĩa. Tập trung vào việc diễn giải các cột quan trọng nhất: <code>r/s</code>, <code>w/s</code> (IOPS), <code>rMB/s</code>, <code>wMB/s</code> (Thông lượng), <code>await</code> (Độ trễ), và <code>%util</code> (Độ bão hòa).</li><li><strong>Bước 3: Xác định các Tiến trình Gây Tải I/O nặng với <code>iotop</code>:</strong> Sử dụng <code>sudo iotop</code> để xem một giao diện giống <code>top</code> của các tiến trình được xếp hạng theo I/O đĩa hiện tại của chúng. Điều này trả lời trực tiếp câu hỏi, &ldquo;Tiến trình nào đang làm quá tải đĩa?&rdquo;.</li></ol><p>Các chỉ số thu thập được trong bài lab này không phải là những con số tùy ý; chúng là dữ liệu thô cung cấp cho các khuôn khổ độ tin cậy cấp cao hơn như &ldquo;Bốn Tín hiệu Vàng&rdquo; của SRE của Google (Độ trễ, Lưu lượng, Lỗi, Độ bão hòa). Việc học cách đo lường chúng tại nguồn là một bước tiến từ quản trị hệ thống đơn thuần sang kỹ thuật đảm bảo độ tin cậy. Ví dụ, cột</p><p><code>await</code> trong <code>iostat</code> là một thước đo trực tiếp về <strong>Độ trễ</strong> I/O đĩa. Các cột IOPS và thông lượng là thước đo trực tiếp về <strong>Lưu lượng</strong> đĩa. Cột <code>%util</code> trong <code>iostat</code> và <code>%iowait</code> từ <code>top</code> là các chỉ số trực tiếp về <strong>Độ bão hòa</strong> của đĩa và CPU. Bằng cách hiểu mối liên hệ này, ta có thể chẩn đoán các vấn đề hiệu năng với một tư duy chiến lược, tập trung vào các chỉ số thực sự quan trọng đối với sức khỏe của dịch vụ.</p><h2 id=lab-5-các-lệnh-mạng-và-xử-lý-sự-cố-thiết-yếu>Lab 5: Các Lệnh Mạng và Xử Lý Sự Cố Thiết Yếu<a hidden class=anchor aria-hidden=true href=#lab-5-các-lệnh-mạng-và-xử-lý-sự-cố-thiết-yếu>#</a></h2><p><strong>Mục tiêu:</strong> Xây dựng một bộ công cụ mạnh mẽ để chẩn đoán các vấn đề mạng, từ kiểm tra kết nối cơ bản đến kiểm tra các kết nối đang hoạt động và các vấn đề DNS—một công việc hàng ngày trong môi trường microservices.</p><h3 id=các-khái-niệm-cốt-lõi-4>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-4>#</a></h3><p>Các khái niệm cơ bản về mạng bao gồm giao diện mạng, địa chỉ IP, cổng và socket, là những thành phần nền tảng cho mọi giao tiếp trên mạng.</p><h3 id=thực-hành-từng-bước-4>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-4>#</a></h3><ul><li><strong>Bước 1: Kiểm tra Cấu hình Cục bộ:</strong> Sử dụng <code>ip addr</code> (thay thế hiện đại cho <code>ifconfig</code>) để xem các giao diện mạng và địa chỉ IP của chúng.</li><li><strong>Bước 2: Kiểm tra Kết nối Cơ bản:</strong> Sử dụng <code>ping</code> để kiểm tra khả năng tiếp cận và độ trễ, và <code>traceroute</code> để vạch ra đường đi của gói tin mạng đến một đích.</li><li><strong>Bước 3: Xử lý Sự cố DNS:</strong> Sử dụng <code>dig</code> và <code>host</code> để truy vấn các bản ghi DNS (A, CNAME, MX) và thực hiện tra cứu ngược. Điều này rất quan trọng để gỡ lỗi các vấn đề phát hiện dịch vụ (service discovery).</li><li><strong>Bước 4: Kiểm tra các Kết nối Đang hoạt động:</strong> Giới thiệu <code>ss</code> là công cụ thay thế hiện đại, nhanh hơn cho <code>netstat</code>. Sử dụng
<code>ss -tulpn</code> để tìm các cổng đang lắng nghe và các tiến trình sử dụng chúng. Đây là chìa khóa để trả lời &ldquo;Ứng dụng của tôi có đang lắng nghe trên đúng cổng không?&rdquo; và &ldquo;Cái gì đang kết nối với dịch vụ của tôi?&rdquo;.</li><li><strong>Bước 5: Tương tác với Dịch vụ Web:</strong> Sử dụng <code>curl</code> để thực hiện các yêu cầu HTTP, xem các tiêu đề phản hồi (<code>-I</code>), và nhận chi tiết kết nối đầy đủ (<code>-v</code>), rất cần thiết để kiểm tra API và máy chủ web.</li></ul><table><thead><tr><th>Lệnh <code>netstat</code> Cũ</th><th>Lệnh <code>ss</code> Hiện Đại</th><th>Mục Đích</th></tr></thead><tbody><tr><td><code>netstat -tulpn</code></td><td><code>ss -tulpn</code></td><td>Liệt kê tất cả các cổng TCP/UDP đang lắng nghe và các tiến trình liên quan.</td></tr><tr><td><code>netstat -tan</code></td><td><code>ss -tan</code></td><td>Hiển thị tất cả các kết nối TCP (cả đang lắng nghe và đã thiết lập).</td></tr><tr><td><code>netstat -tun</code></td><td><code>ss -tun</code></td><td>Hiển thị tất cả các kết nối TCP và UDP.</td></tr></tbody></table><h2 id=lab-6-thám-tử---xử-lý-sự-cố-nâng-cao-với-strace>Lab 6: Thám Tử - Xử Lý Sự Cố Nâng Cao với <code>strace</code><a hidden class=anchor aria-hidden=true href=#lab-6-thám-tử---xử-lý-sự-cố-nâng-cao-với-strace>#</a></h2><p><strong>Mục tiêu:</strong> Học cách sử dụng <code>strace</code> như công cụ gỡ lỗi tối thượng để xem chính xác một ứng dụng đang làm gì ở cấp độ lời gọi hệ thống, khi mà log và giám sát không đủ thông tin.</p><h3 id=các-khái-niệm-cốt-lõi-5>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-5>#</a></h3><ul><li><strong>Ranh giới Kernel-Userspace:</strong> Lời gọi hệ thống (<code>syscalls</code>) là giao diện mà qua đó các ứng dụng yêu cầu dịch vụ từ nhân Linux (ví dụ: mở một tệp, gửi dữ liệu mạng). <code>strace</code> chặn và giải mã các lời gọi này, cung cấp một cái nhìn không bị che giấu về hoạt động của chương trình.</li></ul><h3 id=thực-hành-từng-bước-5>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-5>#</a></h3><ul><li><strong>Bước 1: Truy vết Cơ bản:</strong> Chạy một lệnh đơn giản dưới <code>strace</code> (ví dụ: <code>strace ls</code>) để xem luồng đầu ra và hiểu định dạng của nó.</li><li><strong>Bước 2: Gắn vào một Tiến trình Đang chạy:</strong> Tìm PID của một tiến trình đang chạy (sử dụng <code>ps</code> hoặc <code>htop</code> từ Lab 3) và gắn vào nó với <code>strace -p &lt;PID></code>.</li><li><strong>Bước 3: Lọc Nhiễu:</strong> Sức mạnh thực sự của <code>strace</code> nằm ở khả năng lọc. Trình bày cách truy vết các syscall cụ thể với <code>-e</code>:<ul><li><strong>Sự cố Truy cập Tệp:</strong> Sử dụng <code>strace -e trace=file &lt;command></code> để gỡ lỗi các lỗi &ldquo;Permission denied&rdquo; hoặc &ldquo;No such file or directory&rdquo; bằng cách xem chính xác đường dẫn tệp nào đang bị lỗi.</li><li><strong>Sự cố Mạng:</strong> Sử dụng <code>strace -e trace=network &lt;command></code> để xem các lời gọi <code>connect</code>, <code>sendto</code>, <code>recvfrom</code>, giúp gỡ lỗi các kết nối mạng chậm hoặc thất bại.</li></ul></li><li><strong>Bước 4: Phân tích Hiệu năng:</strong> Giới thiệu cờ <code>-T</code> để hiển thị thời gian đã dành cho mỗi syscall, giúp xác định các nút thắt hiệu năng nơi ứng dụng đang chờ một thao tác I/O chậm.</li></ul><p>Log ứng dụng, các chỉ số và tài liệu mô tả những gì một chương trình <em>nên</em> làm. <code>strace</code> tiết lộ những gì nó <em>thực sự</em> đang làm. Nó là nguồn sự thật tối thượng để gỡ lỗi, bỏ qua tất cả các lớp trừu tượng ở cấp độ ứng dụng. Khi các công cụ khác cung cấp thông tin sai lệch hoặc im lặng, <code>strace</code> cung cấp một bản ghi khách quan, không bị lọc về ý định của chương trình, biến nó thành một kỹ năng quan trọng để giải quyết những lỗi &ldquo;không thể&rdquo;.</p><h2 id=lab-7-các-thành-phần-xây-dựng-container-namespaces>Lab 7: Các Thành Phần Xây Dựng Container: Namespaces<a hidden class=anchor aria-hidden=true href=#lab-7-các-thành-phần-xây-dựng-container-namespaces>#</a></h2><p><strong>Mục tiêu:</strong> Giải mã công nghệ container bằng cách trình bày thực tế cách các namespace của Linux tạo ra môi trường bị cô lập cho các tiến trình, mạng và hệ thống tệp.</p><h3 id=các-khái-niệm-cốt-lõi-6>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-6>#</a></h3><ul><li><strong>Namespaces là gì?</strong> Namespaces là một tính năng của nhân Linux giúp phân vùng các tài nguyên hệ thống toàn cục sao cho một tiến trình bên trong một namespace nghĩ rằng nó có một phiên bản riêng của tài nguyên đó (ví dụ: cây tiến trình riêng, ngăn xếp mạng riêng). Đây là cốt lõi của sự cô lập container.</li><li><strong>Các loại Namespaces:</strong> Các loại namespace chính bao gồm PID (Process ID), Net (Network), MNT (Mount), UTS (Hostname), và User. Bài lab này sẽ tập trung vào namespace Mạng (<code>net</code>) như một ví dụ trực quan nhất.</li></ul><h3 id=thực-hành-từng-bước-6>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-6>#</a></h3><ul><li><strong>Bước 1: Tạo Network Namespaces:</strong> Sử dụng <code>ip netns add &lt;name></code> để tạo hai namespace mạng riêng biệt (ví dụ: <code>ns1</code>, <code>ns2</code>).</li><li><strong>Bước 2: Xác minh Sự cô lập:</strong> Chạy <code>ip netns exec &lt;name> ip addr</code> để cho thấy mỗi namespace chỉ có giao diện <code>lo</code> riêng của nó và đang ở trạng thái <code>DOWN</code>.</li><li><strong>Bước 3: Tạo một &ldquo;Cáp Mạng Ảo&rdquo;:</strong> Sử dụng <code>ip link add veth-ns1 type veth peer name veth-ns2</code> để tạo một cặp ethernet ảo (một &ldquo;dây cáp mạng&rdquo; ảo).</li><li><strong>Bước 4: Kết nối các Namespaces:</strong> &ldquo;Cắm&rdquo; mỗi đầu của cáp ảo vào một namespace bằng cách sử dụng <code>ip link set &lt;veth-device> netns &lt;name></code>.</li><li><strong>Bước 5: Cấu hình Mạng bị cô lập:</strong> Bên trong mỗi namespace, gán một địa chỉ IP cho giao diện veth (<code>ip netns exec &lt;name> ip addr add...</code>) và bật giao diện lên (<code>ip netns exec &lt;name> ip link set... up</code>).</li><li><strong>Bước 6: Kiểm tra Giao tiếp:</strong> Sử dụng <code>ip netns exec ns1 ping &lt;ns2_ip></code> để cho thấy hai môi trường bị cô lập giờ đây có thể giao tiếp với nhau qua mạng riêng của chúng, nhưng vẫn vô hình đối với máy chủ chủ (host).</li></ul><h2 id=lab-8-người-quản-lý---quản-lý-tài-nguyên-với-control-groups-cgroups>Lab 8: Người Quản Lý - Quản Lý Tài Nguyên với Control Groups (cgroups)<a hidden class=anchor aria-hidden=true href=#lab-8-người-quản-lý---quản-lý-tài-nguyên-với-control-groups-cgroups>#</a></h2><p><strong>Mục tiêu:</strong> Bổ sung cho sự cô lập từ Lab 7, bài lab này trình bày cách sử dụng cgroups để giới hạn tài nguyên (CPU, bộ nhớ) mà một tiến trình có thể tiêu thụ, hoàn thiện bức tranh về container hóa.</p><h3 id=các-khái-niệm-cốt-lõi-7>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-7>#</a></h3><ul><li><strong>cgroups là gì?</strong> cgroups (control groups) là một tính năng của nhân Linux để giới hạn, tính toán và ưu tiên việc sử dụng tài nguyên cho một tập hợp các tiến trình. Trong khi namespaces cung cấp
<em>sự cô lập</em> (&ldquo;những gì bạn có thể thấy&rdquo;), cgroups cung cấp <em>sự giới hạn</em> (&ldquo;những gì bạn có thể sử dụng&rdquo;).</li><li><strong>Controllers/Subsystems:</strong> cgroups được quản lý thông qua các hệ thống con như <code>memory</code>, <code>cpu</code>, và <code>blkio</code>, mỗi hệ thống con kiểm soát một tài nguyên cụ thể.</li></ul><h3 id=thực-hành-từng-bước-7>Thực Hành (Từng bước)<a hidden class=anchor aria-hidden=true href=#thực-hành-từng-bước-7>#</a></h3><ul><li><strong>Bước 1: Tạo một cgroup:</strong> Sử dụng <code>cgcreate -g memory,cpu:/my-app-group</code> để tạo một cgroup mới được quản lý bởi các controller bộ nhớ và CPU. Hoặc, có thể tạo thư mục thủ công trong hệ thống tệp ảo
<code>/sys/fs/cgroup/</code>.</li><li><strong>Bước 2: Đặt Giới hạn Bộ nhớ:</strong> Sử dụng <code>echo "100M" > /sys/fs/cgroup/memory/my-app-group/memory.limit_in_bytes</code> để đặt giới hạn bộ nhớ 100MB.</li><li><strong>Bước 3: Đặt Giới hạn CPU:</strong> Trình bày cách đặt hạn ngạch CPU. Ví dụ, <code>echo 50000 >.../cpu.cfs_quota_us</code> và <code>echo 100000 >.../cpu.cfs_period_us</code> để giới hạn tiến trình ở mức 50% của một lõi CPU.</li><li><strong>Bước 4: Chạy một Tiến trình trong cgroup:</strong> Sử dụng <code>cgexec -g memory,cpu:/my-app-group &lt;command></code> để chạy một tiến trình trong các giới hạn này.</li><li><strong>Bước 5: Quan sát Giới hạn:</strong> Giám sát tiến trình bằng <code>htop</code> và xem nó bị điều tiết (CPU) hoặc bị OOM killer chấm dứt khi vượt quá giới hạn bộ nhớ. Kiểm tra các tệp kế toán của cgroup (<code>memory.usage_in_bytes</code>, <code>memory.failcnt</code>) để thấy việc thực thi giới hạn trong thực tế.</li></ul><p>Các bài lab 7 và 8 không chỉ là các bài tập lý thuyết; chúng là một minh chứng thực tế về những gì Kubernetes làm &ldquo;dưới mui xe&rdquo; mỗi khi nó lập lịch cho một Pod. Sự cô lập mạng của một Pod là một network namespace. Dòng <code>resources: { limits: { memory: "100Mi" } }</code> trong tệp YAML của Pod được dịch trực tiếp thành một cấu hình cgroup trên node. Do đó, việc gỡ lỗi một Pod bị OOMKilled trong Kubernetes về cơ bản là việc hiểu sự tương tác giữa ứng dụng và giới hạn bộ nhớ cgroup do Kubelet áp đặt. Hướng dẫn này kết nối tệp YAML trừu tượng của Kubernetes với các tính năng cụ thể của nhân Linux, trao quyền cho kỹ sư để suy luận về hành vi của container từ các nguyên tắc cơ bản, giúp họ trở thành một người vận hành và xử lý sự cố Kubernetes hiệu quả hơn nhiều.</p><hr><p><em>Nếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nagih.io.vn/tags/lab/>Lab</a></li></ul><nav class=paginav><a class=prev href=https://blog.nagih.io.vn/posts/ddd-domain-driven-design/><span class=title>« Prev</span><br><span>DDD (Domain-Driven Design)</span>
</a><a class=next href=https://blog.nagih.io.vn/posts/desgin-microservices/><span class=title>Next »</span><br><span>Desgin Microservices</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on x" href="https://x.com/intent/tweet/?text=Labs%20Operating&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f&amp;hashtags=lab"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f&amp;title=Labs%20Operating&amp;summary=Labs%20Operating&amp;source=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f&title=Labs%20Operating"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on whatsapp" href="https://api.whatsapp.com/send?text=Labs%20Operating%20-%20https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on telegram" href="https://telegram.me/share/url?text=Labs%20Operating&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Labs Operating on ycombinator" href="https://news.ycombinator.com/submitlink?t=Labs%20Operating&u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2flabs-operating%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nagih.io.vn/>Nagih | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>