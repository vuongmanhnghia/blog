<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Overview | Nagih | Blog</title>
<meta name=keywords content="docker"><meta name=description content="Tổng hợp các kiến thức cần biết về Docker"><meta name=author content="Nagih"><link rel=canonical href=https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/"><meta property="og:site_name" content="Nagih | Blog"><meta property="og:title" content="Docker Overview"><meta property="og:description" content="Tổng hợp các kiến thức cần biết về Docker"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-12T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-12T00:00:00+00:00"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Docker Overview"><meta name=twitter:description content="Tổng hợp các kiến thức cần biết về Docker"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nagih.io.vn/posts/"},{"@type":"ListItem","position":2,"name":"Docker Overview","item":"https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Overview","name":"Docker Overview","description":"Tổng hợp các kiến thức cần biết về Docker\n","keywords":["docker"],"articleBody":"Tổng hợp các kiến thức cần biết về Docker\nPhần 1: Cuộc Cách Mạng Container - Thấu Hiểu Các Nguyên Tắc Cốt Lõi của Docker 1.1 Giới thiệu về Docker: Tại sao lại là một cuộc cách mạng? Trong thế giới phát triển phần mềm hiện đại, Docker đã nổi lên như một công nghệ nền tảng, thay đổi cách các lập trình viên xây dựng, vận chuyển và chạy ứng dụng. Về cơ bản, Docker là một nền tảng mã nguồn mở được thiết kế để tự động hóa việc triển khai ứng dụng bên trong các môi trường biệt lập, nhẹ được gọi là container.1 Mỗi container đóng gói phần mềm cùng với tất cả những gì nó cần để hoạt động—bao gồm thư viện, công cụ hệ thống, mã nguồn và thời gian chạy (runtime)—thành một đơn vị tiêu chuẩn hóa.3\nĐể hiểu rõ giá trị của Docker, điều quan trọng là phải phân biệt nó với công nghệ ảo hóa truyền thống: máy ảo (Virtual Machines - VMs).\nMáy ảo (VMs): Một máy ảo ảo hóa toàn bộ phần cứng vật lý, cho phép nhiều hệ điều hành khách (guest OS) chạy trên một máy chủ chủ (host server) duy nhất. Mỗi VM bao gồm một bản sao đầy đủ của một hệ điều hành, các tệp nhị phân và thư viện cần thiết, và chính ứng dụng. Điều này dẫn đến sự cô lập mạnh mẽ nhưng phải trả giá bằng việc tiêu tốn tài nguyên đáng kể, kích thước lớn (hàng gigabyte) và thời gian khởi động chậm.4 Containers: Ngược lại, container ảo hóa ở cấp độ hệ điều hành. Thay vì đóng gói cả một hệ điều hành khách, các container chia sẻ nhân (kernel) của hệ điều hành máy chủ.6 Chúng chỉ đóng gói ứng dụng và các dependencies của nó. Kết quả là các container cực kỳ nhẹ (thường chỉ vài chục megabyte), khởi động gần như tức thì và cho phép mật độ ứng dụng cao hơn nhiều trên cùng một phần cứng.5 Sự thay đổi mô hình này mang lại những lợi ích to lớn, định hình lại toàn bộ vòng đời phát triển phần mềm:\nPhân phối ứng dụng nhanh chóng, nhất quán: Docker giải quyết triệt để vấn đề kinh điển “nó chạy trên máy tôi nhưng không chạy trên production”. Bằng cách đóng gói ứng dụng và môi trường của nó lại với nhau, Docker đảm bảo tính nhất quán trên các môi trường phát triển, kiểm thử và sản xuất.8 Tính di động (Portability) vượt trội: Một container được xây dựng trên máy tính xách tay của lập trình viên có thể chạy không thay đổi trên bất kỳ hệ thống nào có cài đặt Docker, cho dù đó là máy chủ vật lý tại chỗ, máy ảo trên đám mây hay trong một môi trường lai.1 Hiệu quả và Tiết kiệm chi phí: Vì các container nhẹ hơn nhiều so với VM, chúng cho phép chạy nhiều ứng dụng hơn trên cùng một cơ sở hạ tầng. Điều này cải thiện đáng kể việc sử dụng tài nguyên và giúp tiết kiệm chi phí phần cứng và cấp phép.3 Tăng tốc quy trình phát triển (CI/CD): Docker tích hợp liền mạch vào các quy trình Tích hợp liên tục và Triển khai liên tục (CI/CD). Các image container có thể được xây dựng, kiểm thử và đẩy lên registry một cách tự động, giúp tăng tốc độ phát hành phần mềm một cách đáng kể.1 Sự phổ biến của Docker không chỉ là một thành tựu kỹ thuật; nó là chất xúc tác trực tiếp cho văn hóa DevOps. Các lợi ích kỹ thuật như môi trường chuẩn hóa 1 và tính di động 8 đã cung cấp cơ chế thực tế để thực hiện các nguyên lý cốt lõi của DevOps: phá vỡ các rào cản giữa phát triển (Dev) và vận hành (Ops), tự động hóa các quy trình, và tăng tần suất triển khai. Docker không chỉ tạo ra một công cụ mới; nó đã biến DevOps từ một triết lý thành một thực tiễn khả thi cho hàng triệu lập trình viên trên toàn thế giới.7\n1.2 Hệ sinh thái Docker: Các Thành phần Cơ bản Để làm việc hiệu quả với Docker, việc nắm vững các khái niệm và thành phần cốt lõi của nó là điều bắt buộc.\nKiến trúc Docker\nDocker hoạt động theo kiến trúc client-server. Thành phần chính bao gồm:\nDocker Daemon (dockerd): Một dịch vụ nền chạy trên máy chủ, chịu trách nhiệm xây dựng, chạy và quản lý các đối tượng Docker như images, containers, networks và volumes. Docker Client (docker): Công cụ dòng lệnh (CLI) mà người dùng tương tác. Khi một lệnh như docker run được thực thi, client sẽ gửi yêu cầu đến daemon thông qua REST API qua socket UNIX hoặc giao diện mạng.1 Images và Containers: Bản thiết kế và Thực thể\nĐây là khái niệm cơ bản và quan trọng nhất trong Docker, thường gây nhầm lẫn cho người mới bắt đầu. Một phép ẩn dụ hữu ích là xem Image như một Class trong lập trình hướng đối tượng và Container như một Instance của class đó.10\nImage: Một Docker image là một mẫu (template) chỉ đọc (read-only) và bất biến (immutable) chứa một tập hợp các chỉ dẫn để tạo ra một container.11 Nó giống như một bản thiết kế chi tiết, bao gồm mã nguồn ứng dụng, runtime, thư viện, biến môi trường và các tệp cấu hình. Images được xây dựng từ một Dockerfile và bao gồm một loạt các lớp (layers) xếp chồng lên nhau. Mỗi chỉ thị trong Dockerfile tạo ra một lớp mới. Tính bất biến này chính là nguyên nhân trực tiếp tạo ra khả năng tái tạo và tính nhất quán mà Docker cung cấp; vì image không thể thay đổi, mọi container được khởi tạo từ nó đều được đảm bảo giống hệt nhau, loại bỏ hoàn toàn sự trôi dạt môi trường.4 Container: Một Docker container là một thực thể đang chạy (a running instance) của một image.4 Khi Docker tạo một container từ một image, nó sẽ thêm một lớp có thể ghi (writable layer) lên trên các lớp chỉ đọc của image. Bất kỳ thay đổi nào được thực hiện bên trong container—chẳng hạn như tạo tệp mới, sửa đổi cấu hình, hoặc cài đặt phần mềm—đều được ghi vào lớp này. Điều này có nghĩa là nhiều container có thể chia sẻ cùng một image cơ sở trong khi vẫn duy trì trạng thái riêng biệt của chúng.12 Dockerfile: Công thức để tạo Image\nDockerfile là một tệp văn bản đơn giản chứa các hướng dẫn từng bước để Docker tự động xây dựng một image.13 Mỗi lệnh (ví dụ:\nFROM, COPY, RUN, CMD) trong Dockerfile tương ứng với một lớp trong image. Cấu trúc phân lớp này rất hiệu quả vì Docker sẽ lưu trữ (cache) các lớp; khi bạn xây dựng lại image, chỉ những lớp đã thay đổi kể từ lần xây dựng trước mới được tạo lại, giúp quá trình xây dựng nhanh hơn đáng kể.1\nVolumes: Lưu trữ dữ liệu bền bỉ\nBản chất của container là tạm thời (ephemeral). Khi một container bị xóa, lớp ghi của nó cũng bị xóa theo, và mọi dữ liệu được tạo ra trong đó sẽ bị mất vĩnh viễn.14 Đối với các ứng dụng cần lưu trữ dữ liệu lâu dài (ứng dụng có trạng thái - stateful), chẳng hạn như cơ sở dữ liệu hoặc hệ thống quản lý nội dung, điều này là không thể chấp nhận được.\nVolumes là giải pháp của Docker cho vấn đề này. Chúng là một cơ chế lưu trữ bền bỉ được quản lý hoàn toàn bởi Docker và tồn tại độc lập với vòng đời của bất kỳ container nào.14 Dữ liệu trong một volume có thể được chia sẻ giữa nhiều container và vẫn tồn tại ngay cả khi tất cả các container sử dụng nó đã bị xóa. Đây là phương pháp được khuyến nghị để xử lý dữ liệu cho các ứng dụng stateful.18\nNetworks: Giao tiếp giữa các Container\nMặc định, các container được cô lập với nhau. Để cho phép chúng giao tiếp, Docker cung cấp một hệ thống mạng ảo mạnh mẽ.19 Khi Docker khởi động, nó tạo ra một số mạng mặc định. Các loại mạng chính bao gồm:\nbridge: Đây là mạng mặc định cho các container. Các container được kết nối với cùng một mạng bridge có thể giao tiếp với nhau bằng tên container của chúng, nhờ vào hệ thống DNS tích hợp của Docker. Chúng được cô lập với các container trên các mạng bridge khác.20 host: Loại bỏ sự cô lập mạng giữa container và máy chủ Docker. Container chia sẻ trực tiếp không gian mạng của máy chủ. Điều này cung cấp hiệu suất mạng tốt hơn nhưng làm mất đi lợi ích của sự cô lập.21 overlay: Được sử dụng để kết nối các container chạy trên nhiều máy chủ Docker khác nhau, tạo thành một mạng ảo duy nhất. Đây là nền tảng cho các công cụ điều phối như Docker Swarm.19 Phần 2: Làm Chủ Docker Command Line (CLI) Giao diện dòng lệnh (CLI) là công cụ chính để tương tác với Docker Daemon. Thay vì chỉ liệt kê các lệnh một cách khô khan, phần này sẽ tổ chức chúng theo các quy trình làm việc (workflow) mà một lập trình viên thường gặp phải hàng ngày, giúp hiểu rõ hơn về bối cảnh và mục đích sử dụng của từng lệnh.\n2.1 Workflow 1: Quản lý Image Quản lý image là bước đầu tiên trong mọi quy trình làm việc với Docker. Đây là quá trình tạo, phân phối và duy trì các “bản thiết kế” cho ứng dụng của bạn.\ndocker build: Lệnh này xây dựng một Docker image từ một Dockerfile và một “bối cảnh” (context). Bối cảnh là tập hợp các tệp tại đường dẫn được chỉ định. Cờ -t (tag) được sử dụng để đặt tên và phiên bản cho image, giúp dễ dàng nhận dạng. Ví dụ: docker build -t my-app:1.0. 22 docker images (hoặc docker image ls): Liệt kê tất cả các image hiện có trên máy cục bộ của bạn, hiển thị thông tin như REPOSITORY, TAG, IMAGE ID, và SIZE.13 docker pull: Tải một image hoặc một kho lưu trữ (repository) từ một registry, mặc định là Docker Hub. Ví dụ: docker pull postgres:15-alpine 25 docker push: Tải một image từ máy cục bộ của bạn lên một registry, cho phép chia sẻ với những người khác hoặc sử dụng trong môi trường production. Ví dụ: docker push your-username/my-app:1.0 25 docker rmi (hoặc docker image rm): Xóa một hoặc nhiều image khỏi máy cục bộ để giải phóng dung lượng đĩa. Ví dụ: docker rmi my-app:1.0 23 docker inspect : Cung cấp thông tin chi tiết, ở cấp độ thấp về một image, bao gồm các lớp của nó và siêu dữ liệu (metadata).28 2.2 Workflow 2: Vòng đời Container Sau khi có image, bước tiếp theo là tạo và quản lý các thực thể chạy của nó—các container.\ndocker run: Đây là lệnh trung tâm, kết hợp việc tạo và khởi chạy một container mới từ một image. Nó có nhiều cờ tùy chọn mạnh mẽ: -d hoặc --detach: Chạy container ở chế độ nền (detached mode) và in ra ID của container.29 -p :: Ánh xạ một cổng trên máy chủ (host) tới một cổng bên trong container, cho phép truy cập ứng dụng từ bên ngoài. Ví dụ: -p 8080:80.30 --name : Gán một tên cụ thể cho container để dễ dàng tham chiếu thay vì sử dụng ID ngẫu nhiên.23 -v :: Gắn một volume hoặc một thư mục từ máy chủ vào container.29 -e =: Thiết lập một biến môi trường bên trong container.23 Ví dụ đầy đủ: docker run -d -p 8080:80 --name webserver -e APP_MODE=production nginx:latest docker ps: Liệt kê tất cả các container đang chạy. Sử dụng cờ -a để hiển thị tất cả các container, bao gồm cả những container đã dừng.6 docker stop : Dừng một hoặc nhiều container đang chạy một cách nhẹ nhàng (gửi tín hiệu SIGTERM).31 docker start : Khởi động lại một hoặc nhiều container đã bị dừng.30 docker restart : Dừng và sau đó khởi động lại một container.30 docker rm : Xóa một hoặc nhiều container đã dừng. Sử dụng cờ -f để buộc xóa một container đang chạy.31 2.3 Workflow 3: Tương tác và Gỡ lỗi Container Khi container đang chạy, bạn thường cần phải “nhìn vào bên trong” để gỡ lỗi hoặc thực hiện các tác vụ quản trị.\ndocker logs : Lấy và hiển thị nhật ký (logs) được tạo ra bởi một container. Cờ -f (follow) rất hữu ích để theo dõi luồng log trong thời gian thực, tương tự như lệnh tail -f trong Linux.22 docker exec -it : Thực thi một lệnh bên trong một container đang chạy. Cờ -it (-i cho interactive và -t cho TTY) cho phép bạn có một phiên làm việc tương tác. Đây là cách phổ biến nhất để “vào” một container. Ví dụ: docker exec -it webserver bash sẽ mở một phiên shell Bash tương tác bên trong container tên là webserver.13 docker stats: Hiển thị một luồng trực tiếp về việc sử dụng tài nguyên (CPU, bộ nhớ, mạng I/O) của các container đang chạy, rất hữu ích để theo dõi hiệu suất.28 2.4 Workflow 4: Dọn dẹp hệ thống Theo thời gian, Docker có thể tích tụ nhiều đối tượng không sử dụng (container đã dừng, image cũ, volume không được gắn), chiếm dụng không gian đĩa.\ndocker system prune: Một lệnh dọn dẹp mạnh mẽ, theo mặc định sẽ xóa tất cả các container đã dừng, các mạng không được sử dụng, các image lơ lửng (dangling images - những image không có tag và không được container nào sử dụng), và build cache.22 docker system prune -a: Mở rộng việc dọn dẹp để xóa tất cả các image không được sử dụng (không chỉ là dangling). docker system prune --volumes: Bao gồm cả việc xóa các volume không được sử dụng. Bảng tra cứu nhanh các lệnh Docker CLI thiết yếu Bảng dưới đây tóm tắt các lệnh Docker CLI quan trọng nhất để tham khảo nhanh.\nLệnh Mô tả Ví dụ sử dụng docker build Xây dựng một image từ một Dockerfile. docker build -t my-app:latest. docker run Tạo và khởi chạy một container mới từ một image. docker run -d -p 80:80 --name web nginx docker ps Liệt kê các container đang chạy. Sử dụng -a để liệt kê tất cả. docker ps -a docker stop Dừng một container đang chạy. docker stop web docker rm Xóa một container đã dừng. docker rm web docker images Liệt kê các image trên máy. docker images docker rmi Xóa một image. docker rmi nginx docker pull Tải một image từ registry. docker pull ubuntu:22.04 docker push Đẩy một image lên registry. docker push my-username/my-app docker exec Chạy một lệnh bên trong một container đang chạy. docker exec -it web bash docker logs Xem nhật ký của một container. Sử dụng -f để theo dõi. docker logs -f web docker system prune Dọn dẹp các container, network và image không sử dụng. docker system prune -a --volumes Phần 3: Điều phối Ứng dụng với Docker Compose Khi các ứng dụng trở nên phức tạp hơn, chúng thường bao gồm nhiều thành phần phụ thuộc lẫn nhau—một máy chủ web, một API backend, một cơ sở dữ liệu, một hàng đợi tin nhắn, v.v. Việc quản lý từng container riêng lẻ bằng các lệnh docker run dài dòng và phức tạp trở nên không thực tế và dễ gây ra lỗi.33\nĐây là lúc Docker Compose tỏa sáng. Docker Compose là một công cụ cho phép định nghĩa và chạy các ứng dụng Docker đa container một cách dễ dàng.35 Với Compose, bạn sử dụng một tệp YAML duy nhất (thường là\ndocker-compose.yml) để cấu hình tất cả các dịch vụ, mạng và volume của ứng dụng. Sau đó, chỉ với một lệnh duy nhất, bạn có thể khởi động hoặc gỡ bỏ toàn bộ hệ thống.37\n3.1 Cấu trúc của tệp docker-compose.yml Tệp docker-compose.yml là trung tâm của việc quản lý ứng dụng với Compose. Nó có cấu trúc khai báo, nghĩa là bạn mô tả “trạng thái mong muốn” của hệ thống, và Compose sẽ thực hiện các bước cần thiết để đạt được trạng thái đó. Các thành phần chính bao gồm:\nservices: Đây là khối chính, nơi bạn định nghĩa mỗi thành phần của ứng dụng như một “dịch vụ”. Mỗi dịch vụ tương ứng với một hoặc nhiều container chạy cùng một image.37 image: :: Chỉ định image Docker sẽ được sử dụng để tạo container cho dịch vụ này. Compose sẽ tìm image này trên máy cục bộ hoặc tải về từ Docker Hub.39 build: : Thay vì sử dụng một image có sẵn, bạn có thể yêu cầu Compose xây dựng một image tại chỗ từ một Dockerfile. Giá trị này là đường dẫn đến thư mục chứa Dockerfile (ví dụ: build:.).39 ports: - \":\": Ánh xạ cổng giữa máy chủ và container, tương tự cờ -p trong docker run.38 volumes: - :: Gắn một volume hoặc một thư mục từ máy chủ vào container. Đây là cách để lưu trữ dữ liệu bền bỉ hoặc chia sẻ tệp giữa máy chủ và container.40 environment: - =: Thiết lập các biến môi trường bên trong container. Đây là cách phổ biến để truyền các thông tin cấu hình như thông tin đăng nhập cơ sở dữ liệu, khóa API, v.v..38 networks: - : Kết nối dịch vụ vào một hoặc nhiều mạng được định nghĩa. Compose tự động tạo một mạng mặc định cho tất cả các dịch vụ trong tệp, nhưng việc định nghĩa mạng tùy chỉnh mang lại sự kiểm soát tốt hơn.39 depends_on: - : Xác định sự phụ thuộc giữa các dịch vụ. Ví dụ, bạn có thể yêu cầu dịch vụ web chỉ khởi động sau khi dịch vụ cơ sở dữ liệu đã khởi động.38 volumes (cấp cao nhất): Nơi bạn định nghĩa các “named volumes”. Việc khai báo chúng ở đây cho phép chúng được tái sử dụng và quản lý dễ dàng bởi Compose.39 networks (cấp cao nhất): Nơi bạn định nghĩa các mạng tùy chỉnh. Điều này cho phép bạn tạo ra các cấu trúc liên kết mạng phức tạp hơn và cô lập các nhóm dịch vụ.39 3.2 Từ docker run đến docker-compose.yml Để làm rõ mối liên hệ giữa CLI và Compose, bảng dưới đây sẽ ánh xạ các cờ phổ biến của lệnh docker run sang các khóa tương đương trong tệp docker-compose.yml. Việc hiểu rõ sự tương ứng này giúp quá trình chuyển đổi từ việc quản lý container đơn lẻ sang điều phối toàn bộ ứng dụng trở nên trực quan hơn. Nó cho thấy docker-compose.yml không phải là một ngôn ngữ hoàn toàn mới, mà là một cách khai báo, có cấu trúc để thể hiện những cấu hình tương tự.\nCờ docker run Khóa docker-compose.yml Ví dụ -d (Mặc định khi dùng up -d) docker compose up -d -p 8080:80 ports ports: [\"8080:80\"] -v my-data:/data volumes volumes: [\"my-data:/data\"] -e VAR=value environment environment: --name my-app container_name container_name: my-app --network my-net networks networks: [\"my-net\"] --restart=always restart restart: always 3.3 Các lệnh Docker Compose cốt lõi Sau khi đã định nghĩa ứng dụng trong tệp docker-compose.yml, bạn sử dụng một vài lệnh đơn giản để quản lý toàn bộ vòng đời của nó.\ndocker compose up: Lệnh này là trái tim của Compose. Nó đọc tệp docker-compose.yml, xây dựng các image cần thiết, tạo và khởi chạy tất cả các container dịch vụ, và tạo các network và volume tương ứng. Nếu không có cờ -d, nó sẽ chạy ở chế độ foreground và hiển thị log tổng hợp từ tất cả các container.34 docker compose up -d: Chạy ứng dụng ở chế độ nền (detached). Đây là cách sử dụng phổ biến nhất trong môi trường phát triển và sản xuất. docker compose down: Lệnh này là đối nghịch của up. Nó sẽ dừng và xóa tất cả các container, cùng với các network được tạo bởi Compose. docker compose down --volumes: Thêm cờ này để xóa cả các named volumes đã được định nghĩa trong tệp Compose. Hãy cẩn thận vì điều này sẽ xóa vĩnh viễn dữ liệu.41 docker compose build: Nếu bạn đã thay đổi Dockerfile của một dịch vụ, lệnh này sẽ buộc xây dựng lại image cho dịch vụ đó trước khi chạy up.37 docker compose logs: Hiển thị log từ các container dịch vụ. docker compose logs -f : Theo dõi log của một dịch vụ cụ thể trong thời gian thực.41 docker compose exec : Thực thi một lệnh bên trong một container của một dịch vụ đang chạy. Rất hữu ích để chạy các tác vụ quản trị hoặc mở một shell để gỡ lỗi. Ví dụ: docker compose exec web sh Phần 4: Hướng dẫn Thực hành: Container hóa Ứng dụng Dịch vụ đơn Lý thuyết là nền tảng, nhưng thực hành mới là cách tốt nhất để củng cố kiến thức. Phần này cung cấp các hướng dẫn từng bước để container hóa các ứng dụng đơn giản được viết bằng Go, Node.js và Python, ba trong số các ngôn ngữ phổ biến nhất trong phát triển web hiện đại.\n4.1 Ví dụ 1: Máy chủ Web Go nhẹ Go nổi tiếng với việc biên dịch ra các tệp nhị phân tĩnh, độc lập, rất phù hợp với container. Chúng ta sẽ tận dụng tính năng multi-stage build của Docker để tạo ra một image production siêu nhỏ.\nMã nguồn (main.go) Tạo một tệp main.go với nội dung sau. Đây là một máy chủ web đơn giản lắng nghe trên cổng 8080.\nGo\npackage main import ( \"fmt\" \"log\" \"net/http\" ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Hello from Go in a Docker Container!\") } func main() { http.HandleFunc(\"/\", handler) log.Println(\"Go web server starting on port 8080\") log.Fatal(http.ListenAndServe(\":8080\", nil)) } Dockerfile Tạo một tệp tên là Dockerfile (không có phần mở rộng) với nội dung sau:\nDockerfile\n# Stage 1: Build the application FROM golang:1.21-alpine AS builder # Set the Current Working Directory inside the container WORKDIR /app # Copy go mod and sum files COPY go.mod go.sum./ # Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed RUN go mod download # Copy the source code COPY.. # Build the Go app # CGO_ENABLED=0 is for static builds # -o /go-app builds the executable to /go-app RUN CGO_ENABLED=0 GOOS=linux go build -o /go-app. # Stage 2: Create the final, lightweight image FROM alpine:latest # Copy the pre-built binary file from the previous stage COPY --from=builder /go-app /go-app # Expose port 8080 to the outside world EXPOSE 8080 # Command to run the executable CMD [\"/go-app\"] Giải thích Dockerfile:\nStage 1 (builder): Chúng ta bắt đầu với image golang:1.21-alpine, chứa tất cả các công cụ cần thiết để biên dịch mã Go. Chúng ta sao chép mã nguồn và biên dịch nó thành một tệp nhị phân tĩnh duy nhất tại /go-app.36 Stage 2 (final): Chúng ta bắt đầu lại với một image alpine:latest siêu nhẹ. Sau đó, chúng ta chỉ sao chép tệp nhị phân đã được biên dịch từ stage builder vào image cuối cùng này. Kết quả là một image production chỉ chứa ứng dụng của bạn và không có bất kỳ công cụ build nào.43 Xây dựng và Chạy Trước tiên, khởi tạo Go module:\nBash\ngo mod init go-webapp Bây giờ, xây dựng image và chạy container:\nBash\n# Build the Docker image docker build -t go-webapp. # Run the container, mapping port 8080 on the host to 8080 in the container docker run -p 8080:8080 go-webapp Mở trình duyệt và truy cập http://localhost:8080 để thấy thông điệp của bạn.\n4.2 Ví dụ 2: API Node.js \u0026 Express năng động Node.js là một lựa chọn phổ biến cho các API. Quy trình làm việc với Docker cho Node.js tập trung vào việc quản lý các dependencies npm một cách hiệu quả.\nMã nguồn và Dependencies Tạo một thư mục dự án và khởi tạo một dự án Node.js:\nBash\nmkdir node-api \u0026\u0026 cd node-api npm init -y npm install express Tạo một tệp app.js:\nJavaScript\nconst express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) =\u003e { res.send('Hello from Node.js \u0026 Express in a Docker Container!'); }); app.listen(port, () =\u003e { console.log(`Node.js API listening on port ${port}`); }); Dockerfile Tạo một tệp Dockerfile:\nDockerfile\n# Use an official Node.js runtime as a parent image FROM node:18-alpine # Set the working directory in the container WORKDIR /usr/src/app # Copy package.json and package-lock.json # This is done separately to take advantage of Docker's layer caching. # The npm install step will only be re-run if these files change. COPY package*.json./ # Install app dependencies RUN npm install # Bundle app source COPY.. # Expose the port the app runs on EXPOSE 3000 # Define the command to run the app CMD [ \"node\", \"app.js\" ] Giải thích Dockerfile:\nChúng ta sao chép package*.json và chạy npm install trước khi sao chép phần còn lại của mã nguồn. Đây là một kỹ thuật tối ưu hóa quan trọng. Vì các dependencies ít thay đổi hơn mã nguồn, Docker có thể tái sử dụng lớp (layer) đã được cache của npm install, giúp các lần build sau nhanh hơn đáng kể.44 3. Xây dựng và Chạy\nBash\n# Build the Docker image docker build -t node-api. # Run the container, mapping port 3000 to 3000 docker run -p 3000:3000 node-api Truy cập http://localhost:3000 trên trình duyệt của bạn.\n4.3 Ví dụ 3: Ứng dụng Python \u0026 FastAPI hướng dữ liệu FastAPI là một framework Python hiện đại để xây dựng API. Tương tự như Node.js, việc quản lý dependencies là chìa khóa.\nMã nguồn và Dependencies Tạo một thư mục dự án. Bên trong, tạo tệp requirements.txt:\nfastapi uvicorn[standard] Tạo tệp main.py:\nPython\nfrom fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read_root(): return {\"message\": \"Hello from Python \u0026 FastAPI in a Docker Container!\"} Dockerfile Tạo một tệp Dockerfile:\nDockerfile\n# Use an official Python runtime as a parent image FROM python:3.11-slim # Set the working directory in the container WORKDIR /code # Copy the dependencies file to the working directory COPY requirements.txt. # Install any needed packages specified in requirements.txt RUN pip install --no-cache-dir -r requirements.txt # Copy the current directory contents into the container at /code COPY.. # Expose port 8000 EXPOSE 8000 # Run uvicorn server when the container launches CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"] Giải thích Dockerfile:\nQuy trình này tương tự như ví dụ Node.js. Chúng ta cài đặt các dependencies từ requirements.txt trước, sau đó sao chép mã nguồn để tận dụng cơ chế cache của Docker.46 Chúng ta sử dụng python:3.11-slim làm image cơ sở, đây là một biến thể nhỏ gọn hơn so với image mặc định, giúp giảm kích thước image cuối cùng. 3. Xây dựng và Chạy\nBash\n# Build the Docker image docker build -t python-api. # Run the container, mapping port 8000 to 8000 docker run -p 8000:8000 python-api Truy cập http://localhost:8000 để xem kết quả.\nPhần 5: Triển khai Full-Stack: WordPress với PostgreSQL bằng Docker Compose Đây là phần tổng hợp, nơi chúng ta sẽ áp dụng tất cả các kiến thức đã học để triển khai một ứng dụng web hoàn chỉnh và thực tế: một trang web WordPress được hỗ trợ bởi cơ sở dữ liệu PostgreSQL. Ví dụ này thể hiện sức mạnh thực sự của Docker Compose trong việc điều phối nhiều dịch vụ phụ thuộc lẫn nhau. Đáng chú ý, chúng ta sẽ sử dụng PostgreSQL theo yêu cầu cụ thể, một lựa chọn ít phổ biến hơn so với MySQL/MariaDB trong các hướng dẫn WordPress thông thường, nhưng hoàn toàn khả thi và mạnh mẽ.48\n5.1 Kiến trúc ứng dụng Hệ thống của chúng ta sẽ bao gồm các thành phần sau, tất cả được định nghĩa và kết nối trong một tệp docker-compose.yml duy nhất:\nDịch vụ 1 (db): Một container chạy PostgreSQL, sử dụng image chính thức postgres:15-alpine. Đây sẽ là nơi lưu trữ tất cả nội dung của trang WordPress (bài viết, trang, người dùng, v.v.). Dịch vụ 2 (wordpress): Một container chạy WordPress, sử dụng image chính thức wordpress:latest. Dịch vụ này sẽ chứa máy chủ web (Apache) và PHP để chạy ứng dụng WordPress. Volume 1 (db_data): Một named volume để lưu trữ dữ liệu của PostgreSQL. Điều này đảm bảo rằng cơ sở dữ liệu của bạn sẽ tồn tại ngay cả khi container db bị xóa và tạo lại. Volume 2 (wp_content): Một named volume để lưu trữ các tệp của WordPress, bao gồm themes, plugins và các tệp được tải lên. Điều này cho phép bạn cập nhật phiên bản WordPress mà không làm mất các tùy chỉnh và nội dung của mình. Network (app_net): Một mạng bridge tùy chỉnh để hai dịch vụ có thể giao tiếp với nhau một cách an toàn và đáng tin cậy, tách biệt với các container khác có thể đang chạy trên cùng một máy chủ. Việc sử dụng một tệp docker-compose.yml để định nghĩa toàn bộ kiến trúc này biến nó thành một dạng “cơ sở hạ tầng dưới dạng mã” (Infrastructure as Code). Tệp này trở thành nguồn chân lý duy nhất cho toàn bộ ứng dụng, có thể được quản lý phiên bản trong Git, chia sẻ với các thành viên trong nhóm và đảm bảo rằng mọi người đều có thể khởi tạo một môi trường giống hệt nhau chỉ bằng một lệnh duy nhất, giúp cải thiện đáng kể quá trình giới thiệu thành viên mới và tính nhất quán.37\n5.2 Phân tích chi tiết docker-compose.yml Tạo một thư mục cho dự án của bạn, ví dụ my-wordpress-site. Bên trong thư mục đó, tạo một tệp có tên docker-compose.yml với nội dung sau:\nYAML\nversion: '3.8' services: db: image: postgres:15-alpine container_name: wordpress_db volumes: - db_data:/var/lib/postgresql/data environment: POSTGRES_DB: ${POSTGRES_DB} POSTGRES_USER: ${POSTGRES_USER} POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} restart: always networks: - app_net wordpress: depends_on: - db image: wordpress:latest container_name: wordpress_app ports: - \"8000:80\" volumes: - wp_content:/var/www/html environment: WORDPRESS_DB_HOST: db:5432 WORDPRESS_DB_USER: ${POSTGRES_USER} WORDPRESS_DB_PASSWORD: ${POSTGRES_PASSWORD} WORDPRESS_DB_NAME: ${POSTGRES_DB} restart: always networks: - app_net volumes: db_data: wp_content: networks: app_net: driver: bridge Giải thích chi tiết:\nservices:: Định nghĩa hai dịch vụ của chúng ta là db và wordpress. db service: image: postgres:15-alpine: Sử dụng phiên bản 15 của PostgreSQL trên nền Alpine Linux để có kích thước nhỏ. volumes: - db_data:/var/lib/postgresql/data: Ánh xạ named volume db_data vào thư mục dữ liệu mặc định của PostgreSQL bên trong container. environment:: Cấu hình cơ sở dữ liệu. Các giá trị ${...} sẽ được Docker Compose thay thế bằng các biến môi trường từ một tệp .env hoặc từ shell, một thực tiễn tốt để giữ bí mật an toàn. restart: always: Tự động khởi động lại container này nếu nó bị dừng. networks: - app_net: Kết nối dịch vụ này vào mạng app_net. wordpress service: depends_on: - db: Yêu cầu Compose khởi động dịch vụ db trước dịch vụ wordpress. ports: - \"8000:80\": Ánh xạ cổng 8000 trên máy chủ của bạn tới cổng 80 (cổng web mặc định) bên trong container WordPress. volumes: - wp_content:/var/www/html: Ánh xạ named volume wp_content vào thư mục gốc của WordPress. environment:: Cung cấp cho WordPress thông tin cần thiết để kết nối với cơ sở dữ liệu. Lưu ý WORDPRESS_DB_HOST: db:5432. Ở đây, db là tên của dịch vụ cơ sở dữ liệu, và Docker Compose sẽ đảm bảo rằng tên này được phân giải thành địa chỉ IP nội bộ của container db trên mạng app_net. volumes: (cấp cao nhất): Khai báo hai named volumes db_data và wp_content để Docker quản lý. networks: (cấp cao nhất): Khai báo mạng tùy chỉnh app_net sử dụng driver bridge mặc định. 5.3 Triển khai và Quản lý Tạo tệp Biến môi trường (.env) Trong cùng thư mục với docker-compose.yml, tạo một tệp tên là .env. Tệp này sẽ chứa các thông tin nhạy cảm. Docker Compose sẽ tự động đọc tệp này.\nLưu ý: Hãy thêm .env vào tệp .gitignore của bạn để không vô tình đưa thông tin đăng nhập vào kho mã nguồn.\nCode snippet\n#.env file # PostgreSQL Credentials POSTGRES_DB=wordpress POSTGRES_USER=wp_user POSTGRES_PASSWORD=your_strong_password Thay your_strong_password bằng một mật khẩu mạnh và an toàn.\nKhởi động hệ thống Mở terminal trong thư mục dự án và chạy lệnh sau:\nBash\ndocker compose up -d Docker Compose sẽ:\nTải về các image postgres:15-alpine và wordpress:latest nếu chúng chưa có trên máy. Tạo mạng app_net. Tạo các volume db_data và wp_content. Khởi động container db trước. Sau đó, khởi động container wordpress. Tất cả sẽ chạy ở chế độ nền (-d). Bạn có thể kiểm tra trạng thái của các container bằng lệnh docker compose ps.\nHoàn tất cài đặt WordPress Mở trình duyệt web và truy cập http://localhost:8000. Bạn sẽ thấy màn hình cài đặt WordPress quen thuộc.48 Hãy làm theo các bước để chọn ngôn ngữ, đặt tên trang web, tạo tài khoản quản trị viên. Tất cả thông tin này sẽ được lưu trữ trong cơ sở dữ liệu PostgreSQL đang chạy trong container\ndb.\nDừng và Dọn dẹp Khi bạn muốn dừng ứng dụng, hãy chạy:\nBash\ndocker compose down Lệnh này sẽ dừng và xóa các container và mạng. Tuy nhiên, các volume (db_data và wp_content) sẽ vẫn còn. Điều này có nghĩa là nếu bạn chạy lại docker compose up -d, trang web của bạn sẽ trở lại với tất cả dữ liệu và tệp tin còn nguyên vẹn.\nĐể xóa mọi thứ, bao gồm cả dữ liệu, hãy chạy:\nBash\ndocker compose down --volumes Phần 6: Các Thực tiễn Tốt nhất cho Môi trường Production Việc đưa các ứng dụng container hóa vào môi trường production đòi hỏi một mức độ cẩn trọng và tối ưu hóa cao hơn so với môi trường phát triển. Phần này sẽ cung cấp các thực tiễn tốt nhất, giúp bạn xây dựng các image nhỏ gọn, an toàn và các tệp Compose có khả năng bảo trì cao, sẵn sàng cho việc triển khai thực tế.\n6.1 Tối ưu hóa Kích thước và Tốc độ: Multi-Stage Builds Một trong những vấn đề phổ biến nhất với các Docker image là chúng trở nên cồng kềnh. Một image lớn không chỉ chiếm nhiều dung lượng lưu trữ mà còn làm tăng thời gian tải về và triển khai. Tệ hơn nữa, nó thường chứa các công cụ xây dựng (như JDK, Go toolchain, build-essentials) và các dependencies chỉ cần thiết cho quá trình biên dịch, không cần thiết cho việc chạy ứng dụng. Những thành phần thừa này làm tăng bề mặt tấn công của image một cách không cần thiết.51\nMulti-stage builds là một tính năng mạnh mẽ của Docker để giải quyết vấn đề này.53 Kỹ thuật này cho phép bạn sử dụng nhiều lệnh\nFROM trong cùng một Dockerfile. Mỗi lệnh FROM bắt đầu một “stage” (giai đoạn) xây dựng mới.\nCách hoạt động rất đơn giản và hiệu quả:\nStage 1 (Build Stage): Bạn sử dụng một image cơ sở đầy đủ (ví dụ: golang:1.21) có tất cả các công cụ cần thiết để biên dịch, kiểm thử và đóng gói ứng dụng của bạn. Giai đoạn này được đặt tên (ví dụ: AS builder). Stage 2 (Final Stage): Bạn bắt đầu một giai đoạn mới với một image cơ sở tối giản (ví dụ: alpine:latest hoặc thậm chí scratch—một image trống). Copy Artifacts: Bạn sử dụng lệnh COPY --from=builder để sao chép chỉ những tạo tác (artifacts) cần thiết—chẳng hạn như tệp nhị phân đã biên dịch hoặc các tệp đã được thu nhỏ—từ giai đoạn xây dựng vào giai đoạn cuối cùng.55 Ví dụ với ứng dụng Go từ Phần 4 đã minh họa hoàn hảo điều này. Image cuối cùng chỉ chứa tệp nhị phân thực thi và image Alpine cơ sở, giảm kích thước từ hàng trăm MB xuống chỉ còn vài MB.\n6.2 Tăng cường Bảo mật Bảo mật là yếu tố không thể bỏ qua khi triển khai. Dockerfile của bạn là tuyến phòng thủ đầu tiên.\nChạy với người dùng không phải root: Mặc định, các container chạy với người dùng root, điều này tạo ra một rủi ro bảo mật nghiêm trọng. Nếu một kẻ tấn công khai thác được một lỗ hổng trong ứng dụng của bạn và thoát ra khỏi container, chúng có thể có quyền root trên máy chủ. Hãy luôn tạo một người dùng và nhóm không có đặc quyền bên trong Dockerfile và sử dụng lệnh USER để chuyển sang người dùng đó trước khi chạy ứng dụng.56 Dockerfile\n# Create a non-root user RUN addgroup -S appgroup \u0026\u0026 adduser -S appuser -G appgroup #... copy files and set permissions... RUN chown -R appuser:appgroup /app # Switch to the non-root user USER appuser CMD [\"/app/my-binary\"] Chọn base image tối giản: Nguyên tắc là “càng ít càng tốt”. Một image cơ sở tối giản như alpine, distroless, hoặc scratch chứa ít thành phần hơn, đồng nghĩa với việc có ít lỗ hổng tiềm tàng hơn và bề mặt tấn công nhỏ hơn.53\nSử dụng .dockerignore: Tương tự như .gitignore, tệp .dockerignore ngăn chặn các tệp và thư mục không cần thiết (như .git, node_modules, các tệp log cục bộ, tệp bí mật) được gửi đến Docker daemon trong quá trình xây dựng. Điều này không chỉ giúp image nhỏ hơn mà còn ngăn chặn việc vô tình rò rỉ thông tin nhạy cảm vào image.57\n6.3 Quản lý các file Compose có thể bảo trì Khi dự án phát triển, việc quản lý cấu hình cho các môi trường khác nhau (phát triển, kiểm thử, sản xuất) trở nên quan trọng.\nSử dụng biến môi trường và tệp .env: Không bao giờ ghi cứng các giá trị nhạy cảm như mật khẩu, khóa API, hoặc thông tin đăng nhập cơ sở dữ liệu trực tiếp vào tệp docker-compose.yml. Thay vào đó, hãy tham chiếu chúng dưới dạng biến môi trường. Docker Compose sẽ tự động tải các biến từ một tệp .env trong cùng thư mục. Tệp .env này nên được thêm vào .gitignore để đảm bảo nó không được đưa vào hệ thống quản lý phiên bản.58 Trong docker-compose.yml: YAML environment: - DB_PASSWORD=${POSTGRES_PASSWORD} Trong tệp .env: Code snippet POSTGRES_PASSWORD=supersecret Quản lý các môi trường khác nhau (Dev vs. Prod): Thay vì duy trì nhiều tệp Compose gần như giống hệt nhau, hãy sử dụng một tệp docker-compose.yml cơ sở cho các cấu hình chung và một tệp docker-compose.override.yml cho các cấu hình dành riêng cho môi trường phát triển. Docker Compose tự động đọc và hợp nhất cả hai tệp này. docker-compose.yml (cơ sở, cho production): YAML services: web: image: my-app:latest ports: [\"80:8000\"] docker-compose.override.yml (cho development, không commit vào Git): YAML ` services: web: build:. volumes: -.:/app # Mount source code for live reload ports: “8000:8000” command: npm run dev Khi bạn chạydocker compose up, Compose sẽ hợp nhất hai tệp này, tạo ra một cấu hình phát triển hoàn chỉnh. Trong môi trường production, bạn chỉ cần triển khai tệp docker-compose.yml` cơ sở.58 Conclusion: Tích hợp Container hóa vào Quy trình làm việc của bạn Hành trình qua thế giới Docker và Docker Compose đã trang bị cho các lập trình viên một bộ công cụ mạnh mẽ để hiện đại hóa quy trình phát triển và triển khai phần mềm. Chúng ta đã đi từ việc tìm hiểu các khái niệm nền tảng—sự khác biệt cốt lõi giữa image và container, tầm quan trọng của volume và network—đến việc làm chủ các lệnh CLI thiết yếu để quản lý vòng đời của chúng.\nThông qua các ví dụ thực tế với Go, Node.js và Python, chúng ta đã thấy cách áp dụng các nguyên tắc này để đóng gói các ứng dụng dịch vụ đơn một cách hiệu quả. Đỉnh cao là việc triển khai một ứng dụng web full-stack, WordPress với PostgreSQL, đã chứng minh sức mạnh của Docker Compose trong việc điều phối các hệ thống phức tạp, đa thành phần chỉ bằng một tệp cấu hình khai báo duy nhất.\nCuối cùng, việc áp dụng các thực tiễn tốt nhất—như multi-stage builds để tối ưu hóa image, các biện pháp bảo mật để làm cứng container, và các chiến lược quản lý tệp Compose để xử lý các môi trường khác nhau—nâng cao kỹ năng từ mức độ “biết dùng” lên “làm chủ”.\nDocker và Docker Compose là những công cụ không thể thiếu trong bộ công cụ của một lập trình viên hiện đại. Chúng là bước đệm hoàn hảo để hiểu sâu hơn về kiến trúc microservices và là nền tảng vững chắc trước khi tiến vào thế giới điều phối ở quy mô lớn hơn như Kubernetes.62 Bằng cách tích hợp container hóa vào quy trình làm việc hàng ngày, các nhóm phát triển có thể đạt được tốc độ, tính nhất quán và hiệu quả cao hơn bao giờ hết, cho phép họ tập trung vào điều quan trọng nhất: xây dựng những sản phẩm tuyệt vời.\n","wordCount":"6992","inLanguage":"en","image":"https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-12T00:00:00Z","dateModified":"2025-08-12T00:00:00Z","author":{"@type":"Person","name":"Nagih"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nagih.io.vn/posts/docker/docker.sync-conflict-20250821-125726-izlhqhs/"},"publisher":{"@type":"Organization","name":"Nagih | Blog","logo":{"@type":"ImageObject","url":"https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nagih.io.vn/ accesskey=h title="Home (Alt + H)"><img src=https://blog.nagih.io.vn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.nagih.io.vn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nagih.io.vn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nagih.io.vn/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.nagih.io.vn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://nagih.io.vn title=Home><span>Home</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nagih.io.vn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.nagih.io.vn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Docker Overview</h1><div class=post-meta><span title='2025-08-12 00:00:00 +0000 UTC'>August 12, 2025</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;6992 words&nbsp;·&nbsp;Nagih&nbsp;|&nbsp;<a href=https://github.com/vuongmanhnghia/posts/content/posts/docker/Docker.sync-conflict-20250821-125726-IZLHQHS.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Tổng hợp các kiến thức cần biết về Docker</p><h2 id=phần-1-cuộc-cách-mạng-container---thấu-hiểu-các-nguyên-tắc-cốt-lõi-của-docker>Phần 1: Cuộc Cách Mạng Container - Thấu Hiểu Các Nguyên Tắc Cốt Lõi của Docker<a hidden class=anchor aria-hidden=true href=#phần-1-cuộc-cách-mạng-container---thấu-hiểu-các-nguyên-tắc-cốt-lõi-của-docker>#</a></h2><h3 id=11-giới-thiệu-về-docker-tại-sao-lại-là-một-cuộc-cách-mạng>1.1 Giới thiệu về Docker: Tại sao lại là một cuộc cách mạng?<a hidden class=anchor aria-hidden=true href=#11-giới-thiệu-về-docker-tại-sao-lại-là-một-cuộc-cách-mạng>#</a></h3><p>Trong thế giới phát triển phần mềm hiện đại, Docker đã nổi lên như một công nghệ nền tảng, thay đổi cách các lập trình viên xây dựng, vận chuyển và chạy ứng dụng. Về cơ bản, Docker là một nền tảng mã nguồn mở được thiết kế để tự động hóa việc triển khai ứng dụng bên trong các môi trường biệt lập, nhẹ được gọi là container.1 Mỗi container đóng gói phần mềm cùng với tất cả những gì nó cần để hoạt động—bao gồm thư viện, công cụ hệ thống, mã nguồn và thời gian chạy (runtime)—thành một đơn vị tiêu chuẩn hóa.3</p><p>Để hiểu rõ giá trị của Docker, điều quan trọng là phải phân biệt nó với công nghệ ảo hóa truyền thống: máy ảo (Virtual Machines - VMs).</p><ul><li><strong>Máy ảo (VMs):</strong> Một máy ảo ảo hóa toàn bộ phần cứng vật lý, cho phép nhiều hệ điều hành khách (guest OS) chạy trên một máy chủ chủ (host server) duy nhất. Mỗi VM bao gồm một bản sao đầy đủ của một hệ điều hành, các tệp nhị phân và thư viện cần thiết, và chính ứng dụng. Điều này dẫn đến sự cô lập mạnh mẽ nhưng phải trả giá bằng việc tiêu tốn tài nguyên đáng kể, kích thước lớn (hàng gigabyte) và thời gian khởi động chậm.4</li><li><strong>Containers:</strong> Ngược lại, container ảo hóa ở cấp độ hệ điều hành. Thay vì đóng gói cả một hệ điều hành khách, các container chia sẻ nhân (kernel) của hệ điều hành máy chủ.6 Chúng chỉ đóng gói ứng dụng và các dependencies của nó. Kết quả là các container cực kỳ nhẹ (thường chỉ vài chục megabyte), khởi động gần như tức thì và cho phép mật độ ứng dụng cao hơn nhiều trên cùng một phần cứng.5</li></ul><p>Sự thay đổi mô hình này mang lại những lợi ích to lớn, định hình lại toàn bộ vòng đời phát triển phần mềm:</p><ul><li><strong>Phân phối ứng dụng nhanh chóng, nhất quán:</strong> Docker giải quyết triệt để vấn đề kinh điển &ldquo;nó chạy trên máy tôi nhưng không chạy trên production&rdquo;. Bằng cách đóng gói ứng dụng và môi trường của nó lại với nhau, Docker đảm bảo tính nhất quán trên các môi trường phát triển, kiểm thử và sản xuất.8</li><li><strong>Tính di động (Portability) vượt trội:</strong> Một container được xây dựng trên máy tính xách tay của lập trình viên có thể chạy không thay đổi trên bất kỳ hệ thống nào có cài đặt Docker, cho dù đó là máy chủ vật lý tại chỗ, máy ảo trên đám mây hay trong một môi trường lai.1</li><li><strong>Hiệu quả và Tiết kiệm chi phí:</strong> Vì các container nhẹ hơn nhiều so với VM, chúng cho phép chạy nhiều ứng dụng hơn trên cùng một cơ sở hạ tầng. Điều này cải thiện đáng kể việc sử dụng tài nguyên và giúp tiết kiệm chi phí phần cứng và cấp phép.3</li><li><strong>Tăng tốc quy trình phát triển (CI/CD):</strong> Docker tích hợp liền mạch vào các quy trình Tích hợp liên tục và Triển khai liên tục (CI/CD). Các image container có thể được xây dựng, kiểm thử và đẩy lên registry một cách tự động, giúp tăng tốc độ phát hành phần mềm một cách đáng kể.1</li></ul><p>Sự phổ biến của Docker không chỉ là một thành tựu kỹ thuật; nó là chất xúc tác trực tiếp cho văn hóa DevOps. Các lợi ích kỹ thuật như môi trường chuẩn hóa 1 và tính di động 8 đã cung cấp cơ chế thực tế để thực hiện các nguyên lý cốt lõi của DevOps: phá vỡ các rào cản giữa phát triển (Dev) và vận hành (Ops), tự động hóa các quy trình, và tăng tần suất triển khai. Docker không chỉ tạo ra một công cụ mới; nó đã biến DevOps từ một triết lý thành một thực tiễn khả thi cho hàng triệu lập trình viên trên toàn thế giới.7</p><h3 id=12-hệ-sinh-thái-docker-các-thành-phần-cơ-bản>1.2 Hệ sinh thái Docker: Các Thành phần Cơ bản<a hidden class=anchor aria-hidden=true href=#12-hệ-sinh-thái-docker-các-thành-phần-cơ-bản>#</a></h3><p>Để làm việc hiệu quả với Docker, việc nắm vững các khái niệm và thành phần cốt lõi của nó là điều bắt buộc.</p><p>Kiến trúc Docker</p><p>Docker hoạt động theo kiến trúc client-server. Thành phần chính bao gồm:</p><ul><li><strong>Docker Daemon (<code>dockerd</code>):</strong> Một dịch vụ nền chạy trên máy chủ, chịu trách nhiệm xây dựng, chạy và quản lý các đối tượng Docker như images, containers, networks và volumes.</li><li><strong>Docker Client (<code>docker</code>):</strong> Công cụ dòng lệnh (CLI) mà người dùng tương tác. Khi một lệnh như <code>docker run</code> được thực thi, client sẽ gửi yêu cầu đến daemon thông qua REST API qua socket UNIX hoặc giao diện mạng.1</li></ul><p>Images và Containers: Bản thiết kế và Thực thể</p><p>Đây là khái niệm cơ bản và quan trọng nhất trong Docker, thường gây nhầm lẫn cho người mới bắt đầu. Một phép ẩn dụ hữu ích là xem Image như một Class trong lập trình hướng đối tượng và Container như một Instance của class đó.10</p><ul><li><strong>Image:</strong> Một Docker image là một mẫu (template) chỉ đọc (read-only) và bất biến (immutable) chứa một tập hợp các chỉ dẫn để tạo ra một container.11 Nó giống như một bản thiết kế chi tiết, bao gồm mã nguồn ứng dụng, runtime, thư viện, biến môi trường và các tệp cấu hình. Images được xây dựng từ một
<code>Dockerfile</code> và bao gồm một loạt các lớp (layers) xếp chồng lên nhau. Mỗi chỉ thị trong Dockerfile tạo ra một lớp mới. Tính bất biến này chính là nguyên nhân trực tiếp tạo ra khả năng tái tạo và tính nhất quán mà Docker cung cấp; vì image không thể thay đổi, mọi container được khởi tạo từ nó đều được đảm bảo giống hệt nhau, loại bỏ hoàn toàn sự trôi dạt môi trường.4</li><li><strong>Container:</strong> Một Docker container là một thực thể đang chạy (a running instance) của một image.4 Khi Docker tạo một container từ một image, nó sẽ thêm một lớp có thể ghi (writable layer) lên trên các lớp chỉ đọc của image. Bất kỳ thay đổi nào được thực hiện bên trong container—chẳng hạn như tạo tệp mới, sửa đổi cấu hình, hoặc cài đặt phần mềm—đều được ghi vào lớp này. Điều này có nghĩa là nhiều container có thể chia sẻ cùng một image cơ sở trong khi vẫn duy trì trạng thái riêng biệt của chúng.12</li></ul><p>Dockerfile: Công thức để tạo Image</p><p>Dockerfile là một tệp văn bản đơn giản chứa các hướng dẫn từng bước để Docker tự động xây dựng một image.13 Mỗi lệnh (ví dụ:</p><p><code>FROM</code>, <code>COPY</code>, <code>RUN</code>, <code>CMD</code>) trong Dockerfile tương ứng với một lớp trong image. Cấu trúc phân lớp này rất hiệu quả vì Docker sẽ lưu trữ (cache) các lớp; khi bạn xây dựng lại image, chỉ những lớp đã thay đổi kể từ lần xây dựng trước mới được tạo lại, giúp quá trình xây dựng nhanh hơn đáng kể.1</p><p>Volumes: Lưu trữ dữ liệu bền bỉ</p><p>Bản chất của container là tạm thời (ephemeral). Khi một container bị xóa, lớp ghi của nó cũng bị xóa theo, và mọi dữ liệu được tạo ra trong đó sẽ bị mất vĩnh viễn.14 Đối với các ứng dụng cần lưu trữ dữ liệu lâu dài (ứng dụng có trạng thái - stateful), chẳng hạn như cơ sở dữ liệu hoặc hệ thống quản lý nội dung, điều này là không thể chấp nhận được.</p><p><strong>Volumes</strong> là giải pháp của Docker cho vấn đề này. Chúng là một cơ chế lưu trữ bền bỉ được quản lý hoàn toàn bởi Docker và tồn tại độc lập với vòng đời của bất kỳ container nào.14 Dữ liệu trong một volume có thể được chia sẻ giữa nhiều container và vẫn tồn tại ngay cả khi tất cả các container sử dụng nó đã bị xóa. Đây là phương pháp được khuyến nghị để xử lý dữ liệu cho các ứng dụng stateful.18</p><p>Networks: Giao tiếp giữa các Container</p><p>Mặc định, các container được cô lập với nhau. Để cho phép chúng giao tiếp, Docker cung cấp một hệ thống mạng ảo mạnh mẽ.19 Khi Docker khởi động, nó tạo ra một số mạng mặc định. Các loại mạng chính bao gồm:</p><ul><li><strong><code>bridge</code>:</strong> Đây là mạng mặc định cho các container. Các container được kết nối với cùng một mạng bridge có thể giao tiếp với nhau bằng tên container của chúng, nhờ vào hệ thống DNS tích hợp của Docker. Chúng được cô lập với các container trên các mạng bridge khác.20</li><li><strong><code>host</code>:</strong> Loại bỏ sự cô lập mạng giữa container và máy chủ Docker. Container chia sẻ trực tiếp không gian mạng của máy chủ. Điều này cung cấp hiệu suất mạng tốt hơn nhưng làm mất đi lợi ích của sự cô lập.21</li><li><strong><code>overlay</code>:</strong> Được sử dụng để kết nối các container chạy trên nhiều máy chủ Docker khác nhau, tạo thành một mạng ảo duy nhất. Đây là nền tảng cho các công cụ điều phối như Docker Swarm.19</li></ul><h2 id=phần-2-làm-chủ-docker-command-line-cli>Phần 2: Làm Chủ Docker Command Line (CLI)<a hidden class=anchor aria-hidden=true href=#phần-2-làm-chủ-docker-command-line-cli>#</a></h2><p>Giao diện dòng lệnh (CLI) là công cụ chính để tương tác với Docker Daemon. Thay vì chỉ liệt kê các lệnh một cách khô khan, phần này sẽ tổ chức chúng theo các quy trình làm việc (workflow) mà một lập trình viên thường gặp phải hàng ngày, giúp hiểu rõ hơn về bối cảnh và mục đích sử dụng của từng lệnh.</p><h3 id=21-workflow-1-quản-lý-image>2.1 Workflow 1: Quản lý Image<a hidden class=anchor aria-hidden=true href=#21-workflow-1-quản-lý-image>#</a></h3><p>Quản lý image là bước đầu tiên trong mọi quy trình làm việc với Docker. Đây là quá trình tạo, phân phối và duy trì các &ldquo;bản thiết kế&rdquo; cho ứng dụng của bạn.</p><ul><li><code>docker build</code>: Lệnh này xây dựng một Docker image từ một <code>Dockerfile</code> và một &ldquo;bối cảnh&rdquo; (context). Bối cảnh là tập hợp các tệp tại đường dẫn được chỉ định. Cờ <code>-t</code> (tag) được sử dụng để đặt tên và phiên bản cho image, giúp dễ dàng nhận dạng.<ul><li>Ví dụ: <code>docker build -t my-app:1.0.</code> 22</li></ul></li><li><code>docker images</code> (hoặc <code>docker image ls</code>): Liệt kê tất cả các image hiện có trên máy cục bộ của bạn, hiển thị thông tin như REPOSITORY, TAG, IMAGE ID, và SIZE.13</li><li><code>docker pull</code>: Tải một image hoặc một kho lưu trữ (repository) từ một registry, mặc định là Docker Hub.<ul><li>Ví dụ: <code>docker pull postgres:15-alpine</code> 25</li></ul></li><li><code>docker push</code>: Tải một image từ máy cục bộ của bạn lên một registry, cho phép chia sẻ với những người khác hoặc sử dụng trong môi trường production.<ul><li>Ví dụ: <code>docker push your-username/my-app:1.0</code> 25</li></ul></li><li><code>docker rmi</code> (hoặc <code>docker image rm</code>): Xóa một hoặc nhiều image khỏi máy cục bộ để giải phóng dung lượng đĩa.<ul><li>Ví dụ: <code>docker rmi my-app:1.0</code> 23</li></ul></li><li><code>docker inspect &lt;image></code>: Cung cấp thông tin chi tiết, ở cấp độ thấp về một image, bao gồm các lớp của nó và siêu dữ liệu (metadata).28</li></ul><h3 id=22-workflow-2-vòng-đời-container>2.2 Workflow 2: Vòng đời Container<a hidden class=anchor aria-hidden=true href=#22-workflow-2-vòng-đời-container>#</a></h3><p>Sau khi có image, bước tiếp theo là tạo và quản lý các thực thể chạy của nó—các container.</p><ul><li><code>docker run</code>: Đây là lệnh trung tâm, kết hợp việc tạo và khởi chạy một container mới từ một image. Nó có nhiều cờ tùy chọn mạnh mẽ:<ul><li><code>-d</code> hoặc <code>--detach</code>: Chạy container ở chế độ nền (detached mode) và in ra ID của container.29</li><li><code>-p &lt;host_port>:&lt;container_port></code>: Ánh xạ một cổng trên máy chủ (host) tới một cổng bên trong container, cho phép truy cập ứng dụng từ bên ngoài. Ví dụ: <code>-p 8080:80</code>.30</li><li><code>--name &lt;container_name></code>: Gán một tên cụ thể cho container để dễ dàng tham chiếu thay vì sử dụng ID ngẫu nhiên.23</li><li><code>-v &lt;host_path_or_volume_name>:&lt;container_path></code>: Gắn một volume hoặc một thư mục từ máy chủ vào container.29</li><li><code>-e &lt;VAR_NAME>=&lt;value></code>: Thiết lập một biến môi trường bên trong container.23</li><li>Ví dụ đầy đủ: <code>docker run -d -p 8080:80 --name webserver -e APP_MODE=production nginx:latest</code></li></ul></li><li><code>docker ps</code>: Liệt kê tất cả các container đang chạy. Sử dụng cờ <code>-a</code> để hiển thị tất cả các container, bao gồm cả những container đã dừng.6</li><li><code>docker stop &lt;container_name_or_id></code>: Dừng một hoặc nhiều container đang chạy một cách nhẹ nhàng (gửi tín hiệu SIGTERM).31</li><li><code>docker start &lt;container_name_or_id></code>: Khởi động lại một hoặc nhiều container đã bị dừng.30</li><li><code>docker restart &lt;container_name_or_id></code>: Dừng và sau đó khởi động lại một container.30</li><li><code>docker rm &lt;container_name_or_id></code>: Xóa một hoặc nhiều container đã dừng. Sử dụng cờ <code>-f</code> để buộc xóa một container đang chạy.31</li></ul><h3 id=23-workflow-3-tương-tác-và-gỡ-lỗi-container>2.3 Workflow 3: Tương tác và Gỡ lỗi Container<a hidden class=anchor aria-hidden=true href=#23-workflow-3-tương-tác-và-gỡ-lỗi-container>#</a></h3><p>Khi container đang chạy, bạn thường cần phải &ldquo;nhìn vào bên trong&rdquo; để gỡ lỗi hoặc thực hiện các tác vụ quản trị.</p><ul><li><code>docker logs &lt;container></code>: Lấy và hiển thị nhật ký (logs) được tạo ra bởi một container. Cờ <code>-f</code> (follow) rất hữu ích để theo dõi luồng log trong thời gian thực, tương tự như lệnh <code>tail -f</code> trong Linux.22</li><li><code>docker exec -it &lt;container> &lt;command></code>: Thực thi một lệnh bên trong một container đang chạy. Cờ <code>-it</code> (<code>-i</code> cho interactive và <code>-t</code> cho TTY) cho phép bạn có một phiên làm việc tương tác. Đây là cách phổ biến nhất để &ldquo;vào&rdquo; một container.<ul><li>Ví dụ: <code>docker exec -it webserver bash</code> sẽ mở một phiên shell Bash tương tác bên trong container tên là <code>webserver</code>.13</li></ul></li><li><code>docker stats</code>: Hiển thị một luồng trực tiếp về việc sử dụng tài nguyên (CPU, bộ nhớ, mạng I/O) của các container đang chạy, rất hữu ích để theo dõi hiệu suất.28</li></ul><h3 id=24-workflow-4-dọn-dẹp-hệ-thống>2.4 Workflow 4: Dọn dẹp hệ thống<a hidden class=anchor aria-hidden=true href=#24-workflow-4-dọn-dẹp-hệ-thống>#</a></h3><p>Theo thời gian, Docker có thể tích tụ nhiều đối tượng không sử dụng (container đã dừng, image cũ, volume không được gắn), chiếm dụng không gian đĩa.</p><ul><li><code>docker system prune</code>: Một lệnh dọn dẹp mạnh mẽ, theo mặc định sẽ xóa tất cả các container đã dừng, các mạng không được sử dụng, các image lơ lửng (dangling images - những image không có tag và không được container nào sử dụng), và build cache.22<ul><li><code>docker system prune -a</code>: Mở rộng việc dọn dẹp để xóa tất cả các image không được sử dụng (không chỉ là dangling).</li><li><code>docker system prune --volumes</code>: Bao gồm cả việc xóa các volume không được sử dụng.</li></ul></li></ul><h3 id=bảng-tra-cứu-nhanh-các-lệnh-docker-cli-thiết-yếu>Bảng tra cứu nhanh các lệnh Docker CLI thiết yếu<a hidden class=anchor aria-hidden=true href=#bảng-tra-cứu-nhanh-các-lệnh-docker-cli-thiết-yếu>#</a></h3><p>Bảng dưới đây tóm tắt các lệnh Docker CLI quan trọng nhất để tham khảo nhanh.</p><table><thead><tr><th>Lệnh</th><th>Mô tả</th><th>Ví dụ sử dụng</th></tr></thead><tbody><tr><td><code>docker build</code></td><td>Xây dựng một image từ một Dockerfile.</td><td><code>docker build -t my-app:latest.</code></td></tr><tr><td><code>docker run</code></td><td>Tạo và khởi chạy một container mới từ một image.</td><td><code>docker run -d -p 80:80 --name web nginx</code></td></tr><tr><td><code>docker ps</code></td><td>Liệt kê các container đang chạy. Sử dụng <code>-a</code> để liệt kê tất cả.</td><td><code>docker ps -a</code></td></tr><tr><td><code>docker stop</code></td><td>Dừng một container đang chạy.</td><td><code>docker stop web</code></td></tr><tr><td><code>docker rm</code></td><td>Xóa một container đã dừng.</td><td><code>docker rm web</code></td></tr><tr><td><code>docker images</code></td><td>Liệt kê các image trên máy.</td><td><code>docker images</code></td></tr><tr><td><code>docker rmi</code></td><td>Xóa một image.</td><td><code>docker rmi nginx</code></td></tr><tr><td><code>docker pull</code></td><td>Tải một image từ registry.</td><td><code>docker pull ubuntu:22.04</code></td></tr><tr><td><code>docker push</code></td><td>Đẩy một image lên registry.</td><td><code>docker push my-username/my-app</code></td></tr><tr><td><code>docker exec</code></td><td>Chạy một lệnh bên trong một container đang chạy.</td><td><code>docker exec -it web bash</code></td></tr><tr><td><code>docker logs</code></td><td>Xem nhật ký của một container. Sử dụng <code>-f</code> để theo dõi.</td><td><code>docker logs -f web</code></td></tr><tr><td><code>docker system prune</code></td><td>Dọn dẹp các container, network và image không sử dụng.</td><td><code>docker system prune -a --volumes</code></td></tr></tbody></table><h2 id=phần-3-điều-phối-ứng-dụng-với-docker-compose>Phần 3: Điều phối Ứng dụng với Docker Compose<a hidden class=anchor aria-hidden=true href=#phần-3-điều-phối-ứng-dụng-với-docker-compose>#</a></h2><p>Khi các ứng dụng trở nên phức tạp hơn, chúng thường bao gồm nhiều thành phần phụ thuộc lẫn nhau—một máy chủ web, một API backend, một cơ sở dữ liệu, một hàng đợi tin nhắn, v.v. Việc quản lý từng container riêng lẻ bằng các lệnh <code>docker run</code> dài dòng và phức tạp trở nên không thực tế và dễ gây ra lỗi.33</p><p>Đây là lúc Docker Compose tỏa sáng. Docker Compose là một công cụ cho phép định nghĩa và chạy các ứng dụng Docker đa container một cách dễ dàng.35 Với Compose, bạn sử dụng một tệp YAML duy nhất (thường là</p><p><code>docker-compose.yml</code>) để cấu hình tất cả các dịch vụ, mạng và volume của ứng dụng. Sau đó, chỉ với một lệnh duy nhất, bạn có thể khởi động hoặc gỡ bỏ toàn bộ hệ thống.37</p><h3 id=31-cấu-trúc-của-tệp-docker-composeyml>3.1 Cấu trúc của tệp <code>docker-compose.yml</code><a hidden class=anchor aria-hidden=true href=#31-cấu-trúc-của-tệp-docker-composeyml>#</a></h3><p>Tệp <code>docker-compose.yml</code> là trung tâm của việc quản lý ứng dụng với Compose. Nó có cấu trúc khai báo, nghĩa là bạn mô tả &ldquo;trạng thái mong muốn&rdquo; của hệ thống, và Compose sẽ thực hiện các bước cần thiết để đạt được trạng thái đó. Các thành phần chính bao gồm:</p><ul><li><strong><code>services</code></strong>: Đây là khối chính, nơi bạn định nghĩa mỗi thành phần của ứng dụng như một &ldquo;dịch vụ&rdquo;. Mỗi dịch vụ tương ứng với một hoặc nhiều container chạy cùng một image.37<ul><li><strong><code>image: &lt;image_name>:&lt;tag></code></strong>: Chỉ định image Docker sẽ được sử dụng để tạo container cho dịch vụ này. Compose sẽ tìm image này trên máy cục bộ hoặc tải về từ Docker Hub.39</li><li><strong><code>build: &lt;path_to_context></code></strong>: Thay vì sử dụng một image có sẵn, bạn có thể yêu cầu Compose xây dựng một image tại chỗ từ một <code>Dockerfile</code>. Giá trị này là đường dẫn đến thư mục chứa <code>Dockerfile</code> (ví dụ: <code>build:.</code>).39</li><li><strong><code>ports: - "&lt;host_port>:&lt;container_port>"</code></strong>: Ánh xạ cổng giữa máy chủ và container, tương tự cờ <code>-p</code> trong <code>docker run</code>.38</li><li><strong><code>volumes: - &lt;volume_name_or_host_path>:&lt;container_path></code></strong>: Gắn một volume hoặc một thư mục từ máy chủ vào container. Đây là cách để lưu trữ dữ liệu bền bỉ hoặc chia sẻ tệp giữa máy chủ và container.40</li><li><strong><code>environment: - &lt;VAR_NAME>=&lt;value></code></strong>: Thiết lập các biến môi trường bên trong container. Đây là cách phổ biến để truyền các thông tin cấu hình như thông tin đăng nhập cơ sở dữ liệu, khóa API, v.v..38</li><li><strong><code>networks: - &lt;network_name></code></strong>: Kết nối dịch vụ vào một hoặc nhiều mạng được định nghĩa. Compose tự động tạo một mạng mặc định cho tất cả các dịch vụ trong tệp, nhưng việc định nghĩa mạng tùy chỉnh mang lại sự kiểm soát tốt hơn.39</li><li><strong><code>depends_on: - &lt;service_name></code></strong>: Xác định sự phụ thuộc giữa các dịch vụ. Ví dụ, bạn có thể yêu cầu dịch vụ web chỉ khởi động sau khi dịch vụ cơ sở dữ liệu đã khởi động.38</li></ul></li><li><strong><code>volumes</code></strong> (cấp cao nhất): Nơi bạn định nghĩa các &ldquo;named volumes&rdquo;. Việc khai báo chúng ở đây cho phép chúng được tái sử dụng và quản lý dễ dàng bởi Compose.39</li><li><strong><code>networks</code></strong> (cấp cao nhất): Nơi bạn định nghĩa các mạng tùy chỉnh. Điều này cho phép bạn tạo ra các cấu trúc liên kết mạng phức tạp hơn và cô lập các nhóm dịch vụ.39</li></ul><h3 id=32-từ-docker-run-đến-docker-composeyml>3.2 Từ <code>docker run</code> đến <code>docker-compose.yml</code><a hidden class=anchor aria-hidden=true href=#32-từ-docker-run-đến-docker-composeyml>#</a></h3><p>Để làm rõ mối liên hệ giữa CLI và Compose, bảng dưới đây sẽ ánh xạ các cờ phổ biến của lệnh <code>docker run</code> sang các khóa tương đương trong tệp <code>docker-compose.yml</code>. Việc hiểu rõ sự tương ứng này giúp quá trình chuyển đổi từ việc quản lý container đơn lẻ sang điều phối toàn bộ ứng dụng trở nên trực quan hơn. Nó cho thấy <code>docker-compose.yml</code> không phải là một ngôn ngữ hoàn toàn mới, mà là một cách khai báo, có cấu trúc để thể hiện những cấu hình tương tự.</p><table><thead><tr><th>Cờ <code>docker run</code></th><th>Khóa <code>docker-compose.yml</code></th><th>Ví dụ</th></tr></thead><tbody><tr><td><code>-d</code></td><td>(Mặc định khi dùng <code>up -d</code>)</td><td><code>docker compose up -d</code></td></tr><tr><td><code>-p 8080:80</code></td><td><code>ports</code></td><td><code>ports: ["8080:80"]</code></td></tr><tr><td><code>-v my-data:/data</code></td><td><code>volumes</code></td><td><code>volumes: ["my-data:/data"]</code></td></tr><tr><td><code>-e VAR=value</code></td><td><code>environment</code></td><td><code>environment:</code></td></tr><tr><td><code>--name my-app</code></td><td><code>container_name</code></td><td><code>container_name: my-app</code></td></tr><tr><td><code>--network my-net</code></td><td><code>networks</code></td><td><code>networks: ["my-net"]</code></td></tr><tr><td><code>--restart=always</code></td><td><code>restart</code></td><td><code>restart: always</code></td></tr></tbody></table><h3 id=33-các-lệnh-docker-compose-cốt-lõi>3.3 Các lệnh Docker Compose cốt lõi<a hidden class=anchor aria-hidden=true href=#33-các-lệnh-docker-compose-cốt-lõi>#</a></h3><p>Sau khi đã định nghĩa ứng dụng trong tệp <code>docker-compose.yml</code>, bạn sử dụng một vài lệnh đơn giản để quản lý toàn bộ vòng đời của nó.</p><ul><li><code>docker compose up</code>: Lệnh này là trái tim của Compose. Nó đọc tệp <code>docker-compose.yml</code>, xây dựng các image cần thiết, tạo và khởi chạy tất cả các container dịch vụ, và tạo các network và volume tương ứng. Nếu không có cờ <code>-d</code>, nó sẽ chạy ở chế độ foreground và hiển thị log tổng hợp từ tất cả các container.34<ul><li><code>docker compose up -d</code>: Chạy ứng dụng ở chế độ nền (detached). Đây là cách sử dụng phổ biến nhất trong môi trường phát triển và sản xuất.</li></ul></li><li><code>docker compose down</code>: Lệnh này là đối nghịch của <code>up</code>. Nó sẽ dừng và xóa tất cả các container, cùng với các network được tạo bởi Compose.<ul><li><code>docker compose down --volumes</code>: Thêm cờ này để xóa cả các named volumes đã được định nghĩa trong tệp Compose. Hãy cẩn thận vì điều này sẽ xóa vĩnh viễn dữ liệu.41</li></ul></li><li><code>docker compose build</code>: Nếu bạn đã thay đổi <code>Dockerfile</code> của một dịch vụ, lệnh này sẽ buộc xây dựng lại image cho dịch vụ đó trước khi chạy <code>up</code>.37</li><li><code>docker compose logs</code>: Hiển thị log từ các container dịch vụ.<ul><li><code>docker compose logs -f &lt;service_name></code>: Theo dõi log của một dịch vụ cụ thể trong thời gian thực.41</li></ul></li><li><code>docker compose exec &lt;service_name> &lt;command></code>: Thực thi một lệnh bên trong một container của một dịch vụ đang chạy. Rất hữu ích để chạy các tác vụ quản trị hoặc mở một shell để gỡ lỗi.<ul><li>Ví dụ: <code>docker compose exec web sh</code></li></ul></li></ul><h2 id=phần-4-hướng-dẫn-thực-hành-container-hóa-ứng-dụng-dịch-vụ-đơn>Phần 4: Hướng dẫn Thực hành: Container hóa Ứng dụng Dịch vụ đơn<a hidden class=anchor aria-hidden=true href=#phần-4-hướng-dẫn-thực-hành-container-hóa-ứng-dụng-dịch-vụ-đơn>#</a></h2><p>Lý thuyết là nền tảng, nhưng thực hành mới là cách tốt nhất để củng cố kiến thức. Phần này cung cấp các hướng dẫn từng bước để container hóa các ứng dụng đơn giản được viết bằng Go, Node.js và Python, ba trong số các ngôn ngữ phổ biến nhất trong phát triển web hiện đại.</p><h3 id=41-ví-dụ-1-máy-chủ-web-go-nhẹ>4.1 Ví dụ 1: Máy chủ Web Go nhẹ<a hidden class=anchor aria-hidden=true href=#41-ví-dụ-1-máy-chủ-web-go-nhẹ>#</a></h3><p>Go nổi tiếng với việc biên dịch ra các tệp nhị phân tĩnh, độc lập, rất phù hợp với container. Chúng ta sẽ tận dụng tính năng multi-stage build của Docker để tạo ra một image production siêu nhỏ.</p><ol><li>Mã nguồn (main.go)</li></ol><p>Tạo một tệp main.go với nội dung sau. Đây là một máy chủ web đơn giản lắng nghe trên cổng 8080.</p><p>Go</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;log&#34;
    &#34;net/http&#34;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &#34;Hello from Go in a Docker Container!&#34;)
}

func main() {
    http.HandleFunc(&#34;/&#34;, handler)
    log.Println(&#34;Go web server starting on port 8080&#34;)
    log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil))
}
</code></pre><ol start=2><li>Dockerfile</li></ol><p>Tạo một tệp tên là Dockerfile (không có phần mở rộng) với nội dung sau:</p><p>Dockerfile</p><pre tabindex=0><code># Stage 1: Build the application
FROM golang:1.21-alpine AS builder

# Set the Current Working Directory inside the container
WORKDIR /app

# Copy go mod and sum files
COPY go.mod go.sum./

# Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed
RUN go mod download

# Copy the source code
COPY..

# Build the Go app
# CGO_ENABLED=0 is for static builds
# -o /go-app builds the executable to /go-app
RUN CGO_ENABLED=0 GOOS=linux go build -o /go-app.

# Stage 2: Create the final, lightweight image
FROM alpine:latest

# Copy the pre-built binary file from the previous stage
COPY --from=builder /go-app /go-app

# Expose port 8080 to the outside world
EXPOSE 8080

# Command to run the executable
CMD [&#34;/go-app&#34;]
</code></pre><p><strong>Giải thích Dockerfile:</strong></p><ul><li><strong>Stage 1 (<code>builder</code>):</strong> Chúng ta bắt đầu với image <code>golang:1.21-alpine</code>, chứa tất cả các công cụ cần thiết để biên dịch mã Go. Chúng ta sao chép mã nguồn và biên dịch nó thành một tệp nhị phân tĩnh duy nhất tại <code>/go-app</code>.36</li><li><strong>Stage 2 (final):</strong> Chúng ta bắt đầu lại với một image <code>alpine:latest</code> siêu nhẹ. Sau đó, chúng ta chỉ sao chép tệp nhị phân đã được biên dịch từ stage <code>builder</code> vào image cuối cùng này. Kết quả là một image production chỉ chứa ứng dụng của bạn và không có bất kỳ công cụ build nào.43</li></ul><ol start=3><li>Xây dựng và Chạy</li></ol><p>Trước tiên, khởi tạo Go module:</p><p>Bash</p><pre tabindex=0><code>go mod init go-webapp
</code></pre><p>Bây giờ, xây dựng image và chạy container:</p><p>Bash</p><pre tabindex=0><code># Build the Docker image
docker build -t go-webapp.

# Run the container, mapping port 8080 on the host to 8080 in the container
docker run -p 8080:8080 go-webapp
</code></pre><p>Mở trình duyệt và truy cập <code>http://localhost:8080</code> để thấy thông điệp của bạn.</p><h3 id=42-ví-dụ-2-api-nodejs--express-năng-động>4.2 Ví dụ 2: API Node.js & Express năng động<a hidden class=anchor aria-hidden=true href=#42-ví-dụ-2-api-nodejs--express-năng-động>#</a></h3><p>Node.js là một lựa chọn phổ biến cho các API. Quy trình làm việc với Docker cho Node.js tập trung vào việc quản lý các dependencies <code>npm</code> một cách hiệu quả.</p><ol><li>Mã nguồn và Dependencies</li></ol><p>Tạo một thư mục dự án và khởi tạo một dự án Node.js:</p><p>Bash</p><pre tabindex=0><code>mkdir node-api &amp;&amp; cd node-api
npm init -y
npm install express
</code></pre><p>Tạo một tệp <code>app.js</code>:</p><p>JavaScript</p><pre tabindex=0><code>const express = require(&#39;express&#39;);
const app = express();
const port = 3000;

app.get(&#39;/&#39;, (req, res) =&gt; {
  res.send(&#39;Hello from Node.js &amp; Express in a Docker Container!&#39;);
});

app.listen(port, () =&gt; {
  console.log(`Node.js API listening on port ${port}`);
});
</code></pre><ol start=2><li>Dockerfile</li></ol><p>Tạo một tệp Dockerfile:</p><p>Dockerfile</p><pre tabindex=0><code># Use an official Node.js runtime as a parent image
FROM node:18-alpine

# Set the working directory in the container
WORKDIR /usr/src/app

# Copy package.json and package-lock.json
# This is done separately to take advantage of Docker&#39;s layer caching.
# The npm install step will only be re-run if these files change.
COPY package*.json./

# Install app dependencies
RUN npm install

# Bundle app source
COPY..

# Expose the port the app runs on
EXPOSE 3000

# Define the command to run the app
CMD [ &#34;node&#34;, &#34;app.js&#34; ]
</code></pre><p><strong>Giải thích Dockerfile:</strong></p><ul><li>Chúng ta sao chép <code>package*.json</code> và chạy <code>npm install</code> trước khi sao chép phần còn lại của mã nguồn. Đây là một kỹ thuật tối ưu hóa quan trọng. Vì các dependencies ít thay đổi hơn mã nguồn, Docker có thể tái sử dụng lớp (layer) đã được cache của <code>npm install</code>, giúp các lần build sau nhanh hơn đáng kể.44</li></ul><p><strong>3. Xây dựng và Chạy</strong></p><p>Bash</p><pre tabindex=0><code># Build the Docker image
docker build -t node-api.

# Run the container, mapping port 3000 to 3000
docker run -p 3000:3000 node-api
</code></pre><p>Truy cập <code>http://localhost:3000</code> trên trình duyệt của bạn.</p><h3 id=43-ví-dụ-3-ứng-dụng-python--fastapi-hướng-dữ-liệu>4.3 Ví dụ 3: Ứng dụng Python & FastAPI hướng dữ liệu<a hidden class=anchor aria-hidden=true href=#43-ví-dụ-3-ứng-dụng-python--fastapi-hướng-dữ-liệu>#</a></h3><p>FastAPI là một framework Python hiện đại để xây dựng API. Tương tự như Node.js, việc quản lý dependencies là chìa khóa.</p><ol><li>Mã nguồn và Dependencies</li></ol><p>Tạo một thư mục dự án. Bên trong, tạo tệp requirements.txt:</p><pre tabindex=0><code>fastapi
uvicorn[standard]
</code></pre><p>Tạo tệp <code>main.py</code>:</p><p>Python</p><pre tabindex=0><code>from fastapi import FastAPI

app = FastAPI()

@app.get(&#34;/&#34;)
def read_root():
    return {&#34;message&#34;: &#34;Hello from Python &amp; FastAPI in a Docker Container!&#34;}
</code></pre><ol start=2><li>Dockerfile</li></ol><p>Tạo một tệp Dockerfile:</p><p>Dockerfile</p><pre tabindex=0><code># Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set the working directory in the container
WORKDIR /code

# Copy the dependencies file to the working directory
COPY requirements.txt.

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy the current directory contents into the container at /code
COPY..

# Expose port 8000
EXPOSE 8000

# Run uvicorn server when the container launches
CMD [&#34;uvicorn&#34;, &#34;main:app&#34;, &#34;--host&#34;, &#34;0.0.0.0&#34;, &#34;--port&#34;, &#34;8000&#34;]
</code></pre><p><strong>Giải thích Dockerfile:</strong></p><ul><li>Quy trình này tương tự như ví dụ Node.js. Chúng ta cài đặt các dependencies từ <code>requirements.txt</code> trước, sau đó sao chép mã nguồn để tận dụng cơ chế cache của Docker.46</li><li>Chúng ta sử dụng <code>python:3.11-slim</code> làm image cơ sở, đây là một biến thể nhỏ gọn hơn so với image mặc định, giúp giảm kích thước image cuối cùng.</li></ul><p><strong>3. Xây dựng và Chạy</strong></p><p>Bash</p><pre tabindex=0><code># Build the Docker image
docker build -t python-api.

# Run the container, mapping port 8000 to 8000
docker run -p 8000:8000 python-api
</code></pre><p>Truy cập <code>http://localhost:8000</code> để xem kết quả.</p><h2 id=phần-5-triển-khai-full-stack-wordpress-với-postgresql-bằng-docker-compose>Phần 5: Triển khai Full-Stack: WordPress với PostgreSQL bằng Docker Compose<a hidden class=anchor aria-hidden=true href=#phần-5-triển-khai-full-stack-wordpress-với-postgresql-bằng-docker-compose>#</a></h2><p>Đây là phần tổng hợp, nơi chúng ta sẽ áp dụng tất cả các kiến thức đã học để triển khai một ứng dụng web hoàn chỉnh và thực tế: một trang web WordPress được hỗ trợ bởi cơ sở dữ liệu PostgreSQL. Ví dụ này thể hiện sức mạnh thực sự của Docker Compose trong việc điều phối nhiều dịch vụ phụ thuộc lẫn nhau. Đáng chú ý, chúng ta sẽ sử dụng PostgreSQL theo yêu cầu cụ thể, một lựa chọn ít phổ biến hơn so với MySQL/MariaDB trong các hướng dẫn WordPress thông thường, nhưng hoàn toàn khả thi và mạnh mẽ.48</p><h3 id=51-kiến-trúc-ứng-dụng>5.1 Kiến trúc ứng dụng<a hidden class=anchor aria-hidden=true href=#51-kiến-trúc-ứng-dụng>#</a></h3><p>Hệ thống của chúng ta sẽ bao gồm các thành phần sau, tất cả được định nghĩa và kết nối trong một tệp <code>docker-compose.yml</code> duy nhất:</p><ul><li><strong>Dịch vụ 1 (<code>db</code>):</strong> Một container chạy PostgreSQL, sử dụng image chính thức <code>postgres:15-alpine</code>. Đây sẽ là nơi lưu trữ tất cả nội dung của trang WordPress (bài viết, trang, người dùng, v.v.).</li><li><strong>Dịch vụ 2 (<code>wordpress</code>):</strong> Một container chạy WordPress, sử dụng image chính thức <code>wordpress:latest</code>. Dịch vụ này sẽ chứa máy chủ web (Apache) và PHP để chạy ứng dụng WordPress.</li><li><strong>Volume 1 (<code>db_data</code>):</strong> Một named volume để lưu trữ dữ liệu của PostgreSQL. Điều này đảm bảo rằng cơ sở dữ liệu của bạn sẽ tồn tại ngay cả khi container <code>db</code> bị xóa và tạo lại.</li><li><strong>Volume 2 (<code>wp_content</code>):</strong> Một named volume để lưu trữ các tệp của WordPress, bao gồm themes, plugins và các tệp được tải lên. Điều này cho phép bạn cập nhật phiên bản WordPress mà không làm mất các tùy chỉnh và nội dung của mình.</li><li><strong>Network (<code>app_net</code>):</strong> Một mạng bridge tùy chỉnh để hai dịch vụ có thể giao tiếp với nhau một cách an toàn và đáng tin cậy, tách biệt với các container khác có thể đang chạy trên cùng một máy chủ.</li></ul><p>Việc sử dụng một tệp <code>docker-compose.yml</code> để định nghĩa toàn bộ kiến trúc này biến nó thành một dạng &ldquo;cơ sở hạ tầng dưới dạng mã&rdquo; (Infrastructure as Code). Tệp này trở thành nguồn chân lý duy nhất cho toàn bộ ứng dụng, có thể được quản lý phiên bản trong Git, chia sẻ với các thành viên trong nhóm và đảm bảo rằng mọi người đều có thể khởi tạo một môi trường giống hệt nhau chỉ bằng một lệnh duy nhất, giúp cải thiện đáng kể quá trình giới thiệu thành viên mới và tính nhất quán.37</p><h3 id=52-phân-tích-chi-tiết-docker-composeyml>5.2 Phân tích chi tiết <code>docker-compose.yml</code><a hidden class=anchor aria-hidden=true href=#52-phân-tích-chi-tiết-docker-composeyml>#</a></h3><p>Tạo một thư mục cho dự án của bạn, ví dụ <code>my-wordpress-site</code>. Bên trong thư mục đó, tạo một tệp có tên <code>docker-compose.yml</code> với nội dung sau:</p><p>YAML</p><pre tabindex=0><code>version: &#39;3.8&#39;

services:
  db:
    image: postgres:15-alpine
    container_name: wordpress_db
    volumes:
      - db_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    restart: always
    networks:
      - app_net

  wordpress:
    depends_on:
      - db
    image: wordpress:latest
    container_name: wordpress_app
    ports:
      - &#34;8000:80&#34;
    volumes:
      - wp_content:/var/www/html
    environment:
      WORDPRESS_DB_HOST: db:5432
      WORDPRESS_DB_USER: ${POSTGRES_USER}
      WORDPRESS_DB_PASSWORD: ${POSTGRES_PASSWORD}
      WORDPRESS_DB_NAME: ${POSTGRES_DB}
    restart: always
    networks:
      - app_net

volumes:
  db_data:
  wp_content:

networks:
  app_net:
    driver: bridge
</code></pre><p><strong>Giải thích chi tiết:</strong></p><ul><li><strong><code>services:</code></strong>: Định nghĩa hai dịch vụ của chúng ta là <code>db</code> và <code>wordpress</code>.</li><li><strong><code>db</code> service:</strong><ul><li><code>image: postgres:15-alpine</code>: Sử dụng phiên bản 15 của PostgreSQL trên nền Alpine Linux để có kích thước nhỏ.</li><li><code>volumes: - db_data:/var/lib/postgresql/data</code>: Ánh xạ named volume <code>db_data</code> vào thư mục dữ liệu mặc định của PostgreSQL bên trong container.</li><li><code>environment:</code>: Cấu hình cơ sở dữ liệu. Các giá trị <code>${...}</code> sẽ được Docker Compose thay thế bằng các biến môi trường từ một tệp <code>.env</code> hoặc từ shell, một thực tiễn tốt để giữ bí mật an toàn.</li><li><code>restart: always</code>: Tự động khởi động lại container này nếu nó bị dừng.</li><li><code>networks: - app_net</code>: Kết nối dịch vụ này vào mạng <code>app_net</code>.</li></ul></li><li><strong><code>wordpress</code> service:</strong><ul><li><code>depends_on: - db</code>: Yêu cầu Compose khởi động dịch vụ <code>db</code> trước dịch vụ <code>wordpress</code>.</li><li><code>ports: - "8000:80"</code>: Ánh xạ cổng 8000 trên máy chủ của bạn tới cổng 80 (cổng web mặc định) bên trong container WordPress.</li><li><code>volumes: - wp_content:/var/www/html</code>: Ánh xạ named volume <code>wp_content</code> vào thư mục gốc của WordPress.</li><li><code>environment:</code>: Cung cấp cho WordPress thông tin cần thiết để kết nối với cơ sở dữ liệu. Lưu ý <code>WORDPRESS_DB_HOST: db:5432</code>. Ở đây, <code>db</code> là tên của dịch vụ cơ sở dữ liệu, và Docker Compose sẽ đảm bảo rằng tên này được phân giải thành địa chỉ IP nội bộ của container <code>db</code> trên mạng <code>app_net</code>.</li></ul></li><li><strong><code>volumes:</code></strong> (cấp cao nhất): Khai báo hai named volumes <code>db_data</code> và <code>wp_content</code> để Docker quản lý.</li><li><strong><code>networks:</code></strong> (cấp cao nhất): Khai báo mạng tùy chỉnh <code>app_net</code> sử dụng driver <code>bridge</code> mặc định.</li></ul><h3 id=53-triển-khai-và-quản-lý>5.3 Triển khai và Quản lý<a hidden class=anchor aria-hidden=true href=#53-triển-khai-và-quản-lý>#</a></h3><ol><li>Tạo tệp Biến môi trường (.env)</li></ol><p>Trong cùng thư mục với docker-compose.yml, tạo một tệp tên là .env. Tệp này sẽ chứa các thông tin nhạy cảm. Docker Compose sẽ tự động đọc tệp này.</p><p>Lưu ý: Hãy thêm .env vào tệp .gitignore của bạn để không vô tình đưa thông tin đăng nhập vào kho mã nguồn.</p><p>Code snippet</p><pre tabindex=0><code>#.env file
# PostgreSQL Credentials
POSTGRES_DB=wordpress
POSTGRES_USER=wp_user
POSTGRES_PASSWORD=your_strong_password
</code></pre><p>Thay <code>your_strong_password</code> bằng một mật khẩu mạnh và an toàn.</p><ol start=2><li>Khởi động hệ thống</li></ol><p>Mở terminal trong thư mục dự án và chạy lệnh sau:</p><p>Bash</p><pre tabindex=0><code>docker compose up -d
</code></pre><p>Docker Compose sẽ:</p><ol><li>Tải về các image <code>postgres:15-alpine</code> và <code>wordpress:latest</code> nếu chúng chưa có trên máy.</li><li>Tạo mạng <code>app_net</code>.</li><li>Tạo các volume <code>db_data</code> và <code>wp_content</code>.</li><li>Khởi động container <code>db</code> trước.</li><li>Sau đó, khởi động container <code>wordpress</code>.</li><li>Tất cả sẽ chạy ở chế độ nền (<code>-d</code>).</li></ol><p>Bạn có thể kiểm tra trạng thái của các container bằng lệnh <code>docker compose ps</code>.</p><ol start=3><li>Hoàn tất cài đặt WordPress</li></ol><p>Mở trình duyệt web và truy cập http://localhost:8000. Bạn sẽ thấy màn hình cài đặt WordPress quen thuộc.48 Hãy làm theo các bước để chọn ngôn ngữ, đặt tên trang web, tạo tài khoản quản trị viên. Tất cả thông tin này sẽ được lưu trữ trong cơ sở dữ liệu PostgreSQL đang chạy trong container</p><p><code>db</code>.</p><ol start=4><li>Dừng và Dọn dẹp</li></ol><p>Khi bạn muốn dừng ứng dụng, hãy chạy:</p><p>Bash</p><pre tabindex=0><code>docker compose down
</code></pre><p>Lệnh này sẽ dừng và xóa các container và mạng. Tuy nhiên, các volume (<code>db_data</code> và <code>wp_content</code>) sẽ vẫn còn. Điều này có nghĩa là nếu bạn chạy lại <code>docker compose up -d</code>, trang web của bạn sẽ trở lại với tất cả dữ liệu và tệp tin còn nguyên vẹn.</p><p>Để xóa mọi thứ, bao gồm cả dữ liệu, hãy chạy:</p><p>Bash</p><pre tabindex=0><code>docker compose down --volumes
</code></pre><h2 id=phần-6-các-thực-tiễn-tốt-nhất-cho-môi-trường-production>Phần 6: Các Thực tiễn Tốt nhất cho Môi trường Production<a hidden class=anchor aria-hidden=true href=#phần-6-các-thực-tiễn-tốt-nhất-cho-môi-trường-production>#</a></h2><p>Việc đưa các ứng dụng container hóa vào môi trường production đòi hỏi một mức độ cẩn trọng và tối ưu hóa cao hơn so với môi trường phát triển. Phần này sẽ cung cấp các thực tiễn tốt nhất, giúp bạn xây dựng các image nhỏ gọn, an toàn và các tệp Compose có khả năng bảo trì cao, sẵn sàng cho việc triển khai thực tế.</p><h3 id=61-tối-ưu-hóa-kích-thước-và-tốc-độ-multi-stage-builds>6.1 Tối ưu hóa Kích thước và Tốc độ: Multi-Stage Builds<a hidden class=anchor aria-hidden=true href=#61-tối-ưu-hóa-kích-thước-và-tốc-độ-multi-stage-builds>#</a></h3><p>Một trong những vấn đề phổ biến nhất với các Docker image là chúng trở nên cồng kềnh. Một image lớn không chỉ chiếm nhiều dung lượng lưu trữ mà còn làm tăng thời gian tải về và triển khai. Tệ hơn nữa, nó thường chứa các công cụ xây dựng (như JDK, Go toolchain, <code>build-essentials</code>) và các dependencies chỉ cần thiết cho quá trình biên dịch, không cần thiết cho việc chạy ứng dụng. Những thành phần thừa này làm tăng bề mặt tấn công của image một cách không cần thiết.51</p><p><strong>Multi-stage builds</strong> là một tính năng mạnh mẽ của Docker để giải quyết vấn đề này.53 Kỹ thuật này cho phép bạn sử dụng nhiều lệnh</p><p><code>FROM</code> trong cùng một <code>Dockerfile</code>. Mỗi lệnh <code>FROM</code> bắt đầu một &ldquo;stage&rdquo; (giai đoạn) xây dựng mới.</p><p>Cách hoạt động rất đơn giản và hiệu quả:</p><ol><li><strong>Stage 1 (Build Stage):</strong> Bạn sử dụng một image cơ sở đầy đủ (ví dụ: <code>golang:1.21</code>) có tất cả các công cụ cần thiết để biên dịch, kiểm thử và đóng gói ứng dụng của bạn. Giai đoạn này được đặt tên (ví dụ: <code>AS builder</code>).</li><li><strong>Stage 2 (Final Stage):</strong> Bạn bắt đầu một giai đoạn mới với một image cơ sở tối giản (ví dụ: <code>alpine:latest</code> hoặc thậm chí <code>scratch</code>—một image trống).</li><li><strong>Copy Artifacts:</strong> Bạn sử dụng lệnh <code>COPY --from=builder</code> để sao chép chỉ những tạo tác (artifacts) cần thiết—chẳng hạn như tệp nhị phân đã biên dịch hoặc các tệp đã được thu nhỏ—từ giai đoạn xây dựng vào giai đoạn cuối cùng.55</li></ol><p>Ví dụ với ứng dụng Go từ Phần 4 đã minh họa hoàn hảo điều này. Image cuối cùng chỉ chứa tệp nhị phân thực thi và image Alpine cơ sở, giảm kích thước từ hàng trăm MB xuống chỉ còn vài MB.</p><h3 id=62-tăng-cường-bảo-mật>6.2 Tăng cường Bảo mật<a hidden class=anchor aria-hidden=true href=#62-tăng-cường-bảo-mật>#</a></h3><p>Bảo mật là yếu tố không thể bỏ qua khi triển khai. <code>Dockerfile</code> của bạn là tuyến phòng thủ đầu tiên.</p><ul><li><p><strong>Chạy với người dùng không phải root:</strong> Mặc định, các container chạy với người dùng <code>root</code>, điều này tạo ra một rủi ro bảo mật nghiêm trọng. Nếu một kẻ tấn công khai thác được một lỗ hổng trong ứng dụng của bạn và thoát ra khỏi container, chúng có thể có quyền <code>root</code> trên máy chủ. Hãy luôn tạo một người dùng và nhóm không có đặc quyền bên trong <code>Dockerfile</code> và sử dụng lệnh <code>USER</code> để chuyển sang người dùng đó trước khi chạy ứng dụng.56
Dockerfile</p><pre tabindex=0><code># Create a non-root user
RUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup

#... copy files and set permissions...
RUN chown -R appuser:appgroup /app

# Switch to the non-root user
USER appuser

CMD [&#34;/app/my-binary&#34;]
</code></pre></li><li><p><strong>Chọn base image tối giản:</strong> Nguyên tắc là &ldquo;càng ít càng tốt&rdquo;. Một image cơ sở tối giản như <code>alpine</code>, <code>distroless</code>, hoặc <code>scratch</code> chứa ít thành phần hơn, đồng nghĩa với việc có ít lỗ hổng tiềm tàng hơn và bề mặt tấn công nhỏ hơn.53</p></li><li><p><strong>Sử dụng <code>.dockerignore</code>:</strong> Tương tự như <code>.gitignore</code>, tệp <code>.dockerignore</code> ngăn chặn các tệp và thư mục không cần thiết (như <code>.git</code>, <code>node_modules</code>, các tệp log cục bộ, tệp bí mật) được gửi đến Docker daemon trong quá trình xây dựng. Điều này không chỉ giúp image nhỏ hơn mà còn ngăn chặn việc vô tình rò rỉ thông tin nhạy cảm vào image.57</p></li></ul><h3 id=63-quản-lý-các-file-compose-có-thể-bảo-trì>6.3 Quản lý các file Compose có thể bảo trì<a hidden class=anchor aria-hidden=true href=#63-quản-lý-các-file-compose-có-thể-bảo-trì>#</a></h3><p>Khi dự án phát triển, việc quản lý cấu hình cho các môi trường khác nhau (phát triển, kiểm thử, sản xuất) trở nên quan trọng.</p><ul><li><strong>Sử dụng biến môi trường và tệp <code>.env</code>:</strong> <strong>Không bao giờ</strong> ghi cứng các giá trị nhạy cảm như mật khẩu, khóa API, hoặc thông tin đăng nhập cơ sở dữ liệu trực tiếp vào tệp <code>docker-compose.yml</code>. Thay vào đó, hãy tham chiếu chúng dưới dạng biến môi trường. Docker Compose sẽ tự động tải các biến từ một tệp <code>.env</code> trong cùng thư mục. Tệp <code>.env</code> này nên được thêm vào <code>.gitignore</code> để đảm bảo nó không được đưa vào hệ thống quản lý phiên bản.58<ul><li>Trong <code>docker-compose.yml</code>:
YAML<pre tabindex=0><code>environment:
  - DB_PASSWORD=${POSTGRES_PASSWORD}
</code></pre></li><li>Trong tệp <code>.env</code>:
Code snippet<pre tabindex=0><code>POSTGRES_PASSWORD=supersecret
</code></pre></li></ul></li><li><strong>Quản lý các môi trường khác nhau (Dev vs. Prod):</strong> Thay vì duy trì nhiều tệp Compose gần như giống hệt nhau, hãy sử dụng một tệp <code>docker-compose.yml</code> cơ sở cho các cấu hình chung và một tệp <code>docker-compose.override.yml</code> cho các cấu hình dành riêng cho môi trường phát triển. Docker Compose tự động đọc và hợp nhất cả hai tệp này.<ul><li><strong><code>docker-compose.yml</code> (cơ sở, cho production):</strong>
YAML<pre tabindex=0><code>services:
  web:
    image: my-app:latest
    ports: [&#34;80:8000&#34;]
</code></pre></li><li><strong><code>docker-compose.override.yml</code> (cho development, không commit vào Git):</strong>
YAML
` services:
web:
build:.
volumes:
-.:/app # Mount source code for live reload
ports:<ul><li>&ldquo;8000:8000&rdquo;
command: npm run dev
<code>Khi bạn chạy</code>docker compose up<code>, Compose sẽ hợp nhất hai tệp này, tạo ra một cấu hình phát triển hoàn chỉnh. Trong môi trường production, bạn chỉ cần triển khai tệp </code>docker-compose.yml` cơ sở.58</li></ul></li></ul></li></ul><h2 id=conclusion-tích-hợp-container-hóa-vào-quy-trình-làm-việc-của-bạn>Conclusion: Tích hợp Container hóa vào Quy trình làm việc của bạn<a hidden class=anchor aria-hidden=true href=#conclusion-tích-hợp-container-hóa-vào-quy-trình-làm-việc-của-bạn>#</a></h2><p>Hành trình qua thế giới Docker và Docker Compose đã trang bị cho các lập trình viên một bộ công cụ mạnh mẽ để hiện đại hóa quy trình phát triển và triển khai phần mềm. Chúng ta đã đi từ việc tìm hiểu các khái niệm nền tảng—sự khác biệt cốt lõi giữa image và container, tầm quan trọng của volume và network—đến việc làm chủ các lệnh CLI thiết yếu để quản lý vòng đời của chúng.</p><p>Thông qua các ví dụ thực tế với Go, Node.js và Python, chúng ta đã thấy cách áp dụng các nguyên tắc này để đóng gói các ứng dụng dịch vụ đơn một cách hiệu quả. Đỉnh cao là việc triển khai một ứng dụng web full-stack, WordPress với PostgreSQL, đã chứng minh sức mạnh của Docker Compose trong việc điều phối các hệ thống phức tạp, đa thành phần chỉ bằng một tệp cấu hình khai báo duy nhất.</p><p>Cuối cùng, việc áp dụng các thực tiễn tốt nhất—như multi-stage builds để tối ưu hóa image, các biện pháp bảo mật để làm cứng container, và các chiến lược quản lý tệp Compose để xử lý các môi trường khác nhau—nâng cao kỹ năng từ mức độ &ldquo;biết dùng&rdquo; lên &ldquo;làm chủ&rdquo;.</p><p>Docker và Docker Compose là những công cụ không thể thiếu trong bộ công cụ của một lập trình viên hiện đại. Chúng là bước đệm hoàn hảo để hiểu sâu hơn về kiến trúc microservices và là nền tảng vững chắc trước khi tiến vào thế giới điều phối ở quy mô lớn hơn như Kubernetes.62 Bằng cách tích hợp container hóa vào quy trình làm việc hàng ngày, các nhóm phát triển có thể đạt được tốc độ, tính nhất quán và hiệu quả cao hơn bao giờ hết, cho phép họ tập trung vào điều quan trọng nhất: xây dựng những sản phẩm tuyệt vời.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nagih.io.vn/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://blog.nagih.io.vn/posts/database/9-mysql-table-design-rules--skills/><span class=title>« Prev</span><br><span>9 MySQL Table Design Rules & Skills</span>
</a><a class=next href=https://blog.nagih.io.vn/posts/database/sql/><span class=title>Next »</span><br><span>SQL Overview</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on x" href="https://x.com/intent/tweet/?text=Docker%20Overview&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f&amp;hashtags=docker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f&amp;title=Docker%20Overview&amp;summary=Docker%20Overview&amp;source=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f&title=Docker%20Overview"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Overview%20-%20https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on telegram" href="https://telegram.me/share/url?text=Docker%20Overview&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Overview on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20Overview&u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2fdocker%2fdocker.sync-conflict-20250821-125726-izlhqhs%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nagih.io.vn/>Nagih | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>