<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>6 Level Deploy | Nagih | Blog</title>
<meta name=keywords content="docker"><meta name=description content="6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn"><meta name=author content="Nagih"><link rel=canonical href=https://blog.nagih.io.vn/posts/6-level-deploy/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.nagih.io.vn/posts/6-level-deploy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.nagih.io.vn/posts/6-level-deploy/"><meta property="og:site_name" content="Nagih | Blog"><meta property="og:title" content="6 Level Deploy"><meta property="og:description" content="6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-17T00:00:00+00:00"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="6 Level Deploy"><meta name=twitter:description content="6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nagih.io.vn/posts/"},{"@type":"ListItem","position":2,"name":"6 Level Deploy","item":"https://blog.nagih.io.vn/posts/6-level-deploy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"6 Level Deploy","name":"6 Level Deploy","description":"6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn\n","keywords":["docker"],"articleBody":"6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn\nHành Trình Trưởng Thành DevOps Trong thế giới phát triển phần mềm hiện đại, DevOps không chỉ là một chức danh công việc mà là một triết lý văn hóa và một tập hợp các phương pháp kỹ thuật. Mục tiêu cốt lõi của DevOps là rút ngắn vòng đời phát triển phần mềm và cung cấp sản phẩm một cách liên tục với chất lượng cao, thông qua việc phá vỡ các rào cản giữa đội ngũ Phát triển (Development - Dev) và Vận hành (Operations - Ops), thúc đẩy sự hợp tác, chia sẻ trách nhiệm và giao tiếp hiệu quả\nTrước khi bắt đầu, cần phải làm rõ một sự khác biệt nền tảng nhưng thường bị nhầm lẫn: “Deployment” (Triển khai) và “Release” (Phát hành).\nDeployment là một hoạt động kỹ thuật, bao gồm việc di chuyển mã nguồn từ môi trường này sang môi trường khác, ví dụ từ staging lên production. Đây là một quy trình vận hành thuần túy, tập trung vào việc đảm bảo mã nguồn chạy đúng trong môi trường mới. Release là một quyết định kinh doanh, liên quan đến việc cung cấp các tính năng mới cho người dùng. Quá trình này có thể bao gồm các hoạt động marketing, đào tạo người dùng, hoặc tung ra theo từng giai đoạn. Một tính năng có thể được “deploy” lên production nhiều lần nhưng ẩn sau một “feature flag” (cờ tính năng) và chỉ được “release” khi có quyết định từ phía kinh doanh. Hiểu rõ sự khác biệt này là chìa khóa để nhận ra rằng toàn bộ hành trình trưởng thành của DevOps về cơ bản là một cuộc tìm kiếm không ngừng nhằm quản lý và giảm thiểu rủi ro, đồng thời tăng tốc độ cung cấp giá trị cho người dùng. Mỗi cấp độ đại diện cho một chiến lược quản lý rủi ro ngày càng tinh vi hơn. Ở cấp độ thấp nhất, rủi ro cực kỳ cao, một phương pháp kém hiệu quả. Các cấp độ tiếp theo lần lượt giảm thiểu rủi ro từ lỗi con người, lỗi tích hợp, sự không nhất quán của môi trường, cho đến các lỗi vận hành hệ thống phân tán.\nCấp độ 0: Deploy Thủ Công Đây là vạch xuất phát, điểm khởi đầu hỗn loạn của nhiều tổ chức. Các quy trình ở cấp độ này chủ yếu là thủ công, bị động và không có tài liệu rõ ràng.\nThực tiễn, Công cụ và Quy trình Quy trình thủ công: Việc triển khai được thực hiện bằng cách kết nối thủ công đến máy chủ thông qua các giao thức như FTP, SCP, hoặc SSH, sau đó sao chép từng tệp. Hoàn toàn không có tự động hóa. Quản lý mã nguồn hỗn loạn: Nếu có sử dụng Git, quy trình làm việc thường là “Centralized Workflow”, nơi mọi người đều đẩy (push) mã nguồn trực tiếp lên nhánh chính (main hoặc master), gây ra sự bất ổn định và khó theo dõi. “Deployment Checklist” - Tia hy vọng đầu tiên: Nỗ lực đầu tiên để tạo ra trật tự thường là một danh sách kiểm tra (checklist) thủ công. Đây là một tài liệu liệt kê các bước cần tuân theo, từ việc sao lưu cơ sở dữ liệu đến việc khởi động lại dịch vụ. Dù thô sơ, đây là bước quan trọng đầu tiên hướng tới việc chuẩn hóa quy trình. Rủi ro và Nỗi đau Rủi ro bảo mật thảm khốc: Giao thức FTP truyền thông tin đăng nhập (username, password) dưới dạng văn bản thuần (plain text), khiến chúng dễ dàng bị “bắt” bởi bất kỳ ai trên mạng. Dữ liệu truyền đi cũng không được mã hóa, có nguy cơ bị tấn công xen giữa (man-in-the-middle), nơi kẻ tấn công có thể chèn mã độc vào các tệp đang được triển khai mà không bị phát hiện. Hệ thống cực kỳ mong manh: Quy trình này rất dễ xảy ra lỗi. Chỉ cần quên một tệp, sao chép sai thư mục, hoặc một tệp truyền bị lỗi cũng có thể làm sập toàn bộ hệ thống. Không có cơ chế Rollback đáng tin cậy: Khi một lần triển khai thất bại, không có cách nào dễ dàng và tự động để quay trở lại phiên bản ổn định trước đó. “Rollback” lại là một quy trình thủ công điên cuồng khác, cố gắng khôi phục phiên bản cũ dưới áp lực cực lớn. Cái giá phải trả của con người: Cấp độ này gây ra căng thẳng cực độ, kiệt sức và một nền văn hóa sợ hãi xung quanh việc triển khai. Các bản phát hành trở nên hiếm hoi, đồ sộ và đầy rủi ro. Cấp độ 1: Tự Động Hóa Bằng Script và Quản Lý Mã Nguồn Có Cấu Trúc Khi nỗi đau của Cấp độ 0 trở nên không thể chịu đựng được, tổ chức buộc phải thực hiện bước tiến thực sự đầu tiên hướng tới tự động hóa. Trọng tâm lúc này là làm cho quy trình thủ công hiện có trở nên lặp lại được và ít bị lỗi hơn bằng cách viết script cho nó.\nThực tiễn, Công cụ và Quy trình Sự ra đời của Script triển khai: “Deployment checklist” từ Cấp độ 0 được mã hóa thành một kịch bản (script) triển khai đơn giản, thường sử dụng Bash. Script này tự động hóa các bước kết nối đến máy chủ, lấy mã nguồn mới nhất từ kho chứa, và khởi động lại các dịch vụ. Quy trình Git có cấu trúc: Nhóm nhận ra rằng việc đẩy trực tiếp lên nhánh main là không bền vững. Họ áp dụng một chiến lược phân nhánh chính thức, phổ biến nhất là Feature Branch Workflow. Nhánh main giờ đây được coi là “bất khả xâm phạm” và luôn ở trạng thái sẵn sàng để triển khai. Tất cả công việc mới (tính năng, sửa lỗi) được thực hiện trên các nhánh riêng biệt. Các thay đổi được tích hợp trở lại vào main thông qua Pull Request (hoặc Merge Request), cho phép thực hiện quy trình đánh giá mã nguồn (code review). Lợi ích và Những Vấn đề Còn Tồn Tại Lợi ích: Bản thân quy trình triển khai giờ đây đã đáng tin cậy và nhất quán hơn. Nhánh main ổn định hơn. Việc đánh giá mã nguồn giúp cải thiện chất lượng. Vấn đề còn tồn tại: Đây là một hình thức tự động hóa mong manh. Script không xử lý tốt các trường hợp thất bại. Không có kiểm thử tự động—lỗi vẫn được triển khai, chỉ là một cách nhất quán hơn. Các môi trường (development, staging, production) vẫn được cấu hình thủ công và không nhất quán, dẫn đến vấn đề kinh điển “nó chạy trên máy của tôi”. Tự động hóa quy trình triển khai không giải quyết được tất cả các vấn đề; nó chỉ làm cho chúng lộ ra rõ ràng hơn. Script bây giờ có thể triển khai một cách đáng tin cậy mã nguồn bị lỗi, hoặc thất bại vì môi trường production khác với môi trường staging. Nút thắt cổ chai không còn là các bước triển khai thủ công nữa, mà là sự thiếu vắng các cổng kiểm soát chất lượng tự động và tính nhất quán của môi trường. Khi nhóm tạo một script để tự động hóa việc triển khai, script có thể chạy nhưng ứng dụng được triển khai lại bị hỏng. Nhóm nhận ra họ không có các bài kiểm thử tự động để phát hiện lỗi trước khi triển khai. Hoặc, script chạy hoàn hảo trong môi trường staging nhưng lại thất bại trong môi trường production vì phiên bản thư viện khác nhau hoặc thiếu một cấu hình nào đó. Nhóm đi đến kết luận rằng chỉ một script là không đủ. Họ cần một hệ thống có khả năng\ntích hợp và kiểm thử mã nguồn một cách tự động và đảm bảo các môi trường phải giống hệt nhau. Nhận thức này chính là chất xúc tác trực tiếp để áp dụng CI/CD và IaC.\nCấp độ 2: Tích Hợp và Phân Phối Liên Tục (CI/CD) Đây là một bước nhảy vọt về mức độ trưởng thành. Trọng tâm chuyển từ một script triển khai đơn lẻ sang một đường ống (pipeline) tự động hóa hoàn toàn, hoạt động như một “nhà máy” trung tâm cho việc phân phối phần mềm. Đây là nơi thế giới “Dev” và “Ops” thực sự bắt đầu hợp nhất.\nCác Khái Niệm Cốt Lõi Tích hợp Liên tục (Continuous Integration - CI): Là thực tiễn tự động hóa việc tích hợp các thay đổi mã nguồn từ nhiều nhà phát triển vào một dự án duy nhất. Mỗi lần đẩy mã nguồn lên một nhánh sẽ kích hoạt một quy trình xây dựng (build) tự động và một bộ các bài kiểm thử tự động (unit test, integration test). Điều này cung cấp phản hồi nhanh chóng và ngăn chặn “địa ngục tích hợp” (integration hell). Phân phối Liên tục (Continuous Delivery - CD): Là một phần mở rộng của CI. Sau khi các giai đoạn xây dựng và kiểm thử thành công, phần mềm sẽ được đóng gói và triển khai tự động đến một hoặc nhiều môi trường phi sản xuất (như staging). Việc triển khai lên production thường là một bước thủ công, chỉ cần một cú nhấp chuột. Triển khai Liên tục (Continuous Deployment - cũng là CD): Là hình thức tiên tiến nhất, nơi mọi thay đổi vượt qua tất cả các bài kiểm thử tự động đều được triển khai tự động lên production mà không cần sự can thiệp của con người. Đường ống CI/CD là một chuỗi các bước đã được thiết lập mà các nhà phát triển phải tuân theo để cung cấp một phiên bản phần mềm mới. Nó tự động hóa các giai đoạn từ phát triển, kiểm thử, đến sản xuất và giám sát, giúp các nhóm phát triển mã chất lượng cao hơn, nhanh hơn và an toàn hơn. Các giai đoạn điển hình bao gồm: Source (lấy mã nguồn), Build (biên dịch và đóng gói), Test (chạy các bài kiểm thử tự động), và Deploy (triển khai đến các môi trường).\nCông cụ Việc lựa chọn một công cụ CI/CD là một quyết định quan trọng ở giai đoạn này. Bảng dưới đây so sánh các lựa chọn phổ biến nhất.\nTính năng Jenkins GitLab CI GitHub Actions Thiết lập \u0026 Lưu trữ Cần cài đặt thủ công, thiết lập agent, tự lưu trữ (on-premise/cloud). Tích hợp sẵn trong GitLab, không cần cài đặt riêng. Tích hợp sẵn trong GitHub, không cần cài đặt riêng. Cấu hình Jenkinsfile (viết bằng Groovy) hoặc qua giao diện người dùng (UI). Tệp YAML (.gitlab-ci.yml) trong kho mã nguồn. Tệp YAML trong thư mục .github/workflows. Hệ sinh thái \u0026 Mở rộng Cực kỳ mạnh mẽ với hơn 1800 plugin, tùy biến cao nhưng có thể phức tạp và dễ gặp vấn đề tương thích. Tích hợp sâu với các tính năng của GitLab. Hệ sinh thái plugin nhỏ hơn Jenkins. Thị trường (Marketplace) rộng lớn với các “Actions” tái sử dụng. Dễ dàng tạo action tùy chỉnh. Trường hợp sử dụng lý tưởng Các quy trình phức tạp, yêu cầu tùy biến sâu, môi trường on-premise hoặc các hệ thống cũ (legacy). Các nhóm đã và đang sử dụng GitLab làm nền tảng chính, muốn một giải pháp “tất cả trong một”. Các nhóm ưu tiên GitHub, dự án mã nguồn mở, startup, cần sự đơn giản và khởi đầu nhanh chóng. Lợi ích và Thách thức Mới Lợi ích: Vòng lặp phản hồi nhanh hơn đáng kể, chất lượng mã nguồn được cải thiện, giảm rủi ro triển khai và tăng năng suất của nhà phát triển. Thách thức: Bản thân “đường ống CI/CD” trở thành một phần mềm phức tạp cần được bảo trì. Các nhóm giờ đây phải đối mặt với những vấn đề mới như các bài kiểm thử chạy chậm hoặc không ổn định (flaky tests), quản lý các phụ thuộc phức tạp, và vấn đề dai dẳng về “trôi dạt môi trường” (environment drift), nơi môi trường staging và production không giống hệt nhau. Cấp độ 3: Hạ Tầng Dưới Dạng Mã (IaC) và Container Hóa Để giải quyết vấn đề trôi dạt môi trường và làm cho việc quản lý hạ tầng trở nên nghiêm ngặt như phát triển ứng dụng, các nhóm áp dụng triết lý “mọi thứ đều là mã nguồn”.\nCác Khái Niệm Cốt Lõi Hạ tầng dưới dạng mã (Infrastructure as Code - IaC): Là việc quản lý và cấp phát hạ tầng (máy chủ, mạng, cơ sở dữ liệu) thông qua các tệp định nghĩa mà máy có thể đọc được (mã nguồn), thay vì cấu hình thủ công. Có hai cách tiếp cận chính: Khai báo (Declarative - “Cái gì”): Bạn định nghĩa trạng thái cuối cùng mong muốn của hạ tầng. Công cụ (ví dụ: Terraform) sẽ tự tìm cách để đạt được trạng thái đó. Đây là cách tiếp cận chủ đạo trong IaC hiện đại. Mệnh lệnh (Imperative - “Như thế nào”): Bạn viết các kịch bản chỉ định các bước chính xác cần thực hiện để cấu hình hạ tầng (ví dụ: Ansible, Chef, Puppet). Sự chuyển đổi sang IaC khai báo là một bước nhảy vọt về mặt khái niệm. Nó chuyển từ “chạy các lệnh này” sang “đảm bảo trạng thái này”, một phương pháp mạnh mẽ, tự tài liệu hóa và có tính bất biến (idempotent) hơn. Container hóa với Docker: Là người bạn đồng hành hoàn hảo của IaC. Docker giải quyết vấn đề “nó chạy trên máy của tôi” bằng cách đóng gói một ứng dụng và tất cả các phụ thuộc của nó vào một đơn vị duy nhất, được tiêu chuẩn hóa và bị cô lập gọi là container. Dockerfile: “Công thức” hay bản thiết kế để xây dựng một image. Image: Một mẫu chỉ đọc (read-only) chứa ứng dụng và môi trường của nó. Container: Một thực thể đang chạy (running instance) của một image. Nó nhẹ và có tính di động cao. Quy trình Mới Đường ống CI/CD được nâng cấp. Nó không còn chỉ triển khai mã nguồn; nó xây dựng một Docker image (một tạo phẩm nhất quán được đảm bảo) và sử dụng các công cụ IaC như Terraform để cấp phát một môi trường giống hệt nơi container sẽ chạy.\nLợi ích và Nút thắt Cổ chai Tiếp theo Lợi ích: Vấn đề trôi dạt môi trường được loại bỏ. Các lần triển khai giờ đây có tính nhất quán và độ tin cậy cao trên các môi trường dev, staging và production. Các thay đổi về hạ tầng được quản lý phiên bản, được đánh giá và có thể kiểm tra lại. Nút thắt cổ chai tiếp theo: Tổ chức bây giờ đã thành công và có hàng trăm hoặc hàng nghìn container. Làm thế nào để quản lý chúng? Làm thế nào để xử lý mạng, mở rộng quy mô và kiểm tra sức khỏe cho tất cả các container này? Đây là vấn đề của việc điều phối (orchestration). Cấp độ 4: Điều Phối Container và Kiến Trúc Cloud-Native Trọng tâm chuyển từ việc quản lý các container riêng lẻ sang quản lý một ứng dụng phân tán bao gồm nhiều container ở quy mô lớn. Điều này đòi hỏi một “nhạc trưởng” cho “dàn nhạc” container.\nCác Khái Niệm Cốt Lõi: Kubernetes (K8s) Kubernetes là gì: Là hệ thống mã nguồn mở, tiêu chuẩn de-facto của ngành công nghiệp, dùng để tự động hóa việc triển khai, mở rộng quy mô và quản lý các ứng dụng được container hóa. Nó giải quyết vấn đề chạy các hệ thống phân tán một cách linh hoạt và có khả năng phục hồi. Các đối tượng Kubernetes chính (Đơn giản hóa cho người mới bắt đầu): Pod: Đơn vị triển khai nhỏ nhất, cơ bản nhất trong Kubernetes. Nó là một lớp vỏ bọc quanh một hoặc nhiều container, chia sẻ tài nguyên lưu trữ và mạng. Hãy coi nó như “nguyên tử” cơ bản của một ứng dụng K8s. Deployment: Một đối tượng cấp cao hơn mô tả trạng thái mong muốn cho ứng dụng của bạn. Nó nói với Kubernetes rằng “Tôi muốn có 3 bản sao (replica) của pod máy chủ web của tôi chạy mọi lúc.” Bộ điều khiển Deployment (Deployment Controller) sẽ làm việc để biến trạng thái này thành hiện thực. Service: Một lớp trừu tượng định nghĩa một tập hợp logic các Pod và một chính sách để truy cập chúng. Nó cung cấp một địa chỉ IP và tên DNS ổn định, để các phần khác của ứng dụng (hoặc người dùng bên ngoài) có thể kết nối đến các Pod, ngay cả khi chúng được tạo ra và phá hủy. Lợi ích và Sự Phức Tạp Mới Lợi ích: Tổ chức đạt được khả năng mở rộng quy mô thực sự, tự phục hồi (Kubernetes tự động khởi động lại các container bị lỗi), và tính sẵn sàng cao. Các bản cập nhật và quay lui (rolling updates and rollbacks) giờ đây được quản lý một cách khai báo và an toàn. Sự phức tạp mới: Bản thân Kubernetes là một hệ thống cực kỳ phức tạp. Việc học nó rất khó khăn. Quản lý, giám sát và bảo mật một cụm Kubernetes (cluster) trở thành một công việc toàn thời gian. Thách thức mới không còn là “làm thế nào để chạy ứng dụng của chúng ta?” mà là “làm thế nào để chạy Kubernetes một cách đáng tin cậy?” Kubernetes về cơ bản đã đảo ngược mô hình vận hành. Trước K8s, các nhóm Ops chịu trách nhiệm làm cho mọi thứ hoạt động. Với K8s, trách nhiệm của nhà phát triển mở rộng đến việc khai báo cách mọi thứ nên hoạt động (thông qua các tệp kê khai YAML), và bộ điều khiển của K8s trở thành “đội ngũ Ops” tự động thực thi các khai báo đó. Để làm được điều này, nhà phát triển phải viết một tệp Deployment.yaml chỉ định image container, số lượng bản sao và yêu cầu tài nguyên. Tệp YAML này là một hợp đồng, là cách nhà phát triển nói với cụm máy chủ (và qua đó là nhóm Ops quản lý cụm máy chủ) chính xác những gì họ cần. Điều này đòi hỏi nhà phát triển phải có hiểu biết sâu sắc hơn về các vấn đề vận hành (giới hạn tài nguyên, kiểm tra sức khỏe, v.v.), và đòi hỏi nhóm Ops phải cung cấp một nền tảng đáng tin cậy (cụm máy chủ) để các khai báo này có thể chạy. Trách nhiệm chung này chính là bản chất của DevOps trưởng thành.\nCấp độ 5: Vận Hành Dựa Trên Dữ Liệu (SRE, GitOps, \u0026 Observability) Đây là cấp độ trưởng thành cao nhất. Các hoạt động vận hành không còn là bị động hay thậm chí chỉ là tự động; chúng trở nên chủ động, được điều khiển bằng dữ liệu và được xem như một ngành kỹ thuật phần mềm.\nCác Khái Niệm Cốt Lõi Kỹ thuật Đảm bảo Độ tin cậy của Hệ thống (Site Reliability Engineering - SRE): Một phương pháp triển khai cụ thể của DevOps, bắt nguồn từ Google. Nó coi các vấn đề vận hành như những bài toán phần mềm. SLI, SLO, và Ngân sách Lỗi (Error Budgets): SRE cung cấp một khung làm việc toán học cho độ tin cậy. SLI (Service Level Indicator - Chỉ số Cấp độ Dịch vụ): Một thước đo định lượng về một khía cạnh nào đó của dịch vụ (ví dụ: độ trễ yêu cầu, tỷ lệ lỗi). SLO (Service Level Objective - Mục tiêu Cấp độ Dịch vụ): Một giá trị mục tiêu cho một SLI trong một khoảng thời gian (ví dụ: 99.9% yêu cầu được phục vụ trong \u003c200ms). Error Budget (Ngân sách Lỗi): Là phần nghịch đảo của SLO (100%−SLO). Đây là lượng “không đáng tin cậy” mà nhóm được phép “tiêu thụ”. Nếu ngân sách lỗi còn dương, nhóm có thể phát hành tính năng mới. Nếu nó cạn kiệt, mọi công việc phải chuyển sang cải thiện độ tin cậy. Đây là một cách tiếp cận dựa trên dữ liệu để cân bằng giữa đổi mới và sự ổn định. SRE và DevOps: DevOps là triết lý văn hóa; SRE là một cách cụ thể, có chính kiến để thực hiện nó. SRE trả lời câu hỏi “làm thế nào” cho cái “gì” của DevOps. GitOps: Sự tiến hóa của IaC và CI/CD. Git là nguồn chân lý duy nhất (single source of truth) cho toàn bộ trạng thái hệ thống (hạ tầng và ứng dụng). Quy trình làm việc: Các thay đổi được thực hiện thông qua Pull Request đến một kho chứa Git. Một agent bên trong cụm Kubernetes (như Argo CD hoặc Flux) liên tục so sánh trạng thái thực tế với trạng thái được khai báo trong Git và tự động điều chỉnh bất kỳ sự khác biệt nào. Argo CD và Flux: Argo CD giống một nền tảng hoàn chỉnh, có giao diện người dùng, trong khi Flux là một bộ công cụ mô-đun hơn, tập trung vào dòng lệnh và thường được coi là gần gũi hơn với cách tiếp cận “thuần Kubernetes”. Khả năng Quan sát (Observability): Vượt ra ngoài việc giám sát đơn giản (“máy chủ có hoạt động không?”) để đạt đến sự hiểu biết sâu sắc về hệ thống (“tại sao máy chủ lại chậm đối với người dùng ở khu vực cụ thể này?”). Ba Trụ cột của Observability: Logs (Nhật ký): Các bản ghi chi tiết, có dấu thời gian về các sự kiện riêng lẻ. Metrics (Số liệu): Dữ liệu số, được tổng hợp theo thời gian (ví dụ: mức sử dụng CPU, số lượng yêu cầu). Traces (Dấu vết): Cho thấy hành trình từ đầu đến cuối của một yêu cầu khi nó di chuyển qua một hệ thống phân tán. Công cụ: Các ngăn xếp công cụ phổ biến bao gồm Prometheus \u0026 Grafana để theo dõi số liệu và trực quan hóa, và ELK Stack (Elasticsearch, Logstash, Kibana) để quản lý nhật ký. Ở cấp độ tinh hoa, SRE, GitOps và Observability không phải là các ngành riêng biệt; chúng là một vòng lặp tích hợp chặt chẽ, tự củng cố lẫn nhau. Observability cung cấp dữ liệu thô (SLI) cần thiết để xác định SLO và ngân sách lỗi của SRE. Quy trình SRE sử dụng ngân sách lỗi để quyết định khi nào an toàn để phê duyệt một thay đổi. Thay đổi đó được đề xuất và thực thi thông qua quy trình GitOps (một pull request). Khi công cụ GitOps áp dụng thay đổi, các công cụ Observability sẽ giám sát tác động của nó, cung cấp dữ liệu mới trở lại cho các SLI. Điều này tạo ra một hệ thống vòng kín, dựa trên dữ liệu để quản lý một môi trường production phức tạp, đó là mục tiêu cuối cùng của DevOps.\nKết luận Lời khuyên Hành động Đánh giá Mức độ Trưởng thành: Các tổ chức nên sử dụng mô hình này để xác định vị trí hiện tại của nhóm mình. Tập trung vào Nút thắt Cổ chai Tiếp theo: Thay vì cố gắng nhảy từ Cấp độ 0 lên Cấp độ 5, chìa khóa là xác định điểm yếu lớn nhất hiện tại và áp dụng các thực tiễn của cấp độ tiếp theo để giải quyết nó. Quá trình này nên diễn ra từ từ và có kế hoạch. Lộ trình Kỹ năng Tóm tắt: Để phát triển cá nhân hoặc xây dựng đội ngũ, một lộ trình kỹ năng có cấu trúc là cần thiết: Nền tảng: Ngôn ngữ lập trình (Python/Go), Linux/Shell Scripting, Git. DevOps Cốt lõi: Công cụ CI/CD (Jenkins, GitLab CI, GitHub Actions), IaC (Terraform), Containers (Docker). Nâng cao/Cloud-Native: Kubernetes, Nền tảng Đám mây (AWS/GCP/Azure), Giám sát/Quan sát (Prometheus, Grafana). Tinh hoa/SRE: Hiểu biết sâu về hệ thống phân tán, triển khai SLI/SLO, tự động hóa nâng cao. Tương lai: Kỹ thuật Nền tảng (Platform Engineering) Đối với các tổ chức trưởng thành, mục tiêu của một nhóm DevOps/SRE trung tâm không phải là tự mình làm mọi thứ, mà là tạo điều kiện cho tất cả các nhà phát triển khác. Đây chính là vai trò của Kỹ thuật Nền tảng.\nMột nhóm Kỹ thuật Nền tảng xây dựng một “Nền tảng Nhà phát triển Nội bộ” (Internal Developer Platform - IDP) cung cấp một “con đường trải nhựa” cho các nhóm phát triển sản phẩm. Họ cung cấp các công cụ tự phục vụ, được tiêu chuẩn hóa cho CI/CD, cấp phát hạ tầng, giám sát và triển khai. Điều này cho phép các nhà phát triển sản phẩm triển khai mã nguồn một cách nhanh chóng và an toàn mà không cần phải là chuyên gia về Kubernetes hay Terraform. Cách tiếp cận này giúp nhân rộng các lợi ích của Cấp độ 5 trên toàn bộ tổ chức, và đây chính là đích đến cuối cùng của quá trình chuyển đổi DevOps.\nNếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!\n","wordCount":"4321","inLanguage":"en","image":"https://blog.nagih.io.vn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-17T00:00:00Z","dateModified":"2025-08-17T00:00:00Z","author":{"@type":"Person","name":"Nagih"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nagih.io.vn/posts/6-level-deploy/"},"publisher":{"@type":"Organization","name":"Nagih | Blog","logo":{"@type":"ImageObject","url":"https://blog.nagih.io.vn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nagih.io.vn/ accesskey=h title="Home (Alt + H)"><img src=https://blog.nagih.io.vn/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.nagih.io.vn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nagih.io.vn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nagih.io.vn/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.nagih.io.vn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://nagih.io.vn title=Home><span>Home</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nagih.io.vn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.nagih.io.vn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">6 Level Deploy</h1><div class=post-meta><span title='2025-08-17 00:00:00 +0000 UTC'>August 17, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4321 words&nbsp;·&nbsp;Nagih&nbsp;|&nbsp;<a href=https://github.com/vuongmanhnghia/posts/content/posts/deploy/6%20Level%20Deploy.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#hành-trình-trưởng-thành-devops>Hành Trình Trưởng Thành DevOps</a></li><li><a href=#cấp-độ-0-deploy-thủ-công>Cấp độ 0: Deploy Thủ Công</a><ul><li><a href=#thực-tiễn-công-cụ-và-quy-trình>Thực tiễn, Công cụ và Quy trình</a></li><li><a href=#rủi-ro-và-nỗi-đau>Rủi ro và Nỗi đau</a></li></ul></li><li><a href=#cấp-độ-1-tự-động-hóa-bằng-script-và-quản-lý-mã-nguồn-có-cấu-trúc>Cấp độ 1: Tự Động Hóa Bằng Script và Quản Lý Mã Nguồn Có Cấu Trúc</a><ul><li><a href=#thực-tiễn-công-cụ-và-quy-trình-1>Thực tiễn, Công cụ và Quy trình</a></li><li><a href=#lợi-ích-và-những-vấn-đề-còn-tồn-tại>Lợi ích và Những Vấn đề Còn Tồn Tại</a></li></ul></li><li><a href=#cấp-độ-2-tích-hợp-và-phân-phối-liên-tục-cicd>Cấp độ 2: Tích Hợp và Phân Phối Liên Tục (CI/CD)</a><ul><li><a href=#các-khái-niệm-cốt-lõi>Các Khái Niệm Cốt Lõi</a></li><li><a href=#công-cụ>Công cụ</a></li><li><a href=#lợi-ích-và-thách-thức-mới>Lợi ích và Thách thức Mới</a></li></ul></li><li><a href=#cấp-độ-3-hạ-tầng-dưới-dạng-mã-iac-và-container-hóa>Cấp độ 3: Hạ Tầng Dưới Dạng Mã (IaC) và Container Hóa</a><ul><li><a href=#các-khái-niệm-cốt-lõi-1>Các Khái Niệm Cốt Lõi</a></li><li><a href=#quy-trình-mới>Quy trình Mới</a></li><li><a href=#lợi-ích-và-nút-thắt-cổ-chai-tiếp-theo>Lợi ích và Nút thắt Cổ chai Tiếp theo</a></li></ul></li><li><a href=#cấp-độ-4-điều-phối-container-và-kiến-trúc-cloud-native>Cấp độ 4: Điều Phối Container và Kiến Trúc Cloud-Native</a><ul><li><a href=#các-khái-niệm-cốt-lõi-kubernetes-k8s>Các Khái Niệm Cốt Lõi: Kubernetes (K8s)</a></li><li><a href=#lợi-ích-và-sự-phức-tạp-mới>Lợi ích và Sự Phức Tạp Mới</a></li></ul></li><li><a href=#cấp-độ-5-vận-hành-dựa-trên-dữ-liệu-sre-gitops--observability>Cấp độ 5: Vận Hành Dựa Trên Dữ Liệu (SRE, GitOps, & Observability)</a><ul><li><a href=#các-khái-niệm-cốt-lõi-2>Các Khái Niệm Cốt Lõi</a></li></ul></li><li><a href=#kết-luận>Kết luận</a><ul><li><a href=#lời-khuyên-hành-động>Lời khuyên Hành động</a></li><li><a href=#tương-lai-kỹ-thuật-nền-tảng-platform-engineering>Tương lai: Kỹ thuật Nền tảng (Platform Engineering)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>6 Cấp Độ Trưởng Thành Từ Deploy Thủ Công Đến Vận Hành Tinh Gọn</p><h2 id=hành-trình-trưởng-thành-devops>Hành Trình Trưởng Thành DevOps<a hidden class=anchor aria-hidden=true href=#hành-trình-trưởng-thành-devops>#</a></h2><p>Trong thế giới phát triển phần mềm hiện đại, DevOps không chỉ là một chức danh công việc mà là một triết lý văn hóa và một tập hợp các phương pháp kỹ thuật. Mục tiêu cốt lõi của DevOps là rút ngắn vòng đời phát triển phần mềm và cung cấp sản phẩm một cách liên tục với chất lượng cao, thông qua việc phá vỡ các rào cản giữa đội ngũ Phát triển (Development - Dev) và Vận hành (Operations - Ops), thúc đẩy sự hợp tác, chia sẻ trách nhiệm và giao tiếp hiệu quả</p><p>Trước khi bắt đầu, cần phải làm rõ một sự khác biệt nền tảng nhưng thường bị nhầm lẫn: &ldquo;Deployment&rdquo; (Triển khai) và &ldquo;Release&rdquo; (Phát hành).</p><ul><li><strong>Deployment</strong> là một hoạt động <em>kỹ thuật</em>, bao gồm việc di chuyển mã nguồn từ môi trường này sang môi trường khác, ví dụ từ staging lên production. Đây là một quy trình vận hành thuần túy, tập trung vào việc đảm bảo mã nguồn chạy đúng trong môi trường mới.</li><li><strong>Release</strong> là một quyết định <em>kinh doanh</em>, liên quan đến việc cung cấp các tính năng mới cho người dùng. Quá trình này có thể bao gồm các hoạt động marketing, đào tạo người dùng, hoặc tung ra theo từng giai đoạn. Một tính năng có thể được &ldquo;deploy&rdquo; lên production nhiều lần nhưng ẩn sau một &ldquo;feature flag&rdquo; (cờ tính năng) và chỉ được &ldquo;release&rdquo; khi có quyết định từ phía kinh doanh.</li></ul><p>Hiểu rõ sự khác biệt này là chìa khóa để nhận ra rằng toàn bộ hành trình trưởng thành của DevOps về cơ bản là một cuộc tìm kiếm không ngừng nhằm quản lý và giảm thiểu rủi ro, đồng thời tăng tốc độ cung cấp giá trị cho người dùng. Mỗi cấp độ đại diện cho một chiến lược quản lý rủi ro ngày càng tinh vi hơn. Ở cấp độ thấp nhất, rủi ro cực kỳ cao, một phương pháp kém hiệu quả. Các cấp độ tiếp theo lần lượt giảm thiểu rủi ro từ lỗi con người, lỗi tích hợp, sự không nhất quán của môi trường, cho đến các lỗi vận hành hệ thống phân tán.</p><h2 id=cấp-độ-0-deploy-thủ-công>Cấp độ 0: Deploy Thủ Công<a hidden class=anchor aria-hidden=true href=#cấp-độ-0-deploy-thủ-công>#</a></h2><p>Đây là vạch xuất phát, điểm khởi đầu hỗn loạn của nhiều tổ chức. Các quy trình ở cấp độ này chủ yếu là thủ công, bị động và không có tài liệu rõ ràng.</p><h3 id=thực-tiễn-công-cụ-và-quy-trình>Thực tiễn, Công cụ và Quy trình<a hidden class=anchor aria-hidden=true href=#thực-tiễn-công-cụ-và-quy-trình>#</a></h3><ul><li><strong>Quy trình thủ công:</strong> Việc triển khai được thực hiện bằng cách kết nối thủ công đến máy chủ thông qua các giao thức như FTP, SCP, hoặc SSH, sau đó sao chép từng tệp. Hoàn toàn không có tự động hóa.</li><li><strong>Quản lý mã nguồn hỗn loạn:</strong> Nếu có sử dụng Git, quy trình làm việc thường là &ldquo;Centralized Workflow&rdquo;, nơi mọi người đều đẩy (push) mã nguồn trực tiếp lên nhánh chính (<code>main</code> hoặc <code>master</code>), gây ra sự bất ổn định và khó theo dõi.</li><li><strong>&ldquo;Deployment Checklist&rdquo; - Tia hy vọng đầu tiên:</strong> Nỗ lực đầu tiên để tạo ra trật tự thường là một danh sách kiểm tra (checklist) thủ công. Đây là một tài liệu liệt kê các bước cần tuân theo, từ việc sao lưu cơ sở dữ liệu đến việc khởi động lại dịch vụ. Dù thô sơ, đây là bước quan trọng đầu tiên hướng tới việc chuẩn hóa quy trình.</li></ul><h3 id=rủi-ro-và-nỗi-đau>Rủi ro và Nỗi đau<a hidden class=anchor aria-hidden=true href=#rủi-ro-và-nỗi-đau>#</a></h3><ul><li><strong>Rủi ro bảo mật thảm khốc:</strong> Giao thức FTP truyền thông tin đăng nhập (username, password) dưới dạng văn bản thuần (plain text), khiến chúng dễ dàng bị &ldquo;bắt&rdquo; bởi bất kỳ ai trên mạng. Dữ liệu truyền đi cũng không được mã hóa, có nguy cơ bị tấn công xen giữa (man-in-the-middle), nơi kẻ tấn công có thể chèn mã độc vào các tệp đang được triển khai mà không bị phát hiện.</li><li><strong>Hệ thống cực kỳ mong manh:</strong> Quy trình này rất dễ xảy ra lỗi. Chỉ cần quên một tệp, sao chép sai thư mục, hoặc một tệp truyền bị lỗi cũng có thể làm sập toàn bộ hệ thống.</li><li><strong>Không có cơ chế Rollback đáng tin cậy:</strong> Khi một lần triển khai thất bại, không có cách nào dễ dàng và tự động để quay trở lại phiên bản ổn định trước đó. &ldquo;Rollback&rdquo; lại là một quy trình thủ công điên cuồng khác, cố gắng khôi phục phiên bản cũ dưới áp lực cực lớn.</li><li><strong>Cái giá phải trả của con người:</strong> Cấp độ này gây ra căng thẳng cực độ, kiệt sức và một nền văn hóa sợ hãi xung quanh việc triển khai. Các bản phát hành trở nên hiếm hoi, đồ sộ và đầy rủi ro.</li></ul><h2 id=cấp-độ-1-tự-động-hóa-bằng-script-và-quản-lý-mã-nguồn-có-cấu-trúc>Cấp độ 1: Tự Động Hóa Bằng Script và Quản Lý Mã Nguồn Có Cấu Trúc<a hidden class=anchor aria-hidden=true href=#cấp-độ-1-tự-động-hóa-bằng-script-và-quản-lý-mã-nguồn-có-cấu-trúc>#</a></h2><p>Khi nỗi đau của Cấp độ 0 trở nên không thể chịu đựng được, tổ chức buộc phải thực hiện bước tiến thực sự đầu tiên hướng tới tự động hóa. Trọng tâm lúc này là làm cho quy trình thủ công hiện có trở nên lặp lại được và ít bị lỗi hơn bằng cách viết script cho nó.</p><h3 id=thực-tiễn-công-cụ-và-quy-trình-1>Thực tiễn, Công cụ và Quy trình<a hidden class=anchor aria-hidden=true href=#thực-tiễn-công-cụ-và-quy-trình-1>#</a></h3><ul><li><strong>Sự ra đời của Script triển khai:</strong> &ldquo;Deployment checklist&rdquo; từ Cấp độ 0 được mã hóa thành một kịch bản (script) triển khai đơn giản, thường sử dụng Bash. Script này tự động hóa các bước kết nối đến máy chủ, lấy mã nguồn mới nhất từ kho chứa, và khởi động lại các dịch vụ.</li><li><strong>Quy trình Git có cấu trúc:</strong> Nhóm nhận ra rằng việc đẩy trực tiếp lên nhánh <code>main</code> là không bền vững. Họ áp dụng một chiến lược phân nhánh chính thức, phổ biến nhất là <strong>Feature Branch Workflow</strong>.<ul><li>Nhánh <code>main</code> giờ đây được coi là &ldquo;bất khả xâm phạm&rdquo; và luôn ở trạng thái sẵn sàng để triển khai.</li><li>Tất cả công việc mới (tính năng, sửa lỗi) được thực hiện trên các nhánh riêng biệt.</li><li>Các thay đổi được tích hợp trở lại vào <code>main</code> thông qua Pull Request (hoặc Merge Request), cho phép thực hiện quy trình đánh giá mã nguồn (code review).</li></ul></li></ul><h3 id=lợi-ích-và-những-vấn-đề-còn-tồn-tại>Lợi ích và Những Vấn đề Còn Tồn Tại<a hidden class=anchor aria-hidden=true href=#lợi-ích-và-những-vấn-đề-còn-tồn-tại>#</a></h3><ul><li><strong>Lợi ích:</strong> Bản thân quy trình triển khai giờ đây đã đáng tin cậy và nhất quán hơn. Nhánh <code>main</code> ổn định hơn. Việc đánh giá mã nguồn giúp cải thiện chất lượng.</li><li><strong>Vấn đề còn tồn tại:</strong> Đây là một hình thức tự động hóa mong manh. Script không xử lý tốt các trường hợp thất bại. Không có kiểm thử tự động—lỗi vẫn được triển khai, chỉ là một cách nhất quán hơn. Các môi trường (development, staging, production) vẫn được cấu hình thủ công và không nhất quán, dẫn đến vấn đề kinh điển &ldquo;nó chạy trên máy của tôi&rdquo;.</li></ul><p>Tự động hóa quy trình triển khai không giải quyết được tất cả các vấn đề; nó chỉ làm cho chúng lộ ra rõ ràng hơn. Script bây giờ có thể triển khai một cách đáng tin cậy mã nguồn bị lỗi, hoặc thất bại vì môi trường production khác với môi trường staging. Nút thắt cổ chai không còn là các bước triển khai thủ công nữa, mà là sự thiếu vắng các cổng kiểm soát chất lượng tự động và tính nhất quán của môi trường. Khi nhóm tạo một script để tự động hóa việc triển khai, script có thể chạy nhưng ứng dụng được triển khai lại bị hỏng. Nhóm nhận ra họ không có các bài kiểm thử tự động để phát hiện lỗi trước khi triển khai. Hoặc, script chạy hoàn hảo trong môi trường staging nhưng lại thất bại trong môi trường production vì phiên bản thư viện khác nhau hoặc thiếu một cấu hình nào đó. Nhóm đi đến kết luận rằng chỉ một script là không đủ. Họ cần một hệ thống có khả năng</p><p><em>tích hợp</em> và <em>kiểm thử</em> mã nguồn một cách tự động và đảm bảo các môi trường phải giống hệt nhau. Nhận thức này chính là chất xúc tác trực tiếp để áp dụng CI/CD và IaC.</p><h2 id=cấp-độ-2-tích-hợp-và-phân-phối-liên-tục-cicd>Cấp độ 2: Tích Hợp và Phân Phối Liên Tục (CI/CD)<a hidden class=anchor aria-hidden=true href=#cấp-độ-2-tích-hợp-và-phân-phối-liên-tục-cicd>#</a></h2><p>Đây là một bước nhảy vọt về mức độ trưởng thành. Trọng tâm chuyển từ một script triển khai đơn lẻ sang một <strong>đường ống (pipeline)</strong> tự động hóa hoàn toàn, hoạt động như một &ldquo;nhà máy&rdquo; trung tâm cho việc phân phối phần mềm. Đây là nơi thế giới &ldquo;Dev&rdquo; và &ldquo;Ops&rdquo; thực sự bắt đầu hợp nhất.</p><h3 id=các-khái-niệm-cốt-lõi>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi>#</a></h3><ul><li><strong>Tích hợp Liên tục (Continuous Integration - CI):</strong> Là thực tiễn tự động hóa việc tích hợp các thay đổi mã nguồn từ nhiều nhà phát triển vào một dự án duy nhất. Mỗi lần đẩy mã nguồn lên một nhánh sẽ kích hoạt một quy trình xây dựng (build) tự động và một bộ các bài kiểm thử tự động (unit test, integration test). Điều này cung cấp phản hồi nhanh chóng và ngăn chặn &ldquo;địa ngục tích hợp&rdquo; (integration hell).</li><li><strong>Phân phối Liên tục (Continuous Delivery - CD):</strong> Là một phần mở rộng của CI. Sau khi các giai đoạn xây dựng và kiểm thử thành công, phần mềm sẽ được đóng gói và triển khai tự động đến một hoặc nhiều môi trường phi sản xuất (như staging). Việc triển khai lên production thường là một bước thủ công, chỉ cần một cú nhấp chuột.</li><li><strong>Triển khai Liên tục (Continuous Deployment - cũng là CD):</strong> Là hình thức tiên tiến nhất, nơi mọi thay đổi vượt qua tất cả các bài kiểm thử tự động đều được <em>triển khai tự động</em> lên production mà không cần sự can thiệp của con người.</li></ul><p>Đường ống CI/CD là một chuỗi các bước đã được thiết lập mà các nhà phát triển phải tuân theo để cung cấp một phiên bản phần mềm mới. Nó tự động hóa các giai đoạn từ phát triển, kiểm thử, đến sản xuất và giám sát, giúp các nhóm phát triển mã chất lượng cao hơn, nhanh hơn và an toàn hơn. Các giai đoạn điển hình bao gồm: Source (lấy mã nguồn), Build (biên dịch và đóng gói), Test (chạy các bài kiểm thử tự động), và Deploy (triển khai đến các môi trường).</p><h3 id=công-cụ>Công cụ<a hidden class=anchor aria-hidden=true href=#công-cụ>#</a></h3><p>Việc lựa chọn một công cụ CI/CD là một quyết định quan trọng ở giai đoạn này. Bảng dưới đây so sánh các lựa chọn phổ biến nhất.</p><table><thead><tr><th>Tính năng</th><th>Jenkins</th><th>GitLab CI</th><th>GitHub Actions</th></tr></thead><tbody><tr><td><strong>Thiết lập & Lưu trữ</strong></td><td>Cần cài đặt thủ công, thiết lập agent, tự lưu trữ (on-premise/cloud).</td><td>Tích hợp sẵn trong GitLab, không cần cài đặt riêng.</td><td>Tích hợp sẵn trong GitHub, không cần cài đặt riêng.</td></tr><tr><td><strong>Cấu hình</strong></td><td>Jenkinsfile (viết bằng Groovy) hoặc qua giao diện người dùng (UI).</td><td>Tệp YAML (<code>.gitlab-ci.yml</code>) trong kho mã nguồn.</td><td>Tệp YAML trong thư mục <code>.github/workflows</code>.</td></tr><tr><td><strong>Hệ sinh thái & Mở rộng</strong></td><td>Cực kỳ mạnh mẽ với hơn 1800 plugin, tùy biến cao nhưng có thể phức tạp và dễ gặp vấn đề tương thích.</td><td>Tích hợp sâu với các tính năng của GitLab. Hệ sinh thái plugin nhỏ hơn Jenkins.</td><td>Thị trường (Marketplace) rộng lớn với các &ldquo;Actions&rdquo; tái sử dụng. Dễ dàng tạo action tùy chỉnh.</td></tr><tr><td><strong>Trường hợp sử dụng lý tưởng</strong></td><td>Các quy trình phức tạp, yêu cầu tùy biến sâu, môi trường on-premise hoặc các hệ thống cũ (legacy).</td><td>Các nhóm đã và đang sử dụng GitLab làm nền tảng chính, muốn một giải pháp &ldquo;tất cả trong một&rdquo;.</td><td>Các nhóm ưu tiên GitHub, dự án mã nguồn mở, startup, cần sự đơn giản và khởi đầu nhanh chóng.</td></tr></tbody></table><h3 id=lợi-ích-và-thách-thức-mới>Lợi ích và Thách thức Mới<a hidden class=anchor aria-hidden=true href=#lợi-ích-và-thách-thức-mới>#</a></h3><ul><li><strong>Lợi ích:</strong> Vòng lặp phản hồi nhanh hơn đáng kể, chất lượng mã nguồn được cải thiện, giảm rủi ro triển khai và tăng năng suất của nhà phát triển.</li><li><strong>Thách thức:</strong> Bản thân &ldquo;đường ống CI/CD&rdquo; trở thành một phần mềm phức tạp cần được bảo trì. Các nhóm giờ đây phải đối mặt với những vấn đề mới như các bài kiểm thử chạy chậm hoặc không ổn định (flaky tests), quản lý các phụ thuộc phức tạp, và vấn đề dai dẳng về &ldquo;trôi dạt môi trường&rdquo; (environment drift), nơi môi trường staging và production không giống hệt nhau.</li></ul><h2 id=cấp-độ-3-hạ-tầng-dưới-dạng-mã-iac-và-container-hóa>Cấp độ 3: Hạ Tầng Dưới Dạng Mã (IaC) và Container Hóa<a hidden class=anchor aria-hidden=true href=#cấp-độ-3-hạ-tầng-dưới-dạng-mã-iac-và-container-hóa>#</a></h2><p>Để giải quyết vấn đề trôi dạt môi trường và làm cho việc quản lý hạ tầng trở nên nghiêm ngặt như phát triển ứng dụng, các nhóm áp dụng triết lý &ldquo;mọi thứ đều là mã nguồn&rdquo;.</p><h3 id=các-khái-niệm-cốt-lõi-1>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-1>#</a></h3><ul><li><strong>Hạ tầng dưới dạng mã (Infrastructure as Code - IaC):</strong> Là việc quản lý và cấp phát hạ tầng (máy chủ, mạng, cơ sở dữ liệu) thông qua các tệp định nghĩa mà máy có thể đọc được (mã nguồn), thay vì cấu hình thủ công. Có hai cách tiếp cận chính:<ul><li><strong>Khai báo (Declarative - &ldquo;Cái gì&rdquo;):</strong> Bạn định nghĩa <em>trạng thái cuối cùng</em> mong muốn của hạ tầng. Công cụ (ví dụ: Terraform) sẽ tự tìm cách để đạt được trạng thái đó. Đây là cách tiếp cận chủ đạo trong IaC hiện đại.</li><li><strong>Mệnh lệnh (Imperative - &ldquo;Như thế nào&rdquo;):</strong> Bạn viết các kịch bản chỉ định các <em>bước chính xác</em> cần thực hiện để cấu hình hạ tầng (ví dụ: Ansible, Chef, Puppet).
Sự chuyển đổi sang IaC khai báo là một bước nhảy vọt về mặt khái niệm. Nó chuyển từ &ldquo;chạy các lệnh này&rdquo; sang &ldquo;đảm bảo trạng thái này&rdquo;, một phương pháp mạnh mẽ, tự tài liệu hóa và có tính bất biến (idempotent) hơn.</li></ul></li><li><strong>Container hóa với Docker:</strong> Là người bạn đồng hành hoàn hảo của IaC. Docker giải quyết vấn đề &ldquo;nó chạy trên máy của tôi&rdquo; bằng cách đóng gói một ứng dụng và tất cả các phụ thuộc của nó vào một đơn vị duy nhất, được tiêu chuẩn hóa và bị cô lập gọi là <strong>container</strong>.<ul><li><strong>Dockerfile:</strong> &ldquo;Công thức&rdquo; hay bản thiết kế để xây dựng một image.</li><li><strong>Image:</strong> Một mẫu chỉ đọc (read-only) chứa ứng dụng và môi trường của nó.</li><li><strong>Container:</strong> Một thực thể đang chạy (running instance) của một image. Nó nhẹ và có tính di động cao.</li></ul></li></ul><h3 id=quy-trình-mới>Quy trình Mới<a hidden class=anchor aria-hidden=true href=#quy-trình-mới>#</a></h3><p>Đường ống CI/CD được nâng cấp. Nó không còn chỉ triển khai mã nguồn; nó xây dựng một Docker image (một tạo phẩm nhất quán được đảm bảo) và sử dụng các công cụ IaC như Terraform để cấp phát một môi trường giống hệt nơi container sẽ chạy.</p><h3 id=lợi-ích-và-nút-thắt-cổ-chai-tiếp-theo>Lợi ích và Nút thắt Cổ chai Tiếp theo<a hidden class=anchor aria-hidden=true href=#lợi-ích-và-nút-thắt-cổ-chai-tiếp-theo>#</a></h3><ul><li><strong>Lợi ích:</strong> Vấn đề trôi dạt môi trường được loại bỏ. Các lần triển khai giờ đây có tính nhất quán và độ tin cậy cao trên các môi trường dev, staging và production. Các thay đổi về hạ tầng được quản lý phiên bản, được đánh giá và có thể kiểm tra lại.</li><li><strong>Nút thắt cổ chai tiếp theo:</strong> Tổ chức bây giờ đã thành công và có hàng trăm hoặc hàng nghìn container. Làm thế nào để quản lý chúng? Làm thế nào để xử lý mạng, mở rộng quy mô và kiểm tra sức khỏe cho tất cả các container này? Đây là vấn đề của việc <strong>điều phối (orchestration)</strong>.</li></ul><h2 id=cấp-độ-4-điều-phối-container-và-kiến-trúc-cloud-native>Cấp độ 4: Điều Phối Container và Kiến Trúc Cloud-Native<a hidden class=anchor aria-hidden=true href=#cấp-độ-4-điều-phối-container-và-kiến-trúc-cloud-native>#</a></h2><p>Trọng tâm chuyển từ việc quản lý các container riêng lẻ sang quản lý một ứng dụng phân tán bao gồm nhiều container ở quy mô lớn. Điều này đòi hỏi một &ldquo;nhạc trưởng&rdquo; cho &ldquo;dàn nhạc&rdquo; container.</p><h3 id=các-khái-niệm-cốt-lõi-kubernetes-k8s>Các Khái Niệm Cốt Lõi: Kubernetes (K8s)<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-kubernetes-k8s>#</a></h3><ul><li><strong>Kubernetes là gì:</strong> Là hệ thống mã nguồn mở, tiêu chuẩn de-facto của ngành công nghiệp, dùng để tự động hóa việc triển khai, mở rộng quy mô và quản lý các ứng dụng được container hóa. Nó giải quyết vấn đề chạy các hệ thống phân tán một cách linh hoạt và có khả năng phục hồi.</li><li><strong>Các đối tượng Kubernetes chính (Đơn giản hóa cho người mới bắt đầu):</strong><ul><li><strong>Pod:</strong> Đơn vị triển khai nhỏ nhất, cơ bản nhất trong Kubernetes. Nó là một lớp vỏ bọc quanh một hoặc nhiều container, chia sẻ tài nguyên lưu trữ và mạng. Hãy coi nó như &ldquo;nguyên tử&rdquo; cơ bản của một ứng dụng K8s.</li><li><strong>Deployment:</strong> Một đối tượng cấp cao hơn mô tả <em>trạng thái mong muốn</em> cho ứng dụng của bạn. Nó nói với Kubernetes rằng &ldquo;Tôi muốn có 3 bản sao (replica) của pod máy chủ web của tôi chạy mọi lúc.&rdquo; Bộ điều khiển Deployment (Deployment Controller) sẽ làm việc để biến trạng thái này thành hiện thực.</li><li><strong>Service:</strong> Một lớp trừu tượng định nghĩa một tập hợp logic các Pod và một chính sách để truy cập chúng. Nó cung cấp một địa chỉ IP và tên DNS ổn định, để các phần khác của ứng dụng (hoặc người dùng bên ngoài) có thể kết nối đến các Pod, ngay cả khi chúng được tạo ra và phá hủy.</li></ul></li></ul><h3 id=lợi-ích-và-sự-phức-tạp-mới>Lợi ích và Sự Phức Tạp Mới<a hidden class=anchor aria-hidden=true href=#lợi-ích-và-sự-phức-tạp-mới>#</a></h3><ul><li><strong>Lợi ích:</strong> Tổ chức đạt được khả năng mở rộng quy mô thực sự, tự phục hồi (Kubernetes tự động khởi động lại các container bị lỗi), và tính sẵn sàng cao. Các bản cập nhật và quay lui (rolling updates and rollbacks) giờ đây được quản lý một cách khai báo và an toàn.</li><li><strong>Sự phức tạp mới:</strong> Bản thân Kubernetes là một hệ thống cực kỳ phức tạp. Việc học nó rất khó khăn. Quản lý, giám sát và bảo mật một cụm Kubernetes (cluster) trở thành một công việc toàn thời gian. Thách thức mới không còn là &ldquo;làm thế nào để chạy ứng dụng của chúng ta?&rdquo; mà là &ldquo;làm thế nào để chạy Kubernetes một cách đáng tin cậy?&rdquo;</li></ul><p>Kubernetes về cơ bản đã đảo ngược mô hình vận hành. Trước K8s, các nhóm Ops chịu trách nhiệm <em>làm cho mọi thứ hoạt động</em>. Với K8s, trách nhiệm của nhà phát triển mở rộng đến việc <em>khai báo cách mọi thứ nên hoạt động</em> (thông qua các tệp kê khai YAML), và bộ điều khiển của K8s trở thành &ldquo;đội ngũ Ops&rdquo; tự động thực thi các khai báo đó. Để làm được điều này, nhà phát triển phải viết một tệp <code>Deployment.yaml</code> chỉ định image container, số lượng bản sao và yêu cầu tài nguyên. Tệp YAML này là một hợp đồng, là cách nhà phát triển nói với cụm máy chủ (và qua đó là nhóm Ops quản lý cụm máy chủ) chính xác những gì họ cần. Điều này đòi hỏi nhà phát triển phải có hiểu biết sâu sắc hơn về các vấn đề vận hành (giới hạn tài nguyên, kiểm tra sức khỏe, v.v.), và đòi hỏi nhóm Ops phải cung cấp một nền tảng đáng tin cậy (cụm máy chủ) để các khai báo này có thể chạy. Trách nhiệm chung này chính là bản chất của DevOps trưởng thành.</p><h2 id=cấp-độ-5-vận-hành-dựa-trên-dữ-liệu-sre-gitops--observability>Cấp độ 5: Vận Hành Dựa Trên Dữ Liệu (SRE, GitOps, & Observability)<a hidden class=anchor aria-hidden=true href=#cấp-độ-5-vận-hành-dựa-trên-dữ-liệu-sre-gitops--observability>#</a></h2><p>Đây là cấp độ trưởng thành cao nhất. Các hoạt động vận hành không còn là bị động hay thậm chí chỉ là tự động; chúng trở nên chủ động, được điều khiển bằng dữ liệu và được xem như một ngành kỹ thuật phần mềm.</p><h3 id=các-khái-niệm-cốt-lõi-2>Các Khái Niệm Cốt Lõi<a hidden class=anchor aria-hidden=true href=#các-khái-niệm-cốt-lõi-2>#</a></h3><ul><li><strong>Kỹ thuật Đảm bảo Độ tin cậy của Hệ thống (Site Reliability Engineering - SRE):</strong> Một phương pháp triển khai cụ thể của DevOps, bắt nguồn từ Google. Nó coi các vấn đề vận hành như những bài toán phần mềm.<ul><li><strong>SLI, SLO, và Ngân sách Lỗi (Error Budgets):</strong> SRE cung cấp một khung làm việc toán học cho độ tin cậy.<ul><li><strong>SLI (Service Level Indicator - Chỉ số Cấp độ Dịch vụ):</strong> Một thước đo định lượng về một khía cạnh nào đó của dịch vụ (ví dụ: độ trễ yêu cầu, tỷ lệ lỗi).</li><li><strong>SLO (Service Level Objective - Mục tiêu Cấp độ Dịch vụ):</strong> Một giá trị mục tiêu cho một SLI trong một khoảng thời gian (ví dụ: 99.9% yêu cầu được phục vụ trong &lt;200ms).</li><li><strong>Error Budget (Ngân sách Lỗi):</strong> Là phần nghịch đảo của SLO (100%−SLO). Đây là lượng &ldquo;không đáng tin cậy&rdquo; mà nhóm được phép &ldquo;tiêu thụ&rdquo;. Nếu ngân sách lỗi còn dương, nhóm có thể phát hành tính năng mới. Nếu nó cạn kiệt, mọi công việc phải chuyển sang cải thiện độ tin cậy. Đây là một cách tiếp cận dựa trên dữ liệu để cân bằng giữa đổi mới và sự ổn định.</li></ul></li><li><strong>SRE và DevOps:</strong> DevOps là triết lý văn hóa; SRE là một cách cụ thể, có chính kiến để thực hiện nó. SRE trả lời câu hỏi &ldquo;làm thế nào&rdquo; cho cái &ldquo;gì&rdquo; của DevOps.</li></ul></li><li><strong>GitOps:</strong> Sự tiến hóa của IaC và CI/CD. Git là <strong>nguồn chân lý duy nhất (single source of truth)</strong> cho <em>toàn bộ</em> trạng thái hệ thống (hạ tầng và ứng dụng).<ul><li><strong>Quy trình làm việc:</strong> Các thay đổi được thực hiện thông qua Pull Request đến một kho chứa Git. Một agent bên trong cụm Kubernetes (như Argo CD hoặc Flux) liên tục so sánh trạng thái thực tế với trạng thái được khai báo trong Git và tự động điều chỉnh bất kỳ sự khác biệt nào.</li><li><strong>Argo CD và Flux:</strong> Argo CD giống một nền tảng hoàn chỉnh, có giao diện người dùng, trong khi Flux là một bộ công cụ mô-đun hơn, tập trung vào dòng lệnh và thường được coi là gần gũi hơn với cách tiếp cận &ldquo;thuần Kubernetes&rdquo;.</li></ul></li><li><strong>Khả năng Quan sát (Observability):</strong> Vượt ra ngoài việc giám sát đơn giản (&ldquo;máy chủ có hoạt động không?&rdquo;) để đạt đến sự hiểu biết sâu sắc về hệ thống (&ldquo;tại sao máy chủ lại chậm đối với người dùng ở khu vực cụ thể này?&rdquo;).<ul><li><strong>Ba Trụ cột của Observability:</strong><ul><li><strong>Logs (Nhật ký):</strong> Các bản ghi chi tiết, có dấu thời gian về các sự kiện riêng lẻ.</li><li><strong>Metrics (Số liệu):</strong> Dữ liệu số, được tổng hợp theo thời gian (ví dụ: mức sử dụng CPU, số lượng yêu cầu).</li><li><strong>Traces (Dấu vết):</strong> Cho thấy hành trình từ đầu đến cuối của một yêu cầu khi nó di chuyển qua một hệ thống phân tán.</li></ul></li><li><strong>Công cụ:</strong> Các ngăn xếp công cụ phổ biến bao gồm Prometheus & Grafana để theo dõi số liệu và trực quan hóa, và ELK Stack (Elasticsearch, Logstash, Kibana) để quản lý nhật ký.</li></ul></li></ul><p>Ở cấp độ tinh hoa, SRE, GitOps và Observability không phải là các ngành riêng biệt; chúng là một vòng lặp tích hợp chặt chẽ, tự củng cố lẫn nhau. Observability cung cấp dữ liệu thô (SLI) cần thiết để xác định SLO và ngân sách lỗi của SRE. Quy trình SRE sử dụng ngân sách lỗi để quyết định <em>khi nào</em> an toàn để phê duyệt một thay đổi. Thay đổi đó được đề xuất và thực thi thông qua quy trình GitOps (một pull request). Khi công cụ GitOps áp dụng thay đổi, các công cụ Observability sẽ giám sát tác động của nó, cung cấp dữ liệu mới trở lại cho các SLI. Điều này tạo ra một hệ thống vòng kín, dựa trên dữ liệu để quản lý một môi trường production phức tạp, đó là mục tiêu cuối cùng của DevOps.</p><h2 id=kết-luận>Kết luận<a hidden class=anchor aria-hidden=true href=#kết-luận>#</a></h2><h3 id=lời-khuyên-hành-động>Lời khuyên Hành động<a hidden class=anchor aria-hidden=true href=#lời-khuyên-hành-động>#</a></h3><ul><li><strong>Đánh giá Mức độ Trưởng thành:</strong> Các tổ chức nên sử dụng mô hình này để xác định vị trí hiện tại của nhóm mình.</li><li><strong>Tập trung vào Nút thắt Cổ chai Tiếp theo:</strong> Thay vì cố gắng nhảy từ Cấp độ 0 lên Cấp độ 5, chìa khóa là xác định điểm yếu lớn nhất hiện tại và áp dụng các thực tiễn của cấp độ tiếp theo để giải quyết nó. Quá trình này nên diễn ra từ từ và có kế hoạch.</li><li><strong>Lộ trình Kỹ năng Tóm tắt:</strong> Để phát triển cá nhân hoặc xây dựng đội ngũ, một lộ trình kỹ năng có cấu trúc là cần thiết:<ol><li><strong>Nền tảng:</strong> Ngôn ngữ lập trình (Python/Go), Linux/Shell Scripting, Git.</li><li><strong>DevOps Cốt lõi:</strong> Công cụ CI/CD (Jenkins, GitLab CI, GitHub Actions), IaC (Terraform), Containers (Docker).</li><li><strong>Nâng cao/Cloud-Native:</strong> Kubernetes, Nền tảng Đám mây (AWS/GCP/Azure), Giám sát/Quan sát (Prometheus, Grafana).</li><li><strong>Tinh hoa/SRE:</strong> Hiểu biết sâu về hệ thống phân tán, triển khai SLI/SLO, tự động hóa nâng cao.</li></ol></li></ul><h3 id=tương-lai-kỹ-thuật-nền-tảng-platform-engineering>Tương lai: Kỹ thuật Nền tảng (Platform Engineering)<a hidden class=anchor aria-hidden=true href=#tương-lai-kỹ-thuật-nền-tảng-platform-engineering>#</a></h3><p>Đối với các tổ chức trưởng thành, mục tiêu của một nhóm DevOps/SRE trung tâm không phải là tự mình làm mọi thứ, mà là <em>tạo điều kiện</em> cho tất cả các nhà phát triển khác. Đây chính là vai trò của <strong>Kỹ thuật Nền tảng</strong>.</p><p>Một nhóm Kỹ thuật Nền tảng xây dựng một &ldquo;Nền tảng Nhà phát triển Nội bộ&rdquo; (Internal Developer Platform - IDP) cung cấp một &ldquo;con đường trải nhựa&rdquo; cho các nhóm phát triển sản phẩm. Họ cung cấp các công cụ tự phục vụ, được tiêu chuẩn hóa cho CI/CD, cấp phát hạ tầng, giám sát và triển khai. Điều này cho phép các nhà phát triển sản phẩm triển khai mã nguồn một cách nhanh chóng và an toàn mà không cần phải là chuyên gia về Kubernetes hay Terraform. Cách tiếp cận này giúp nhân rộng các lợi ích của Cấp độ 5 trên toàn bộ tổ chức, và đây chính là đích đến cuối cùng của quá trình chuyển đổi DevOps.</p><hr><p><em>Nếu thấy hay, hãy để lại cho mình 1 comment xuống phía dưới để mình có động lực viết các blog chất lượng tiếp theo nhé!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nagih.io.vn/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://blog.nagih.io.vn/posts/desgin-microservices/><span class=title>« Prev</span><br><span>Desgin Microservices</span>
</a><a class=next href=https://blog.nagih.io.vn/posts/nginx/><span class=title>Next »</span><br><span>Nginx Overview</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on x" href="https://x.com/intent/tweet/?text=6%20Level%20Deploy&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f&amp;hashtags=docker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f&amp;title=6%20Level%20Deploy&amp;summary=6%20Level%20Deploy&amp;source=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f&title=6%20Level%20Deploy"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on whatsapp" href="https://api.whatsapp.com/send?text=6%20Level%20Deploy%20-%20https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on telegram" href="https://telegram.me/share/url?text=6%20Level%20Deploy&amp;url=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 6 Level Deploy on ycombinator" href="https://news.ycombinator.com/submitlink?t=6%20Level%20Deploy&u=https%3a%2f%2fblog.nagih.io.vn%2fposts%2f6-level-deploy%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nagih.io.vn/>Nagih | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>