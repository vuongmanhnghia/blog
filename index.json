
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"Docker and Docker compose tutorial\nPhần 1: Cuộc Cách Mạng Container - Thấu Hiểu Các Nguyên Tắc Cốt Lõi của Docker 1.1 Giới thiệu về Docker: Tại sao lại là một cuộc cách mạng? Trong thế giới phát triển phần mềm hiện đại, Docker đã nổi lên như một công nghệ nền tảng, thay đổi cách các lập trình viên xây dựng, vận chuyển và chạy ứng dụng. Về cơ bản, Docker là một nền tảng mã nguồn mở được thiết kế để tự động hóa việc triển khai ứng dụng bên trong các môi trường biệt lập, nhẹ được gọi là container. Mỗi container đóng gói phần mềm cùng với tất cả những gì nó cần để hoạt động—bao gồm thư viện, công cụ hệ thống, mã nguồn và thời gian chạy (runtime)—thành một đơn vị tiêu chuẩn hóa.\nĐể hiểu rõ giá trị của Docker, điều quan trọng là phải phân biệt nó với công nghệ ảo hóa truyền thống: máy ảo (Virtual Machines - VMs).\nMáy ảo (VMs): Một máy ảo ảo hóa toàn bộ phần cứng vật lý, cho phép nhiều hệ điều hành khách (guest OS) chạy trên một máy chủ chủ (host server) duy nhất. Mỗi VM bao gồm một bản sao đầy đủ của một hệ điều hành, các tệp nhị phân và thư viện cần thiết, và chính ứng dụng. Điều này dẫn đến sự cô lập mạnh mẽ nhưng phải trả giá bằng việc tiêu tốn tài nguyên đáng kể, kích thước lớn (hàng gigabyte) và thời gian khởi động chậm.\nContainers: Ngược lại, container ảo hóa ở cấp độ hệ điều hành. Thay vì đóng gói cả một hệ điều hành khách, các container chia sẻ nhân (kernel) của hệ điều hành máy chủ. Chúng chỉ đóng gói ứng dụng và các dependencies của nó. Kết quả là các container cực kỳ nhẹ (thường chỉ vài chục megabyte), khởi động gần như tức thì và cho phép mật độ ứng dụng cao hơn nhiều trên cùng một phần cứng.\nSự thay đổi mô hình này mang lại những lợi ích to lớn, định hình lại toàn bộ vòng đời phát triển phần mềm:\nPhân phối ứng dụng nhanh chóng, nhất quán: Docker giải quyết triệt để vấn đề kinh điển “nó chạy trên máy tôi nhưng không chạy trên production”. Bằng cách đóng gói ứng dụng và môi trường của nó lại với nhau, Docker đảm bảo tính nhất quán trên các môi trường phát triển, kiểm thử và sản xuất.\nTính di động (Portability) vượt trội: Một container được xây dựng trên máy tính xách tay của lập trình viên có thể chạy không thay đổi trên bất kỳ hệ thống nào có cài đặt Docker, cho dù đó là máy chủ vật lý tại chỗ, máy ảo trên đám mây hay trong một môi trường lai.\nHiệu quả và Tiết kiệm chi phí: Vì các container nhẹ hơn nhiều so với VM, chúng cho phép chạy nhiều ứng dụng hơn trên cùng một cơ sở hạ tầng. Điều này cải thiện đáng kể việc sử dụng tài nguyên và giúp tiết kiệm chi phí phần cứng và cấp phép.\nTăng tốc quy trình phát triển (CI/CD): Docker tích hợp liền mạch vào các quy trình Tích hợp liên tục và Triển khai liên tục (CI/CD). Các image container có thể được xây dựng, kiểm thử và đẩy lên registry một cách tự động, giúp tăng tốc độ phát hành phần mềm một cách đáng kể.\nSự phổ biến của Docker không chỉ là một thành tựu kỹ thuật; nó là chất xúc tác trực tiếp cho văn hóa DevOps. Các lợi ích kỹ thuật như môi trường chuẩn hóa 1 và tính di động 8 đã cung cấp cơ chế thực tế để thực hiện các nguyên lý cốt lõi của DevOps: phá vỡ các rào cản giữa phát triển (Dev) và vận hành (Ops), tự động hóa các quy trình, và tăng tần suất triển khai. Docker không chỉ tạo ra một công cụ mới; nó đã biến DevOps từ một triết lý thành một thực tiễn khả thi cho hàng triệu lập trình viên trên toàn thế giới.\n1.2 Hệ sinh thái Docker: Các Thành phần Cơ bản Để làm việc hiệu quả với Docker, việc nắm vững các khái niệm và thành phần cốt lõi của nó là điều bắt buộc.\nKiến trúc Docker\nDocker hoạt động theo kiến trúc client-server. Thành phần chính bao gồm:\nDocker Daemon (dockerd): Một dịch vụ nền chạy trên máy chủ, chịu trách nhiệm xây dựng, chạy và quản lý các đối tượng Docker như images, containers, networks và volumes.\nDocker Client (docker): Công cụ dòng lệnh (CLI) mà người dùng tương tác. Khi một lệnh như docker run được thực thi, client sẽ gửi yêu cầu đến daemon thông qua REST API qua socket UNIX hoặc giao diện mạng.\nImages và Containers: Bản thiết kế và Thực thể\nĐây là khái niệm cơ bản và quan trọng nhất trong Docker, thường gây nhầm lẫn cho người mới bắt đầu. Một phép ẩn dụ hữu ích là xem Image như một Class trong lập trình hướng đối tượng và Container như một Instance của class đó.\nImage: Một Docker image là một mẫu (template) chỉ đọc (read-only) và bất biến (immutable) chứa một tập hợp các chỉ dẫn để tạo ra một container. Nó giống như một bản thiết kế chi tiết, bao gồm mã nguồn ứng dụng, runtime, thư viện, biến môi trường và các tệp cấu hình. Images được xây dựng từ một\nDockerfile và bao gồm một loạt các lớp (layers) xếp chồng lên nhau. Mỗi chỉ thị trong Dockerfile tạo ra một lớp mới. Tính bất biến này chính là nguyên nhân trực tiếp tạo ra khả năng tái tạo và tính nhất quán mà Docker cung cấp; vì image không thể thay đổi, mọi container được khởi tạo từ nó đều được đảm bảo giống hệt nhau, loại bỏ hoàn toàn sự trôi dạt môi trường.\nContainer: Một Docker container là một thực thể đang chạy (a running instance) của một image. Khi Docker tạo một container …","date":1755043200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"9ee2d4aed02069512028d5365f982862","permalink":"https://blog.nagih.io.vn/post/docker/docker/","publishdate":"2025-08-13T00:00:00Z","relpermalink":"/post/docker/docker/","section":"post","summary":"Docker and Docker compose tutorial\n","tags":["docker","vi"],"title":"Docker","type":"post"},{"authors":null,"categories":null,"content":"Mastering Internet Protocol Addresses\nĐối với một người dùng Linux, dù bạn là nhà phát triển, quản trị viên hệ thống hay chỉ là một người đam mê công nghệ, việc hiểu sâu và làm chủ địa chỉ IP không chỉ là một kỹ năng hữu ích mà còn là một yêu cầu thiết yếu.\nBài viết này sẽ là kim chỉ nam của bạn, dẫn dắt bạn đi từ những khái niệm cơ bản nhất như “Địa chỉ IP là gì?” đến các kỹ thuật nâng cao như cấu hình mạng, quét tìm thiết bị và thiết lập kết nối từ xa an toàn. Chúng ta sẽ cùng nhau “mổ xẻ” các lệnh, khám phá các công cụ và áp dụng chúng vào những kịch bản thực tế, giúp bạn tự tin điều hướng trong không gian mạng rộng lớn bằng sức mạnh của dòng lệnh Linux.\nPhần 1: Giải Phẫu Địa Chỉ IP: Nền Tảng của Thế Giới Số Trước khi đi sâu vào các câu lệnh và cấu hình, việc xây dựng một nền tảng kiến thức vững chắc về bản chất của địa chỉ IP là vô cùng quan trọng. Phần này sẽ giải mã các khái niệm cốt lõi, giúp bạn hiểu rõ “tại sao” và “như thế nào” trước khi học “làm gì”.\n1.1. Địa chỉ IP là gì? Hơn Cả những Con Số Vai trò Cốt lõi: “Địa chỉ Nhà Kỹ thuật số” của Thiết bị\nVề cơ bản, địa chỉ Giao thức Internet (Internet Protocol address), hay địa chỉ IP, là một định danh số duy nhất được gán cho mỗi thiết bị điện tử (như máy tính, điện thoại, máy chủ) khi tham gia vào một mạng máy tính sử dụng Giao thức Internet để giao tiếp. Hãy hình dung nó như một địa chỉ nhà trong thế giới thực; để một lá thư (dữ liệu) có thể được gửi đến đúng người nhận (thiết bị), nó cần một địa chỉ chính xác. Mục đích chính của địa chỉ IP là để nhận diện thiết bị và xác định vị trí của nó trên mạng, từ đó cho phép việc truyền và nhận dữ liệu diễn ra một cách chính xác.\nMọi dữ liệu di chuyển trên mạng đều được chia thành các đơn vị nhỏ hơn gọi là “gói tin” (packets). Mỗi gói tin này không chỉ chứa một phần dữ liệu mà còn mang theo một phần “tiêu đề” (header). Trong tiêu đề này, thông tin quan trọng nhất chính là địa chỉ IP của người gửi (nguồn) và địa chỉ IP của người nhận (đích). Cấu trúc này đảm bảo rằng dù các gói tin có thể đi theo những con đường khác nhau qua Internet, chúng vẫn sẽ đến được đúng đích và được tập hợp lại một cách chính xác.\nTuy nhiên, việc ví IP như một “địa chỉ nhà” chỉ là bước khởi đầu. Một sự tương đồng chính xác hơn cho người dùng kỹ thuật là: địa chỉ IP giống như địa chỉ của vị trí bạn đang kết nối mạng, trong khi địa chỉ MAC (Media Access Control) mới thực sự là số sê-ri định danh duy nhất của thiết bị đó. Địa chỉ MAC là một địa chỉ vật lý, được gán cứng vào card mạng của bạn bởi nhà sản xuất và không thay đổi. Ngược lại, địa chỉ IP của bạn có thể thay đổi. Khi bạn mang laptop từ nhà (kết nối vào mạng Wi-Fi gia đình) đến một quán cà phê (kết nối vào mạng Wi-Fi của quán), địa chỉ MAC của laptop vẫn giữ nguyên, nhưng nó sẽ được cấp một địa chỉ IP mới tương ứng với mạng của quán cà phê. Việc phân biệt rõ ràng giữa định danh thiết bị (MAC, Lớp 2) và định danh vị trí mạng (IP, Lớp 3) là chìa khóa để hiểu các khái niệm như DHCP, tính di động của mạng và cách các lớp khác nhau trong mô hình mạng tương tác với nhau.\nCỗ máy Vận hành: Giao thức IP và Vị trí trong Chồng Giao thức TCP/IP\nĐịa chỉ IP không tồn tại một mình; nó là một phần không thể tách rời của bộ giao thức TCP/IP, bộ khung xương sống của Internet hiện đại. TCP/IP là một mô hình phân tầng, trong đó Giao thức IP hoạt động ở Tầng Mạng (Network Layer), hay còn gọi là Tầng Internet, tương ứng với Lớp 3 trong mô hình tham chiếu OSI (Open Systems Interconnection).\nTrong bộ đôi này, mỗi giao thức có một nhiệm vụ riêng biệt:\nIP (Internet Protocol): Chịu trách nhiệm về việc định địa chỉ và định tuyến. Nó gắn địa chỉ IP vào các gói tin và quyết định con đường mà các gói tin đó sẽ đi qua mạng để đến đích. IP hoạt động theo nguyên tắc “nỗ lực tốt nhất” (best-effort), nghĩa là nó không đảm bảo các gói tin sẽ đến nơi, đến đúng thứ tự, hay không bị lỗi.\nTCP (Transmission Control Protocol): Hoạt động ở tầng trên (Tầng Giao vận - Transport Layer), TCP bổ sung cho sự thiếu tin cậy của IP. Nó thiết lập một kết nối ổn định, đảm bảo rằng tất cả các gói tin đều đến đích một cách toàn vẹn và theo đúng thứ tự. Nếu một gói tin bị mất, TCP sẽ yêu cầu gửi lại.\nSự kết hợp giữa một hệ thống địa chỉ và định tuyến toàn cầu (IP) và một cơ chế đảm bảo truyền tải đáng tin cậy (TCP) chính là thứ đã tạo nên một Internet mạnh mẽ và linh hoạt như ngày nay.\nHành trình của một Gói tin: Cách Dữ liệu Di chuyển trên Internet\nHãy xem xét một hành động quen thuộc: bạn gõ google.com vào trình duyệt. Đây là những gì xảy ra đằng sau hậu trường:\nPhân giải DNS: Máy tính của bạn không biết google.com ở đâu. Nó gửi một yêu cầu đến một Máy chủ Tên miền (DNS - Domain Name System) để hỏi: “Địa chỉ IP của google.com là gì?”. Máy chủ DNS sẽ trả lời bằng một địa chỉ IP, ví dụ 172.217.24.238.\nĐóng gói và Gửi đi: Trình duyệt của bạn tạo một yêu cầu (ví dụ: HTTP GET) và chuyển nó xuống các tầng thấp hơn của mô hình TCP/IP. Dữ liệu được chia thành các gói tin, mỗi gói được gắn tiêu đề chứa IP nguồn (máy của bạn) và IP đích (máy …","date":1755043200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"ddf48f95c2ff19e1edbdf2879ae7dace","permalink":"https://blog.nagih.io.vn/post/network/ip/","publishdate":"2025-08-13T00:00:00Z","relpermalink":"/post/network/ip/","section":"post","summary":"Mastering Internet Protocol Addresses\n","tags":["network","vi"],"title":"Internet Protocol (IP)","type":"post"},{"authors":null,"categories":null,"content":"SSH and GitHub Tutorial\nTrong hệ sinh thái phát triển phần mềm hiện đại, GitHub không chỉ là một kho lưu trữ mã nguồn mà còn là trung tâm cộng tác, quản lý dự án và triển khai ứng dụng. Việc tương tác hiệu quả và an toàn với nền tảng này là một kỹ năng cơ bản đối với mọi nhà phát triển. Mặc dù HTTPS cung cấp một phương thức kết nối ban đầu đơn giản, việc chuyển sang sử dụng giao thức SSH (Secure Shell) là một bước tiến quan trọng, không chỉ nâng cao đáng kể mức độ bảo mật mà còn tối ưu hóa quy trình làm việc hàng ngày.\nBlog này sẽ cung cấp một hướng dẫn chi tiết và toàn diện về việc thiết lập và sử dụng khóa SSH để kết nối với GitHub. Chúng ta sẽ đi từ những khái niệm cơ bản, lý do tại sao SSH là lựa chọn ưu việt, các bước cấu hình chi tiết, đến việc quản lý nhiều tài khoản phức tạp và xử lý các lỗi thường gặp. Mục tiêu là trang bị cho các nhà phát triển, từ người mới bắt đầu đến các chuyên gia dày dạn kinh nghiệm, kiến thức và công cụ cần thiết để làm chủ phương thức kết nối an toàn và hiệu quả này.\nPhần 1: Nâng Cấp Bảo Mật và Sự Tiện Lợi với SSH Trước khi đi sâu vào các bước kỹ thuật, điều quan trọng là phải hiểu rõ tại sao việc chuyển đổi từ HTTPS sang SSH lại là một nâng cấp đáng giá cho quy trình làm việc của một nhà phát triển chuyên nghiệp.\nNhững Hạn Chế của Xác thực qua HTTPS Khi bắt đầu với Git và GitHub, hầu hết người dùng đều chọn HTTPS vì sự đơn giản của nó. Tuy nhiên, phương thức này có những hạn chế cố hữu. Xác thực qua HTTPS yêu cầu sử dụng Personal Access Token (PAT), một chuỗi ký tự hoạt động tương tự như mật khẩu.\nMặc dù dễ thiết lập, quy trình này bộc lộ sự bất tiện trong quá trình sử dụng lâu dài. Git sẽ thường xuyên yêu cầu người dùng nhập thông tin xác thực, làm gián đoạn luồng công việc. Mặc dù các công cụ hỗ trợ quản lý thông tin đăng nhập (credential helpers) có thể lưu trữ token, nhưng chúng lại đặt ra một vấn đề khác về mức độ an toàn của việc lưu trữ này. Quan trọng hơn, một PAT bị rò rỉ có thể cấp cho kẻ tấn công quyền truy cập không chỉ vào các kho lưu trữ mà còn có thể vào toàn bộ tài khoản GitHub, tùy thuộc vào phạm vi quyền hạn được cấp cho token đó.\nSo Sánh Nhanh: HTTPS và SSH trên GitHub Để tóm tắt những khác biệt chính, bảng dưới đây cung cấp một cái nhìn tổng quan về hai phương thức xác thực.\nTiêu chí HTTPS (với Personal Access Token) SSH Cơ chế Xác thực Dựa trên token (hoạt động như mật khẩu) 1 Cặp khóa Public/Private (mật mã bất đối xứng) 1 Mức độ Bảo mật Dễ bị lộ nếu token không được bảo vệ cẩn thận 3 Rất cao; khóa riêng tư không bao giờ truyền qua mạng 4 Sự tiện lợi Yêu cầu nhập lại token hoặc phụ thuộc vào credential helper 3 Rất tiện lợi sau khi thiết lập, không cần nhập lại thông tin 8 Thiết lập ban đầu Đơn giản, chỉ cần tạo token 2 Phức tạp hơn một chút, yêu cầu tạo và quản lý cặp khóa 2 Quản lý Truy cập Phân quyền thông qua phạm vi của token trên GitHub 1 Có thể quản lý truy cập chi tiết qua từng khóa riêng lẻ 1 Phần 2: Hướng Dẫn Thiết Lập Khóa SSH Từ A đến Z Phần này sẽ hướng dẫn chi tiết từng bước để tạo và cấu hình khóa SSH cho tài khoản GitHub của bạn.\nBước 1: Tạo Cặp Khóa SSH với ssh-keygen Công cụ dòng lệnh ssh-keygen được sử dụng để tạo ra cặp khóa công khai và riêng tư, là nền tảng của việc xác thực bằng SSH.\nLựa chọn Thuật toán Mã hóa Việc lựa chọn thuật toán mã hóa là một quyết định quan trọng ảnh hưởng đến cả hiệu suất và bảo mật.\nEd25519 (Khuyến nghị): Đây là thuật toán hiện đại, được khuyến nghị sử dụng. Dựa trên Mật mã Đường cong Elliptic (Elliptic Curve Cryptography), Ed25519 cung cấp mức độ bảo mật rất cao với độ dài khóa ngắn hơn, giúp quá trình xác thực diễn ra nhanh hơn. Để tạo khóa Ed25519, hãy mở terminal và chạy lệnh sau, thay thế email bằng email liên kết với tài khoản GitHub của bạn:\nBash\n$ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; RSA (Lựa chọn thay thế): RSA là một thuật toán cũ hơn nhưng vẫn rất phổ biến và tương thích rộng rãi. Nếu bạn cần hỗ trợ các hệ thống cũ không tương thích với Ed25519, RSA là một lựa chọn an toàn. Tuy nhiên, điều cực kỳ quan trọng là phải sử dụng độ dài khóa đủ lớn. Mức khuyến nghị tối thiểu hiện nay là 4096 bits để đảm bảo an toàn.9\nBash\n$ ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; Tầm quan trọng của Passphrase Trong quá trình tạo khóa, bạn sẽ được nhắc nhập một “passphrase”. Đây là một lớp bảo vệ cực kỳ quan trọng và rất nên được sử dụng. Passphrase này sẽ mã hóa file khóa riêng tư của bạn trên đĩa. Điều này có nghĩa là, ngay cả khi máy tính của bạn bị đánh cắp và kẻ tấn công có được file khóa riêng tư, họ cũng không thể sử dụng nó nếu không biết passphrase. Đây là tuyến phòng thủ cuối cùng để bảo vệ danh tính số của bạn.\nLưu khóa và Đặt tên file tùy chỉnh Theo mặc định, ssh-keygen sẽ lưu cặp khóa vào thư mục ~/.ssh/ với tên file là id_ed25519 và id_ed25519.pub (hoặc id_rsa cho RSA). Mặc dù bạn có thể chấp nhận giá trị mặc định, một thực hành tốt là đặt tên file tùy chỉnh, đặc biệt khi bạn dự định quản lý nhiều khóa cho các tài khoản khác nhau. Ví dụ, bạn có thể đặt tên là …","date":1755043200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"9c6e0e5f26e3be1972a03bcb49321a24","permalink":"https://blog.nagih.io.vn/post/git/ssh/","publishdate":"2025-08-13T00:00:00Z","relpermalink":"/post/git/ssh/","section":"post","summary":"SSH and GitHub Tutorial\n","tags":["ssh","git","vi"],"title":"SSH - Github","type":"post"},{"authors":null,"categories":null,"content":"Principles and skills to extend MySQL table design\nTrong thế giới phát triển ứng dụng Backend, việc thiết kế cơ sở dữ liệu (database) không chỉ là một công việc kỹ thuật mà còn là một nghệ thuật đòi hỏi sự tỉ mỉ, hiểu biết sâu sắc về dữ liệu và tầm nhìn dài hạn về tính mở rộng của hệ thống. Đặc biệt, đối với các ứng dụng có nhiều kịch bản phức tạp như chat nhóm (chat group) với nhiều người dùng tham gia, việc lưu trữ dữ liệu đòi hỏi một phương pháp tiếp cận có nguyên tắc.\nDưới đây là 9 nguyên tắc cốt lõi và một số kỹ năng mở rộng mà mọi lập trình viên Backend cần nắm vững khi khởi tạo bảng trong MySQL, đảm bảo ứng dụng không chỉ chạy đúng mà còn hiệu quả và dễ bảo trì:\n1. Mọi Table Luôn Phải Có Các Column Mặc Định\nMột thiết kế table hoàn chỉnh cần có ít nhất 5 trường mặc định để theo dõi lịch sử và tính nhất quán của dữ liệu:\n• version: Ghi lại số lần chỉnh sửa của table, đồng thời liên quan đến các khái niệm khóa lạc quan (optimistic lock) và khóa bi quan (pessimistic lock)\n• creator_id: (Tùy chọn, tùy thuộc vào công ty) Ai là người tạo bản ghi này\n• modifier: Ai là người cuối cùng sửa đổi bản ghi, quan trọng để biết hành động cuối cùng trên table\n• create_at: Thời gian bản ghi được tạo\n• update_at: Thời gian bản ghi được cập nhật lần cuối\n2. Giải Thích Ngữ Nghĩa Các Column Bằng Comment\nKhi viết DDL (Data Definition Language) cho MySQL, PostgreSQL, hoặc bất kỳ hệ quản trị cơ sở dữ liệu nào, hãy luôn thêm comment giải thích ý nghĩa của từng column. Điều này đặc biệt quan trọng cho các trường kiểu liệt kê (enumeration) như status (ví dụ: 1 là private, 2 là public, 3 là friends, 4 là only me). Việc comment rõ ràng giúp các thành viên mới gia nhập team dễ dàng hiểu và làm quen với cấu trúc dữ liệu, tránh sự hiểu lầm về ngữ nghĩa của các trường\n3. Xóa Dữ Liệu Không Phải Xóa “Bay” (Xóa Logic)\nKhông bao giờ sử dụng lệnh DELETE để xóa vật lý dữ liệu trực tiếp trong môi trường sản phẩm. Thay vào đó, hãy sử dụng phương pháp xóa logic (soft delete) bằng cách thêm một trường để đánh dấu bản ghi đã bị xóa hay chưa, và thời gian xóa\n• Ban đầu có thể sử dụng hai trường: is_deleted (0: hoạt động, 1: đã xóa) và deleted_at (thời gian xóa)\n• Cách tối ưu hơn là chỉ sử dụng một trường deleted_at: Nếu giá trị là NULL nghĩa là bản ghi chưa bị xóa; nếu có giá trị thời gian, đó là thời gian bản ghi bị xóa\n• Lưu ý: Giá trị NULL có thể gây nhược điểm nghiêm trọng về hiệu suất index khi dữ liệu lớn, do đó cần cân nhắc kỹ hoặc tìm hiểu sâu hơn về NULL trong database\n4. Quy Ước Đặt Tên Với Prefix (Tiền Tố)\nCác trường (field) trong table nên có các tiền tố (prefix) để dễ dàng xác định nguồn gốc khi các bảng được join lại với nhau. Ví dụ, bảng account có thể có trường acc_number. Việc này cực kỳ quan trọng vì trong thực tế, chúng ta ít khi làm việc với dữ liệu độc lập mà thường phải join nhiều bảng (ít nhất 3 bảng là nguyên tắc làm việc). Nếu không có prefix, việc phân biệt ID hay create_at thuộc về bảng nào khi join sẽ gây ra sự hiểu nhầm và lỗi\n5. Tách Bảng Khi Có Quá Nhiều Trường (Vertical Partitioning)\nMột table không nên có quá nhiều trường (column), tối đa khoảng 20 trường. Nếu vượt quá, cần phải tách bảng dọc (vertical partition). Bảng có nhiều trường sẽ làm dữ liệu lưu trữ lớn, giảm hiệu suất truy vấn và tốn bộ nhớ\n• Tách bảng: Chia thành một bảng chính chứa các trường được truy cập thường xuyên và quan trọng (ví dụ: title, status, thumbnail của một bài post), và một bảng chi tiết chứa các trường ít quan trọng hơn hoặc chỉ hiển thị khi người dùng click vào (ví dụ: content, description)\n• Mối quan hệ giữa hai bảng này thường là 1-1, giúp việc join đơn giản và hiệu quả, không ảnh hưởng đến hiệu suất\n6. Chọn Kiểu Dữ Liệu và Độ Dài Thích Hợp\nMột hệ thống tốt không chỉ chạy đúng mà còn phải chạy hiệu quả. Việc chọn kiểu dữ liệu và độ dài phù hợp giúp:\n• Tiết kiệm bộ nhớ (memory) và dung lượng đĩa (disk)\n• Tối ưu tốc độ query\n• Giảm tỷ lệ Input/Output (I/O). Ví dụ:\nTrường title không nên để VARCHAR(255) nếu độ dài thực tế chỉ khoảng 100 ký tự (như tiêu đề video YouTube/TikTok)\nTrường language chỉ cần CHAR(2) (ví dụ: “en”, “vi”) thay vì VARCHAR dài\nTrường status chỉ nên dùng TINYINT (kích thước 1 byte, lưu trữ 0-255) thay vì INT (kích thước 4 byte, lưu trữ 0-4 tỷ ID) nếu các giá trị chỉ là 1, 2, 3\n7. Nguyên Tắc Not NULL\nKhông nên cho phép giá trị NULL bừa bãi. NULL không phải là một số, một chuỗi hay một biến boolean; nó là một vùng không xác định. NULL có thể:\n• Làm hỏng logic nghiệp vụ nếu quên xử lý\n• Gây lỗi index khi so sánh bằng NULL (ví dụ WHERE column IS NULL thường không sử dụng index hiệu quả). Các trường bắt buộc phải có giá trị (như title, status, create_at) nên được khai báo là NOT NULL. Khi không có giá trị, hãy sử dụng DEFAULT đi kèm với NOT NULL\n8. Chiến Lược Đánh Index\nIndex là chìa khóa để tối ưu hiệu suất truy vấn\n• Nên đánh index cho các trường ít trùng lặp và thường xuyên được sử dụng trong truy vấn, ví dụ: creator_id và create_at (quan trọng khi truy vấn theo thời gian). Luôn có prefix idx_ cho các index\n• Trường …","date":1754956800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"c744e8cb4d13e977402088a198cccaf9","permalink":"https://blog.nagih.io.vn/post/database/9-mysql-table-design-rules--skills/","publishdate":"2025-08-12T00:00:00Z","relpermalink":"/post/database/9-mysql-table-design-rules--skills/","section":"post","summary":"Principles and skills to extend MySQL table design\n","tags":["database","sql","vi"],"title":"9 MySQL Table Design Rules \u0026 Skills","type":"post"},{"authors":null,"categories":null,"content":"Các kiến trức trọng tâm và tất cả các lệnh SQL\nCẩm Nang SQL Toàn Tập: Từ Zero Đến Hero - Tổng Hợp Tất Cả Các Lệnh SQL Quan Trọng Trong thế giới số hiện đại, dữ liệu được ví như “dầu mỏ” mới, và SQL chính là công cụ thiết yếu để khai thác và tinh chế nguồn tài nguyên quý giá đó. Tuy nhiên, đối với người mới bắt đầu, việc học SQL có thể trở nên khó khăn khi phải đối mặt với vô số tài liệu rời rạc và thiếu cấu trúc. Bài viết này được biên soạn như một cuốn cẩm nang toàn diện, cung cấp một lộ trình học tập có hệ thống, từ những viên gạch nền móng đầu tiên như định nghĩa dữ liệu, cho đến các kỹ thuật truy vấn và tối ưu hóa phức tạp. Mục tiêu là trang bị cho người đọc một kiến thức vững chắc và một cái nhìn tổng quan, mạch lạc về Ngôn ngữ Truy vấn có Cấu trúc.\nPhần 1: Giới Thiệu - SQL Là Gì và Tại Sao Bạn Cần Phải Học Nó? Để bắt đầu hành trình làm chủ dữ liệu, điều đầu tiên cần hiểu rõ là công cụ cốt lõi mà chúng ta sẽ sử dụng.\nSQL là gì? SQL, viết tắt của Structured Query Language (Ngôn ngữ Truy vấn có Cấu trúc), là ngôn ngữ tiêu chuẩn được sử dụng để giao tiếp, quản lý và thao tác với các cơ sở dữ liệu quan hệ. Cần phải nhấn mạnh rằng SQL không phải là một ngôn ngữ lập trình đa năng như Python hay Java, mà là một ngôn ngữ chuyên dụng, được thiết kế riêng cho mục đích làm việc với dữ liệu. Một trong những ưu điểm lớn nhất của SQL là nó không đòi hỏi kỹ năng mã hóa phức tạp; thay vào đó, nó sử dụng các từ khóa tiếng Anh gần gũi và dễ hiểu như\nSELECT, INSERT, UPDATE, giúp người dùng dễ dàng tiếp cận và sử dụng.\nLịch sử hình thành SQL ra đời vào những năm 1970, được phát triển bởi hai kỹ sư của IBM là Donald D. Chamberlin và Raymond F. Boyce. Ngôn ngữ này được xây dựng dựa trên nền tảng lý thuyết của mô hình cơ sở dữ liệu quan hệ do Tiến sĩ Edgar F. Codd, cũng là một nhà khoa học của IBM, đề xuất vào năm 1970. Ban đầu, nó có tên là SEQUEL (Structured English Query Language), nhưng sau đó được rút gọn thành SQL do một tranh chấp về thương hiệu. Kể từ đó, SQL đã trở thành một tiêu chuẩn công nghiệp được công nhận toàn cầu.\nVai trò và ứng dụng thực tế Ngày nay, SQL là một kỹ năng không thể thiếu đối với nhiều vị trí trong ngành công nghệ, từ nhà phân tích dữ liệu, nhà khoa học dữ liệu, lập trình viên backend cho đến quản trị viên cơ sở dữ liệu. Sự phổ biến của nó đến từ khả năng ứng dụng trong vô số lĩnh vực:\nPhân tích kinh doanh (Business Intelligence): Các chuyên gia sử dụng SQL để trích xuất, tổng hợp và phân tích dữ liệu từ các hệ thống lớn, nhằm tìm ra các xu hướng (insights) kinh doanh, tạo báo cáo và hỗ trợ việc ra quyết định.\nPhát triển ứng dụng: Hầu hết các ứng dụng web và di động đều cần một nơi để lưu trữ dữ liệu người dùng, thông tin sản phẩm, đơn hàng, v.v. SQL đóng vai trò là cầu nối ở tầng backend, giúp ứng dụng quản lý và thao tác với các dữ liệu này.\nNgành Game: Các trò chơi điện tử sử dụng cơ sở dữ liệu để lưu trữ và quản lý một lượng lớn thông tin như hồ sơ người chơi, điểm số, vật phẩm và thành tích.\nHệ thống giáo dục: Các trường học và tổ chức giáo dục dùng SQL để quản lý hồ sơ sinh viên, thông tin khóa học, điểm số và các hoạt động hành chính khác.\nCác Hệ Quản trị Cơ sở dữ liệu Quan hệ (RDBMS) phổ biến Một điểm quan trọng cần làm rõ là sự khác biệt giữa SQL và các Hệ Quản trị Cơ sở dữ liệu Quan hệ (Relational Database Management System - RDBMS). SQL là ngôn ngữ, trong khi RDBMS là phần mềm, là hệ thống thực thi các câu lệnh SQL đó. Có thể hình dung SQL như “tiếng Anh”, còn RDBMS như một “nhà xuất bản” sử dụng tiếng Anh để tạo ra sách. Việc nhầm lẫn giữa SQL và MySQL là rất phổ biến; MySQL chỉ là một trong nhiều RDBMS sử dụng ngôn ngữ SQL.\nMột số RDBMS phổ biến hiện nay bao gồm:\nMySQL: Một hệ quản trị CSDL quan hệ mã nguồn mở rất phổ biến, đặc biệt trong các ứng dụng web.\nPostgreSQL: Một hệ quản trị CSDL quan hệ mã nguồn mở mạnh mẽ, nổi tiếng với sự tuân thủ chuẩn SQL và các tính năng nâng cao.\nMicrosoft SQL Server: Một sản phẩm thương mại của Microsoft, được sử dụng rộng rãi trong các môi trường doanh nghiệp, đặc biệt là các tổ chức sử dụng hệ sinh thái Windows.\nOracle Database: Một hệ quản trị CSDL thương mại hàng đầu, thường được các tập đoàn lớn sử dụng cho các ứng dụng quan trọng và yêu cầu hiệu suất cao.\nPhần 2: Nền Tảng Của SQL - Hiểu Về Cơ Sở Dữ Liệu Quan Hệ Trước khi viết những câu lệnh SQL đầu tiên, việc nắm vững các khái niệm nền tảng của cơ sở dữ liệu quan hệ là điều kiện tiên quyết. Đây chính là cấu trúc mà SQL được thiết kế để tương tác.\nCác khái niệm cốt lõi Cơ sở dữ liệu (Database): Là một tập hợp các thông tin có liên quan đến nhau, được tổ chức và lưu trữ một cách có hệ thống trên máy tính để có thể dễ dàng truy cập và quản lý.\nCơ sở dữ liệu quan hệ (Relational Database): Là một loại cơ sở dữ liệu mà trong đó dữ liệu được tổ chức thành các bảng (tables) có cấu trúc chặt chẽ. Mô hình này được E.F. Codd đề xuất vào năm 1970 và đã trở thành mô hình thống trị trong quản lý dữ liệu suốt nhiều thập kỷ.\nBảng (Table): Là thành phần cấu trúc cơ bản nhất trong CSDL quan hệ, bao gồm các …","date":1754956800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"3c5037f4a42201b4e10db134d0085b44","permalink":"https://blog.nagih.io.vn/post/database/sql/","publishdate":"2025-08-12T00:00:00Z","relpermalink":"/post/database/sql/","section":"post","summary":"Các kiến trức trọng tâm và tất cả các lệnh SQL\n","tags":["database","sql","vi"],"title":"SQL","type":"post"},{"authors":null,"categories":null,"content":"Overview of Cache\nTrong thế giới phát triển phần mềm, chúng ta luôn bị ám ảnh bởi một từ khóa: hiệu năng. Làm thế nào để ứng dụng chạy nhanh hơn? Làm sao để trang web tải trong chớp mắt? Làm sao để hệ thống chịu được hàng triệu lượt truy cập mà không sụp đổ? Giữa vô vàn câu trả lời, có một khái niệm nền tảng, một kỹ thuật được áp dụng ở mọi quy mô, từ con chip nhỏ trong CPU đến các hệ thống phân tán toàn cầu. Đó chính là Cache.\nNhiều người đã nghe về cache, có thể là “xóa cache trình duyệt” hay “cache của CPU”. Nhưng cache thực sự là gì? Nó hoạt động ra sao và tại sao nó lại quan trọng đến vậy?\nBài viết này sẽ đưa bạn đi từ những khái niệm cơ bản nhất đến các chiến lược chuyên sâu trong thiết kế hệ thống. Hy vọng rằng sau khi đọc xong, bạn sẽ có một cái nhìn rõ ràng và sâu sắc về “vũ khí bí mật” mang tên cache.\nHãy cùng bắt đầu!\nCache Là Gì? Để hiểu về cache, hãy bắt đầu bằng một câu chuyện đơn giản.\nCâu chuyện về Thư viện và Chiếc bàn làm việc Hãy tưởng tượng bạn là một nhà nghiên cứu cần rất nhiều sách cho công việc của mình. Toàn bộ sách được lưu trữ trong một thư viện khổng lồ ở phía bên kia thành phố. Mỗi khi cần một thông tin, bạn phải mất công di chuyển đến thư viện, tìm đúng cuốn sách, đọc, rồi lại đi về. Quá trình này rất chậm chạp và tốn thời gian.\nBây giờ, bạn nghĩ ra một giải pháp thông minh hơn. Thay vì mỗi lần cần lại chạy đi, bạn sẽ mang những cuốn sách hay dùng nhất về đặt ngay trên chiếc bàn làm việc của mình. Chiếc bàn này tuy nhỏ, không thể chứa cả thư viện, nhưng nó ở ngay trước mặt bạn. Lần tới, khi cần thông tin từ những cuốn sách đó, bạn chỉ cần với tay là có ngay, nhanh hơn gấp trăm lần so với việc đi đến thư viện.\nTrong thế giới máy tính, câu chuyện này diễn ra liên tục.\nThư viện khổng lồ chính là nơi lưu trữ dữ liệu chính, ví dụ như ổ cứng (HDD/SSD) hoặc Database. Nơi này có dung lượng lớn nhưng tốc độ truy cập khá chậm.\nChiếc bàn làm việc của bạn chính là Cache.\nCache là một lớp lưu trữ dữ liệu tốc độ cao, có kích thước nhỏ, dùng để chứa một tập hợp con của dữ liệu gốc. Mục đích của nó là để các yêu cầu truy xuất dữ liệu trong tương lai được phục vụ nhanh hơn rất nhiều so với việc phải lấy dữ liệu từ database. Về cơ bản, cache cho phép chúng ta tái sử dụng một cách hiệu quả những dữ liệu đã được truy xuất hoặc tính toán trước đó.\nTại sao Cache lại quan trọng đến vậy? Sử dụng cache mang lại 3 lợi ích cốt lõi, biến nó trở thành một kỹ thuật không thể thiếu trong hầu hết mọi hệ thống máy tính hiện đại.\nTăng tốc độ một cách chóng mặt (Performance): Đây là mục đích chính. Cache thường được triển khai trên các phần cứng truy cập nhanh như RAM (Bộ nhớ truy cập ngẫu nhiên). Tốc độ truy cập RAM nhanh hơn hàng trăm, thậm chí hàng nghìn lần so với ổ đĩa. Việc phục vụ dữ liệu từ cache giúp giảm độ trễ (latency) và tăng số lượng thao tác I/O mỗi giây (IOPS) một cách đáng kể, làm cho ứng dụng trở nên mượt mà và phản hồi nhanh hơn.\nGiảm tải cho hệ thống Backend: Cache hoạt động như một tấm khiên, che chắn cho cơ sở dữ liệu hoặc các dịch vụ API. Thay vì mọi yêu cầu đều phải truy cập vào cơ sở dữ liệu, phần lớn các yêu cầu đọc sẽ được cache xử lý. Điều này giúp cơ sở dữ liệu không bị quá tải, đặc biệt là trong những thời điểm có lưu lượng truy cập tăng đột biến, và giữ cho toàn bộ hệ thống ổn định.\nTiết kiệm chi phí (Cost Efficiency): Ở quy mô lớn, việc phục vụ dữ liệu từ cache trong bộ nhớ (in-memory) có thể rẻ hơn đáng kể so với việc phải nâng cấp liên tục các máy chủ cơ sở dữ liệu hoặc trả chi phí cho lưu lượng mạng cao khi truy xuất dữ liệu từ các dịch vụ đám mây.\nCache Hit và Cache Miss Hoạt động của cache xoay quanh hai kịch bản chính: Cache Hit và Cache Miss. Khi một client (có thể là CPU, trình duyệt web, hoặc ứng dụng của bạn) cần dữ liệu, nó sẽ luôn hỏi cache trước tiên.\nCache Hit (Tìm thấy trong Cache): Đây là kịch bản lý tưởng. Dữ liệu được yêu cầu có tồn tại trong cache. Cache sẽ ngay lập tức trả về dữ liệu này cho client. Quá trình này cực kỳ nhanh chóng.\nCache Miss (Không tìm thấy trong Cache): Đây là kịch bản không mong muốn. Dữ liệu được yêu cầu không có trong cache. Khi đó, hệ thống buộc phải truy cập đến database để lấy dữ liệu. Sau khi lấy được, dữ liệu này sẽ được sao chép một bản vào cache để những lần yêu cầu sau sẽ trở thành cache hit, rồi mới được trả về cho client.\nMột điểm cực kỳ quan trọng cần nhận thức ở đây là sự tồn tại của “Cache Miss” cho thấy một sự thật nền tảng: cache không phải là một phép màu tăng tốc miễn phí. Nó đi kèm với sự đánh đổi và chi phí. Một cache miss vốn dĩ còn chậm hơn một hệ thống không có cache. Bởi vì trong một hệ thống không cache, thời gian truy xuất chỉ đơn giản là thời gian lấy dữ liệu từ nguồn chính. Còn trong một cache miss, tổng thời gian là Thời gian kiểm tra cache (và thất bại) + Thời gian lấy dữ liệu từ database.\nDo đó, mục tiêu của mọi chiến lược caching không chỉ đơn giản là “có cache”, mà là thiết kế một hệ thống nơi tổng thời gian tiết kiệm được từ vô số các cache hit phải lớn hơn rất nhiều so với tổng thời gian bị mất đi do các …","date":1754784000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"46cfb344e391e02950fc6055b5a1d56e","permalink":"https://blog.nagih.io.vn/post/system/cache/","publishdate":"2025-08-10T00:00:00Z","relpermalink":"/post/system/cache/","section":"post","summary":"Overview of Cache\n","tags":["system","vi"],"title":"Cache","type":"post"},{"authors":null,"categories":null,"content":"Giới thiệu về kiến trúc truyền thống và kiến trúc phân tán, sự ra đời của Kafka\nKAFKA ĐƯỢC DÙNG KHI NÀO ? Kiến trúc truyền thống - Lập trình nối tiếp Các function quá lệ thuộc vào nhau: Nếu 1 ngày nào đó, tính năng update cart của 1 nhân viên B bị lỗi thì khi user save order -\u0026gt; update cart nhưng bị lỗi ở đây và trả về lỗi, thực tế nếu hệ thống bỏ qua bước này và cho tới bước update inventory thì có được hay không ? Thực tế, mọi trang thương mại điện tử hiện nay đều có thể xử lý lỗi thành công, miễn là cho user có trải nghiệm tốt là được. Nếu xảy ra lỗi. Các hệ thống sẽ trả cho user phần bù đắp thiệt hại cho user (1 vourcher chẳng hạn) chứ không nên để cho user đặt hàng không thành công.\nTrong hình ảnh tiếp theo, tôi đã cung cấp thêm thời gian phản hồi, có thể thấy mỗi 1 request sẽ mất 150ms\nGiả sử nhân viên B phụ trách tính năng update cart nhưng code yếu thì làm sao ? Tức là tính năng update cart được tính toán nhiều quá, không hiệu quả, và kết quả là bị tắc đường ở đó. Và tất nhiên hệ thống phải đồng bộ. Chẳng hạn khi có 10.000 users bị tắc nghẽn ở đó thì phải làm như thế nào ?\nVà một ngày nào đó, lượng users tăng cao, và cần thêm tính năng mới - Thống kê. Tính năng này thống kê điểm tích lũy cho user để có thể tặng quà cho những người mua hàng nhiều nhất, tích điểm,… Thì khi thêm 1 tính năng bất kỳ, đồng nghĩa với việc sẽ tăng thêm thời gian phản hồi, nguy cơ tăng lỗi cũng sẽ cao hơn\nKiến trúc phân tán Có thể thấy, tất cả các order đều được đẩy vào Message Queue, và ngay lập tức trả về response cho user, không cần quan tâm tới những tác vụ còn lại. Và tất nhiên các tác vụ update cart, update inventory, save payment, save shopping vẫn được tiến hành và được tiến hành theo đúng trình tự.\nVà nhắc lại trường hợp khi nãy, giả sử tính năng update inventory bị lỗi thì chuyện gì sẽ xảy ra? Điều đầu tiên là sẽ không ảnh hưởng tới trải nghiệm người dùng, tiếp theo là message queue có cơ chế tự động sửa lỗi những message bị error, nếu cố gắng sửa đổi trong vòng (10) lần mà không thành công, khi đó sẽ đưa con người vào trực tiếp tham gia quá trình sửa đổi này\nTỉ lệ phản hồi thay vì 150ms như kiến trúc truyền thống thì sẽ chỉ mất 20ms + 5ms từ save order tới message queue, ngay lập tức phản hồi tới user\nTrong kiến trúc phân tán, ta có thể quy định hệ thống làm việc với cường độ 100 orders/time, đến khi nào order hết trong MQ, hay có thể nói là chỉ chỉ đưa cho 100 reqs để làm mà thôi, không được vội vàng, còn lại phải xếp hàng lần lượt, cứ như vậy cho đến hết.\nVà bây giờ, nếu lượng users tăng cao và cần thêm tính năng mới thì cũng không hề ảnh hưởng tới dây chuyền sản xuất\n","date":1754697600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"7fcca94ac047f7f8ceaeb1da94f747c7","permalink":"https://blog.nagih.io.vn/post/system/kafka/","publishdate":"2025-08-09T00:00:00Z","relpermalink":"/post/system/kafka/","section":"post","summary":"Giới thiệu về kiến trúc truyền thống và kiến trúc phân tán, sự ra đời của Kafka\n","tags":["system","vi"],"title":"Kafka","type":"post"},{"authors":null,"categories":null,"content":"Tổng quan về kiến trúc microservices\n1. Kiến trúc Microservices là gì? Hãy tưởng tượng bạn đang xây một ngôi nhà.\nKiến trúc nguyên khối (Monolith): Bạn xây toàn bộ ngôi nhà bằng một khối bê tông khổng lồ duy nhất. Mọi thứ dính liền với nhau. Nếu bạn muốn sửa đường ống nước trong bếp, bạn có thể phải đục cả bức tường lớn, ảnh hưởng đến phòng khách bên cạnh.\nKiến trúc Microservices: Bạn xây ngôi nhà bằng những viên gạch LEGO. Mỗi phòng (phòng khách, phòng ngủ, nhà bếp) là một khối LEGO riêng. Nếu muốn sửa bếp, bạn chỉ cần nhấc khối LEGO “nhà bếp” ra, sửa nó, rồi đặt lại mà không ảnh hưởng gì đến các phòng khác.\nTrong phần mềm, kiến trúc microservices là phương pháp chia một ứng dụng lớn thành nhiều dịch vụ (service) nhỏ, độc lập. Mỗi service đảm nhiệm một chức năng cụ thể, có database riêng, và được phát triển, triển khai, nâng cấp độc lập với các service khác.\n2. Các Service giao tiếp với nhau ra sao? Có giống Frontend gọi tới Backend không? Đây là câu hỏi cốt lõi và quan trọng nhất. Các service (vốn là các backend) giao tiếp với nhau qua mạng. Có hai kiểu giao tiếp chính:\nGiao tiếp Đồng bộ (Synchronous) Giống như một cuộc gọi điện thoại. Service A gọi đến Service B và phải chờ Service B trả lời rồi mới làm việc tiếp.\nCách thức: Thường sử dụng các giao thức như REST API (qua HTTP/S) hoặc gRPC.\nVí dụ: Khi bạn đặt hàng, Service Đơn Hàng sẽ gọi trực tiếp đến Service Kho Hàng để hỏi “Sản phẩm X còn hàng không?”. Service Đơn Hàng sẽ phải đợi câu trả lời từ Service Kho Hàng rồi mới cho phép khách đặt hàng.\nGiống Frontend gọi Backend không? Về mặt kỹ thuật (dùng REST API) thì giống, nhưng bản chất là khác. Đây là giao tiếp giữa các backend với nhau (backend-to-backend), diễn ra bên trong hệ thống mà người dùng không nhìn thấy.\nGiao tiếp Bất đồng bộ (Asynchronous) Giống như gửi email hoặc tin nhắn. Service A gửi một “thông điệp” (message) cho Service B rồi tiếp tục công việc của mình ngay lập tức, không cần chờ B trả lời. Service B sẽ nhận và xử lý thông điệp đó khi nào sẵn sàng.\nCách thức: Sử dụng một hệ thống trung gian gọi là Message Broker (hoặc Message Queue) như RabbitMQ, Kafka.\nVí dụ: Sau khi bạn đặt hàng thành công, Service Đơn Hàng sẽ gửi một thông điệp có nội dung “Đơn hàng #123 đã được tạo” vào một hàng đợi (queue). Service Thông Báo sẽ lắng nghe hàng đợi này, thấy có thông điệp mới liền lấy ra và gửi email xác nhận cho bạn. Service Đơn Hàng không cần quan tâm Service Thông Báo đã gửi email hay chưa.\nƯu điểm: Giúp các service hoàn toàn độc lập (decoupled). Nếu Service Thông Báo bị lỗi, các đơn hàng vẫn được tạo bình thường, các thông điệp sẽ nằm chờ trong queue để được xử lý sau.\n3. Có phải Microservices là kiến trúc ở Backend? Frontend chỉ cần 1 service? Đúng vậy, Microservices chủ yếu là một kiến trúc cho phần backend. Tuy nhiên, việc có nhiều service backend nhỏ lẻ lại tạo ra một vấn đề cho frontend: “Frontend nên gọi đến service nào?”.\nKhông thể để frontend (ứng dụng web, mobile) gọi trực tiếp đến 10 service backend khác nhau. Điều này rất phức tạp, khó quản lý và không an toàn. Giải pháp phổ biến nhất là sử dụng một API Gateway.\nAPI Gateway là gì? Hãy coi API Gateway như một anh chàng lễ tân của toàn bộ hệ thống.\nFrontend chỉ cần nói chuyện với “anh lễ tân” này thôi.\n“Anh lễ tân” sẽ chịu trách nhiệm xác thực yêu cầu, sau đó xem xét yêu cầu này thuộc về phòng ban nào (service nào) và chuyển tiếp đến đúng nơi.\nNó cũng có thể tổng hợp thông tin từ nhiều service trước khi trả về cho frontend.\nVí dụ: Để hiển thị trang chi tiết sản phẩm, frontend chỉ cần gửi 1 yêu cầu duy nhất đến API Gateway. API Gateway sẽ tự động gọi đến Service Sản Phẩm để lấy thông tin sản phẩm và gọi đến Service Đánh Giá để lấy các bình luận, sau đó gộp hai kết quả này lại và trả về cho frontend.\nVậy câu trả lời là: Backend được chia thành nhiều microservices, và thường có một lớp API Gateway làm điểm vào duy nhất cho tất cả các client (web, mobile…).\n4. Vấn đề về Dữ liệu: Mỗi Service một Database? Đây là một trong những quy tắc vàng và cũng là thách thức lớn nhất của microservices: Mỗi microservice phải sở hữu và quản lý cơ sở dữ liệu (database) của riêng mình.\nTại sao? Để đảm bảo tính độc lập tuyệt đối. Nếu Service A và Service B dùng chung một database, khi Service A muốn thay đổi cấu trúc bảng, nó có thể làm sập Service B. Như vậy thì không còn gọi là độc lập nữa.\nThách thức: Làm sao để thực hiện một nghiệp vụ yêu cầu dữ liệu từ nhiều service? Ví dụ: làm sao để đảm bảo khi tạo đơn hàng (Service Đơn Hàng) thì số lượng tồn kho (Service Kho Hàng) cũng phải được trừ đi một cách nhất quán?\nGiải pháp: Cần sử dụng các pattern nâng cao như Saga Pattern để quản lý các giao dịch phân tán (distributed transactions). Đây là một chủ đề phức tạp, nhưng ý tưởng cơ bản là mỗi service sẽ thực hiện phần việc của mình và phát ra sự kiện để service tiếp theo thực hiện phần việc của nó.\n","date":1754524800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755078955,"objectID":"99316e1c0281011c2b6a09a2e4c9ae6c","permalink":"https://blog.nagih.io.vn/post/system/microservices/","publishdate":"2025-08-07T00:00:00Z","relpermalink":"/post/system/microservices/","section":"post","summary":"Tổng quan về kiến trúc microservices\n","tags":["system","vi"],"title":"Microservices","type":"post"}]